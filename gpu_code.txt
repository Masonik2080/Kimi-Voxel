============================================================
FILE: mod.rs
============================================================

// ============================================
// GPU Module - Бесконечный terrain на шейдерах
// ============================================
// Система Player + Camera с режимами 1-го и 3-го лица
// Рефакторинг: разделено на модули по ECS-принципам

pub mod terrain;
pub mod blocks;
pub mod lighting;
pub mod render;
pub mod gui;
pub mod save;
pub mod audio;
pub mod player;
pub mod subvoxel;
pub mod biomes;

// Новые модули после рефакторинга
pub mod core;
pub mod systems;

// Реэкспорт для обратной совместимости
pub use core::app::run;


============================================================
FILE: audio\components.rs
============================================================

// ============================================
// Audio Components - Чистые данные (ECS)
// ============================================

use ultraviolet::Vec3;

/// Состояние системы шагов
pub struct FootstepState {
    pub last_position: Vec3,
    pub distance_traveled: f32,
    pub time_since_last_step: f32,
    pub first_frame: bool,
}

impl FootstepState {
    pub fn new() -> Self {
        Self {
            last_position: Vec3::zero(),
            distance_traveled: 0.0,
            time_since_last_step: 0.0,
            first_frame: true,
        }
    }
}

impl Default for FootstepState {
    fn default() -> Self {
        Self::new()
    }
}

/// Состояние системы прыжков
pub struct JumpState {
    pub was_on_ground: bool,
    pub cooldown: f32,
}

impl JumpState {
    pub fn new() -> Self {
        Self {
            was_on_ground: true,
            cooldown: 0.0,
        }
    }
}

impl Default for JumpState {
    fn default() -> Self {
        Self::new()
    }
}

/// Тип окружения для звука
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub enum EnvironmentType {
    #[default]
    OpenField,
    Forest,
    Cave,
    TightSpace,
    DeepUnderground,
}

/// Параметры окружения для звука
#[derive(Clone, Copy, Debug)]
pub struct EnvironmentParams {
    pub env_type: EnvironmentType,
    pub avg_wall_distance: f32,
    pub enclosure: f32,
    pub ceiling_height: f32,
    pub depth_underground: f32,
}

impl Default for EnvironmentParams {
    fn default() -> Self {
        Self {
            env_type: EnvironmentType::OpenField,
            avg_wall_distance: 20.0,
            enclosure: 0.0,
            ceiling_height: 100.0,
            depth_underground: 0.0,
        }
    }
}

/// Модификаторы звука на основе окружения
#[derive(Clone, Copy, Debug)]
pub struct SoundModifiers {
    pub volume_mult: f32,
    pub pitch_mult: f32,
    pub reverb_amount: f32,
    pub muffling: f32,
}

impl Default for SoundModifiers {
    fn default() -> Self {
        Self::from_environment(&EnvironmentParams::default())
    }
}

impl SoundModifiers {
    /// Рассчитать модификаторы на основе окружения
    pub fn from_environment(env: &EnvironmentParams) -> Self {
        match env.env_type {
            EnvironmentType::OpenField => Self {
                volume_mult: 1.0,
                pitch_mult: 1.0,
                reverb_amount: 0.05,
                muffling: 0.0,
            },
            EnvironmentType::Forest => Self {
                volume_mult: 0.95,
                pitch_mult: 1.0,
                reverb_amount: 0.15,
                muffling: 0.05,
            },
            EnvironmentType::Cave => Self {
                volume_mult: 1.1,
                pitch_mult: 0.98,
                reverb_amount: 0.4 + env.enclosure * 0.3,
                muffling: 0.1,
            },
            EnvironmentType::TightSpace => Self {
                volume_mult: 1.2,
                pitch_mult: 0.95,
                reverb_amount: 0.6,
                muffling: 0.15,
            },
            EnvironmentType::DeepUnderground => Self {
                volume_mult: 1.15,
                pitch_mult: 0.92,
                reverb_amount: 0.5,
                muffling: 0.2,
            },
        }
    }
    
    /// Применить модификаторы к базовым настройкам звука
    pub fn apply(&self, base_volume: f32, base_pitch: f32) -> (f64, f64) {
        let pitch_with_reverb = base_pitch * self.pitch_mult * (1.0 - self.muffling * 0.1);
        let volume = base_volume * self.volume_mult;
        (volume as f64, pitch_with_reverb as f64)
    }
}

/// Тип функции проверки твёрдости блока
pub type BlockSolidChecker = Box<dyn Fn(i32, i32, i32) -> bool + Send + Sync>;


============================================================
FILE: audio\environment.rs
============================================================

// ============================================
// Environment Analyzer - Рейтрейсинг окружения
// ============================================

use ultraviolet::Vec3;
use super::components::{EnvironmentParams, EnvironmentType};

/// Рейтрейсер для анализа окружения
pub struct EnvironmentAnalyzer {
    cached_params: EnvironmentParams,
    time_since_update: f32,
    update_interval: f32,
}

impl EnvironmentAnalyzer {
    pub fn new() -> Self {
        Self {
            cached_params: EnvironmentParams::default(),
            time_since_update: 0.0,
            update_interval: 0.2, // 5 раз в секунду
        }
    }
    
    /// Анализировать окружение вокруг позиции
    pub fn analyze<F>(&mut self, pos: Vec3, dt: f32, is_solid: F) -> EnvironmentParams
    where
        F: Fn(i32, i32, i32) -> bool,
    {
        self.time_since_update += dt;
        
        if self.time_since_update < self.update_interval {
            return self.cached_params;
        }
        self.time_since_update = 0.0;
        
        let distances = self.cast_rays(pos, &is_solid);
        self.cached_params = self.analyze_distances(&distances);
        self.cached_params
    }
    
    /// Получить текущие параметры без пересчёта
    pub fn current_params(&self) -> EnvironmentParams {
        self.cached_params
    }
    
    /// Рейкастим в 26 направлениях
    fn cast_rays<F>(&self, pos: Vec3, is_solid: &F) -> Vec<(Vec3, f32)>
    where
        F: Fn(i32, i32, i32) -> bool,
    {
        let max_distance = 25.0;
        let step = 0.5;
        let mut distances = Vec::with_capacity(26);
        
        for dx in -1..=1 {
            for dy in -1..=1 {
                for dz in -1..=1 {
                    if dx == 0 && dy == 0 && dz == 0 {
                        continue;
                    }
                    
                    let dir = Vec3::new(dx as f32, dy as f32, dz as f32).normalized();
                    let dist = self.raycast_distance(pos, dir, max_distance, step, is_solid);
                    distances.push((dir, dist));
                }
            }
        }
        
        distances
    }
    
    /// Анализ результатов рейкастинга
    fn analyze_distances(&self, distances: &[(Vec3, f32)]) -> EnvironmentParams {
        let max_distance = 25.0;
        
        let horizontal_distances: Vec<f32> = distances.iter()
            .filter(|(dir, _)| dir.y.abs() < 0.5)
            .map(|(_, d)| *d)
            .collect();
        
        let up_distance = distances.iter()
            .filter(|(dir, _)| dir.y > 0.5)
            .map(|(_, d)| *d)
            .next()
            .unwrap_or(max_distance);
        
        let down_distance = distances.iter()
            .filter(|(dir, _)| dir.y < -0.5)
            .map(|(_, d)| *d)
            .next()
            .unwrap_or(max_distance);
        
        let avg_horizontal = if horizontal_distances.is_empty() {
            max_distance
        } else {
            horizontal_distances.iter().sum::<f32>() / horizontal_distances.len() as f32
        };
        
        let min_horizontal = horizontal_distances.iter()
            .cloned()
            .fold(max_distance, f32::min);
        
        let total_avg: f32 = distances.iter().map(|(_, d)| *d).sum::<f32>() / distances.len() as f32;
        let enclosure = 1.0 - (total_avg / max_distance).clamp(0.0, 1.0);
        
        let depth = if up_distance < 5.0 && down_distance > 2.0 {
            (5.0 - up_distance) * 2.0 + down_distance.min(20.0)
        } else {
            0.0
        };
        
        let env_type = self.determine_environment_type(enclosure, min_horizontal, up_distance, depth);
        
        EnvironmentParams {
            env_type,
            avg_wall_distance: avg_horizontal,
            enclosure,
            ceiling_height: up_distance,
            depth_underground: depth,
        }
    }
    
    /// Определить тип окружения
    fn determine_environment_type(
        &self,
        enclosure: f32,
        min_horizontal: f32,
        up_distance: f32,
        depth: f32,
    ) -> EnvironmentType {
        if enclosure > 0.7 && min_horizontal < 2.0 {
            EnvironmentType::TightSpace
        } else if enclosure > 0.5 && up_distance < 8.0 {
            if depth > 10.0 {
                EnvironmentType::DeepUnderground
            } else {
                EnvironmentType::Cave
            }
        } else if enclosure > 0.3 {
            EnvironmentType::Forest
        } else {
            EnvironmentType::OpenField
        }
    }
    
    /// Рейкаст в направлении
    fn raycast_distance<F>(&self, origin: Vec3, dir: Vec3, max_dist: f32, step: f32, is_solid: &F) -> f32
    where
        F: Fn(i32, i32, i32) -> bool,
    {
        let mut dist = step;
        while dist < max_dist {
            let check_pos = origin + dir * dist;
            let bx = check_pos.x.floor() as i32;
            let by = check_pos.y.floor() as i32;
            let bz = check_pos.z.floor() as i32;
            
            if is_solid(bx, by, bz) {
                return dist;
            }
            dist += step;
        }
        max_dist
    }
}

impl Default for EnvironmentAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}


============================================================
FILE: audio\mod.rs
============================================================

// ============================================
// Audio Module - ECS-архитектура
// ============================================
// Пространственный звук с рейтрейсингом окружения

mod components;
mod resources;
mod environment;
mod systems;
mod utils;

pub use components::*;
pub use resources::*;
pub use environment::*;
pub use systems::*;
pub use utils::rand_simple;

use kira::manager::{AudioManager, AudioManagerSettings, backend::DefaultBackend};

/// Главная аудио система - фасад для всех подсистем
pub struct AudioSystem {
    manager: AudioManager,
    sounds: SoundResources,
    environment: EnvironmentAnalyzer,
    current_modifiers: SoundModifiers,
    block_checker: Option<BlockSolidChecker>,
    
    // Состояния подсистем
    footstep_state: FootstepState,
    jump_state: JumpState,
}

impl AudioSystem {
    pub fn new() -> Result<Self, String> {
        let manager = AudioManager::<DefaultBackend>::new(AudioManagerSettings::default())
            .map_err(|e| format!("Failed to create audio manager: {:?}", e))?;
        
        println!("[AUDIO] Аудио система с рейтрейсингом инициализирована");
        
        Ok(Self {
            manager,
            sounds: SoundResources::new(),
            environment: EnvironmentAnalyzer::new(),
            current_modifiers: SoundModifiers::default(),
            block_checker: None,
            footstep_state: FootstepState::new(),
            jump_state: JumpState::new(),
        })
    }
    
    /// Установить функцию проверки твёрдости блока
    pub fn set_block_checker<F>(&mut self, checker: F)
    where
        F: Fn(i32, i32, i32) -> bool + Send + Sync + 'static,
    {
        self.block_checker = Some(Box::new(checker));
    }
    
    pub fn load_sounds(&mut self) -> Result<(), String> {
        self.sounds.load_all()
    }
    
    /// Проиграть звук установки блока
    pub fn play_place_block(&mut self) {
        systems::play_place_block(&mut self.manager, &self.sounds, &self.current_modifiers);
    }
    
    /// Обновить систему (вызывать каждый кадр)
    pub fn update(
        &mut self,
        player_pos: ultraviolet::Vec3,
        _player_forward: ultraviolet::Vec3,
        velocity_y: f32,
        is_moving: bool,
        is_on_ground: bool,
        is_sprinting: bool,
        is_jumping: bool,
        dt: f32,
    ) {
        // Анализируем окружение
        if let Some(ref checker) = self.block_checker {
            let env_params = self.environment.analyze(player_pos, dt, |x, y, z| checker(x, y, z));
            self.current_modifiers = SoundModifiers::from_environment(&env_params);
        }
        
        // Система шагов
        systems::footstep_system(
            &mut self.manager,
            &self.sounds,
            &mut self.footstep_state,
            player_pos,
            is_moving,
            is_on_ground,
            is_sprinting,
            &self.current_modifiers,
            dt,
        );
        
        // Система прыжков
        systems::jump_system(
            &mut self.manager,
            &self.sounds,
            &mut self.jump_state,
            is_on_ground,
            is_jumping,
            velocity_y,
            &self.current_modifiers,
            dt,
        );
    }
    
    /// Получить текущий тип окружения (для отладки)
    #[allow(dead_code)]
    pub fn current_environment(&self) -> EnvironmentType {
        self.environment.current_params().env_type
    }
}


============================================================
FILE: audio\resources.rs
============================================================

// ============================================
// Audio Resources - Загруженные звуки (ECS)
// ============================================

use kira::sound::static_sound::StaticSoundData;

/// Ресурсы звуков - загруженные аудио данные
pub struct SoundResources {
    pub footstep: Option<StaticSoundData>,
    pub jump: Option<StaticSoundData>,
    pub place_block: Option<StaticSoundData>,
}

impl SoundResources {
    pub fn new() -> Self {
        Self {
            footstep: None,
            jump: None,
            place_block: None,
        }
    }
    
    /// Загрузить все звуки
    pub fn load_all(&mut self) -> Result<(), String> {
        self.load_footstep("assets/music/grass-foot-step.wav")?;
        self.load_jump("assets/music/jump.wav")?;
        self.load_place_block("assets/music/place.wav")?;
        Ok(())
    }
    
    fn load_footstep(&mut self, path: &str) -> Result<(), String> {
        match StaticSoundData::from_file(path) {
            Ok(sound) => {
                self.footstep = Some(sound);
                println!("[AUDIO] Загружен звук шага: {}", path);
                Ok(())
            }
            Err(e) => Err(format!("Failed to load footstep sound: {:?}", e))
        }
    }
    
    fn load_jump(&mut self, path: &str) -> Result<(), String> {
        match StaticSoundData::from_file(path) {
            Ok(sound) => {
                self.jump = Some(sound);
                println!("[AUDIO] Загружен звук прыжка: {}", path);
                Ok(())
            }
            Err(e) => Err(format!("Failed to load jump sound: {:?}", e))
        }
    }
    
    fn load_place_block(&mut self, path: &str) -> Result<(), String> {
        match StaticSoundData::from_file(path) {
            Ok(sound) => {
                self.place_block = Some(sound);
                println!("[AUDIO] Загружен звук установки блока: {}", path);
                Ok(())
            }
            Err(e) => Err(format!("Failed to load place block sound: {:?}", e))
        }
    }
}

impl Default for SoundResources {
    fn default() -> Self {
        Self::new()
    }
}


============================================================
FILE: audio\utils.rs
============================================================

// ============================================
// Audio Utils - Утилиты
// ============================================

use std::time::{SystemTime, UNIX_EPOCH};

/// Простой псевдо-рандом без зависимостей
pub fn rand_simple() -> f32 {
    let nanos = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .subsec_nanos();
    (nanos % 1000) as f32 / 1000.0
}


============================================================
FILE: audio\systems\footstep.rs
============================================================

// ============================================
// Footstep System - Система шагов
// ============================================

use kira::{
    manager::AudioManager,
    sound::static_sound::StaticSoundSettings,
    Volume,
};
use ultraviolet::Vec3;

use crate::gpu::audio::{FootstepState, SoundResources, SoundModifiers, rand_simple};

/// Система обработки шагов
pub fn footstep_system(
    audio: &mut AudioManager,
    sounds: &SoundResources,
    state: &mut FootstepState,
    player_pos: Vec3,
    is_moving: bool,
    is_on_ground: bool,
    is_sprinting: bool,
    modifiers: &SoundModifiers,
    dt: f32,
) {
    state.time_since_last_step += dt;
    
    // Первый кадр - инициализация позиции
    if state.first_frame {
        state.first_frame = false;
        state.last_position = player_pos;
        return;
    }
    
    // Расчёт горизонтального движения
    let movement = player_pos - state.last_position;
    let horizontal_movement = Vec3::new(movement.x, 0.0, movement.z);
    let distance = horizontal_movement.mag();
    state.last_position = player_pos;
    
    // Не играем звук если не на земле или не двигаемся
    if !is_on_ground || !is_moving || distance < 0.001 {
        return;
    }
    
    state.distance_traveled += distance;
    
    // Параметры шага
    let step_distance = if is_sprinting { 2.8 } else { 3.5 };
    let min_interval = if is_sprinting { 0.28 } else { 0.4 };
    
    // Проверка на воспроизведение
    if state.distance_traveled >= step_distance && state.time_since_last_step >= min_interval {
        state.distance_traveled = 0.0;
        state.time_since_last_step = 0.0;
        play_footstep(audio, sounds, modifiers);
    }
}

/// Воспроизвести звук шага
fn play_footstep(audio: &mut AudioManager, sounds: &SoundResources, modifiers: &SoundModifiers) {
    if let Some(ref sound_data) = sounds.footstep {
        let volume_variation = 0.85 + rand_simple() * 0.3;
        let pitch_variation = 0.92 + rand_simple() * 0.16;
        
        let base_volume = 0.25 * volume_variation;
        let base_pitch = pitch_variation;
        
        let (volume, pitch) = modifiers.apply(base_volume, base_pitch);
        
        let settings = StaticSoundSettings::new()
            .volume(Volume::Amplitude(volume))
            .playback_rate(pitch);
        
        let _ = audio.play(sound_data.clone().with_settings(settings));
    }
}


============================================================
FILE: audio\systems\jump.rs
============================================================

// ============================================
// Jump System - Система прыжков
// ============================================

use kira::{
    manager::AudioManager,
    sound::static_sound::StaticSoundSettings,
    Volume,
};

use crate::gpu::audio::{JumpState, SoundResources, SoundModifiers, rand_simple};

/// Система обработки прыжков
pub fn jump_system(
    audio: &mut AudioManager,
    sounds: &SoundResources,
    state: &mut JumpState,
    is_on_ground: bool,
    is_jumping: bool,
    velocity_y: f32,
    modifiers: &SoundModifiers,
    dt: f32,
) {
    // Обновление кулдауна
    if state.cooldown > 0.0 {
        state.cooldown -= dt;
    }
    
    // Детекция прыжка
    let just_jumped = state.was_on_ground && 
                      (!is_on_ground || is_jumping) && 
                      velocity_y > 0.5 &&
                      state.cooldown <= 0.0;
    
    if just_jumped {
        play_jump(audio, sounds, modifiers);
        state.cooldown = 0.3;
    }
    
    state.was_on_ground = is_on_ground;
}

/// Воспроизвести звук прыжка
fn play_jump(audio: &mut AudioManager, sounds: &SoundResources, modifiers: &SoundModifiers) {
    if let Some(ref sound_data) = sounds.jump {
        let volume_variation = 0.9 + rand_simple() * 0.2;
        let pitch_variation = 0.95 + rand_simple() * 0.1;
        
        let base_volume = 0.35 * volume_variation;
        let base_pitch = pitch_variation;
        
        let (volume, pitch) = modifiers.apply(base_volume, base_pitch);
        
        let settings = StaticSoundSettings::new()
            .volume(Volume::Amplitude(volume))
            .playback_rate(pitch);
        
        let _ = audio.play(sound_data.clone().with_settings(settings));
    }
}


============================================================
FILE: audio\systems\mod.rs
============================================================

// ============================================
// Audio Systems - Логика (ECS)
// ============================================

mod footstep;
mod jump;
mod place_block;

pub use footstep::footstep_system;
pub use jump::jump_system;
pub use place_block::play_place_block;


============================================================
FILE: audio\systems\place_block.rs
============================================================

// ============================================
// Place Block System - Система установки блоков
// ============================================

use kira::{
    manager::AudioManager,
    sound::static_sound::StaticSoundSettings,
    Volume,
};

use crate::gpu::audio::{SoundResources, SoundModifiers, rand_simple};

/// Воспроизвести звук установки блока
pub fn play_place_block(
    audio: &mut AudioManager,
    sounds: &SoundResources,
    modifiers: &SoundModifiers,
) {
    if let Some(ref sound_data) = sounds.place_block {
        let volume_variation = 0.9 + rand_simple() * 0.2;
        let pitch_variation = 0.95 + rand_simple() * 0.1;
        
        let base_volume = 0.4 * volume_variation;
        let base_pitch = pitch_variation;
        
        let (volume, pitch) = modifiers.apply(base_volume, base_pitch);
        
        let settings = StaticSoundSettings::new()
            .volume(Volume::Amplitude(volume))
            .playback_rate(pitch);
        
        let _ = audio.play(sound_data.clone().with_settings(settings));
    }
}


============================================================
FILE: biomes\climate.rs
============================================================

// ============================================
// Climate Map - Климатическая карта мира
// ============================================

use super::types::ClimateData;
use crate::gpu::terrain::generation::noise::{fbm2d, noise2d};

/// Генератор климатической карты
pub struct ClimateMap {
    seed: u64,
}

impl ClimateMap {
    pub fn new(seed: u64) -> Self {
        Self { seed }
    }

    /// Получить климатические данные для координат
    #[inline]
    pub fn sample(&self, x: f32, z: f32) -> ClimateData {
        let seed_offset = self.seed as f32 * 0.1;
        
        // Температура - крупномасштабный шум
        // Зависит от "широты" (z) + шум для вариации
        let temp_base = fbm2d(
            x * 0.0008 + seed_offset,
            z * 0.0008,
            3
        );
        // Добавляем градиент по Z для имитации широты
        let latitude_factor = (z * 0.0001).sin() * 0.3;
        let temperature = (temp_base + latitude_factor + 0.5).clamp(0.0, 1.0);

        // Влажность - другой масштаб шума
        let humidity = fbm2d(
            x * 0.001 + seed_offset + 500.0,
            z * 0.001 + 500.0,
            3
        ).clamp(0.0, 1.0);

        // Континентальность - ОЧЕНЬ низкая частота для больших горных массивов
        let continentalness = fbm2d(
            x * 0.0002 + seed_offset + 1000.0,
            z * 0.0002 + 1000.0,
            4
        );

        // Эрозия - тоже низкая частота
        let erosion = fbm2d(
            x * 0.0005 + seed_offset + 2000.0,
            z * 0.0005 + 2000.0,
            3
        );

        ClimateData {
            temperature,
            humidity,
            continentalness,
            erosion,
        }
    }

    /// Быстрая версия для LOD
    #[inline]
    pub fn sample_fast(&self, x: f32, z: f32) -> ClimateData {
        let seed_offset = self.seed as f32 * 0.1;
        
        let temperature = noise2d(
            x * 0.0008 + seed_offset,
            z * 0.0008
        );
        
        let humidity = noise2d(
            x * 0.001 + seed_offset + 500.0,
            z * 0.001 + 500.0
        );

        let continentalness = noise2d(
            x * 0.0003 + seed_offset + 1000.0,
            z * 0.0003 + 1000.0
        );

        ClimateData {
            temperature,
            humidity,
            continentalness,
            erosion: 0.5,
        }
    }
}

impl Default for ClimateMap {
    fn default() -> Self {
        Self::new(42)
    }
}

use std::sync::OnceLock;
static CLIMATE_MAP: OnceLock<ClimateMap> = OnceLock::new();

pub fn climate_map() -> &'static ClimateMap {
    CLIMATE_MAP.get_or_init(ClimateMap::default)
}


============================================================
FILE: biomes\mod.rs
============================================================

// ============================================
// Biomes Module - Система биомов
// ============================================
// 
// Климатическая карта определяет биом:
// - Temperature (температура): холодно -> жарко
// - Humidity (влажность): сухо -> влажно
// - Continentalness: океан -> суша -> горы
// - Erosion: плоско -> холмисто
//
// Каждый биом имеет свой тип генерации terrain:
// - Flat: болота, тундра
// - Rolling: равнины, леса
// - Mountains3D: горы с 3D шумом (карнизы, нависания)
// - Valley: долины с крутыми стенами
// - Ocean: океанское дно

mod types;
mod climate;
mod registry;
mod selector;
mod terrain_gen;

pub use types::*;
pub use climate::*;
pub use registry::*;
pub use selector::*;
pub use terrain_gen::*;


============================================================
FILE: biomes\registry.rs
============================================================

// ============================================
// Biome Registry - Реестр биомов
// ============================================

use super::types::*;
use crate::gpu::blocks::{SAND, STONE, GRASS, DIRT, SNOW, BlockType};
use std::sync::OnceLock;

/// Реестр всех биомов
pub struct BiomeRegistry {
    biomes: Vec<BiomeDefinition>,
}

impl BiomeRegistry {
    pub fn new() -> Self {
        let mut registry = Self { biomes: Vec::new() };
        registry.register_default_biomes();
        registry
    }

    fn register_default_biomes(&mut self) {
        // Океан - глубоко под водой
        self.register(
            BiomeDefinition::new(BIOME_OCEAN, "ocean", SAND, SAND, STONE)
                .with_terrain(-15.0, 5.0, TerrainType::Ocean)
                .with_climate(0.5, 1.0)
        );

        // Равнины - стандартный биом
        self.register(
            BiomeDefinition::new(BIOME_PLAINS, "plains", GRASS, DIRT, STONE)
                .with_terrain(20.0, 8.0, TerrainType::Rolling)
                .with_climate(0.5, 0.4)
        );

        // Пустыня - жарко и сухо
        self.register(
            BiomeDefinition::new(BIOME_DESERT, "desert", SAND, SAND, STONE)
                .with_terrain(22.0, 6.0, TerrainType::Rolling)
                .with_climate(0.9, 0.1)
        );

        // Лес - умеренный и влажный
        self.register(
            BiomeDefinition::new(BIOME_FOREST, "forest", GRASS, DIRT, STONE)
                .with_terrain(25.0, 12.0, TerrainType::Rolling)
                .with_climate(0.5, 0.6)
        );

        // Тайга - холодный лес
        self.register(
            BiomeDefinition::new(BIOME_TAIGA, "taiga", GRASS, DIRT, STONE)
                .with_terrain(22.0, 10.0, TerrainType::Rolling)
                .with_climate(0.25, 0.6)
        );

        // Тундра - холодно и сухо
        self.register(
            BiomeDefinition::new(BIOME_TUNDRA, "tundra", SNOW, DIRT, STONE)
                .with_terrain(18.0, 4.0, TerrainType::Flat)
                .with_climate(0.0, 0.3)
        );

        // Болото - плоское, чуть ниже воды
        self.register(
            BiomeDefinition::new(BIOME_SWAMP, "swamp", GRASS, DIRT, STONE)
                .with_terrain(8.0, 2.0, TerrainType::Flat)
                .with_climate(0.6, 0.9)
        );

        // Горы - плавные величественные склоны
        self.register(
            BiomeDefinition::new(BIOME_MOUNTAINS, "mountains", STONE, STONE, STONE)
                .with_terrain(25.0, 60.0, TerrainType::Mountains3D)
                .with_climate(0.3, 0.3)
                .with_3d_noise(0.2)
        );

        // Саванна - жарко, умеренно сухо
        self.register(
            BiomeDefinition::new(BIOME_SAVANNA, "savanna", GRASS, DIRT, STONE)
                .with_terrain(20.0, 5.0, TerrainType::Flat)
                .with_climate(0.8, 0.3)
        );

        // Джунгли - жарко и очень влажно
        self.register(
            BiomeDefinition::new(BIOME_JUNGLE, "jungle", GRASS, DIRT, STONE)
                .with_terrain(28.0, 15.0, TerrainType::Rolling)
                .with_climate(0.9, 0.9)
        );
    }

    pub fn register(&mut self, biome: BiomeDefinition) {
        let id = biome.id as usize;
        if id >= self.biomes.len() {
            self.biomes.resize(id + 1, self.biomes.first().cloned().unwrap_or_else(|| {
                BiomeDefinition::new(0, "unknown", STONE, STONE, STONE)
                    .with_terrain(20.0, 10.0, TerrainType::Rolling)
            }));
        }
        self.biomes[id] = biome;
    }

    #[inline]
    pub fn get(&self, id: BiomeId) -> &BiomeDefinition {
        self.biomes.get(id as usize).unwrap_or(&self.biomes[0])
    }

    pub fn count(&self) -> usize {
        self.biomes.len()
    }
}

impl Default for BiomeRegistry {
    fn default() -> Self {
        Self::new()
    }
}

static BIOME_REGISTRY: OnceLock<BiomeRegistry> = OnceLock::new();

pub fn biome_registry() -> &'static BiomeRegistry {
    BIOME_REGISTRY.get_or_init(BiomeRegistry::new)
}


============================================================
FILE: biomes\selector.rs
============================================================

// ============================================
// Biome Selector - Выбор биома по климату
// ============================================

use super::types::*;
use super::climate::{climate_map, ClimateMap};
use super::registry::biome_registry;

/// Селектор биомов на основе климатической карты
pub struct BiomeSelector {
    climate: &'static ClimateMap,
}

impl BiomeSelector {
    pub fn new() -> Self {
        Self {
            climate: climate_map(),
        }
    }

    /// Получить биом для координат
    #[inline]
    pub fn get_biome(&self, x: i32, z: i32) -> BiomeId {
        let climate = self.climate.sample(x as f32, z as f32);
        self.select_from_climate(&climate)
    }

    /// Получить биом и климат для координат
    #[inline]
    pub fn get_biome_with_climate(&self, x: f32, z: f32) -> (BiomeId, ClimateData) {
        let climate = self.climate.sample(x, z);
        let biome = self.select_from_climate(&climate);
        (biome, climate)
    }

    /// Получить определение биома
    #[inline]
    pub fn get_biome_def(&self, x: i32, z: i32) -> &'static BiomeDefinition {
        let id = self.get_biome(x, z);
        biome_registry().get(id)
    }

    /// Выбор биома по климатическим данным
    fn select_from_climate(&self, climate: &ClimateData) -> BiomeId {
        let t = climate.temperature;
        let h = climate.humidity;
        let c = climate.continentalness;

        // Океан - низкая континентальность
        if c < 0.25 {
            return BIOME_OCEAN;
        }

        // Горы - появляются при высокой континентальности
        // Упрощённое условие - просто высокий континентальность
        if c > 0.55 {
            return BIOME_MOUNTAINS;
        }

        // Температурно-влажностная сетка
        match (t, h) {
            // Холодно (t < 0.25)
            (t, h) if t < 0.25 && h < 0.4 => BIOME_TUNDRA,
            (t, _) if t < 0.25 => BIOME_TAIGA,

            // Жарко (t > 0.75)
            (t, h) if t > 0.75 && h < 0.25 => BIOME_DESERT,
            (t, h) if t > 0.75 && h > 0.7 => BIOME_JUNGLE,
            (t, _) if t > 0.75 => BIOME_SAVANNA,

            // Умеренно (0.25 <= t <= 0.75)
            (_, h) if h > 0.8 => BIOME_SWAMP,
            (_, h) if h > 0.5 => BIOME_FOREST,
            _ => BIOME_PLAINS,
        }
    }
}

impl Default for BiomeSelector {
    fn default() -> Self {
        Self::new()
    }
}

use std::sync::OnceLock;
static BIOME_SELECTOR: OnceLock<BiomeSelector> = OnceLock::new();

pub fn biome_selector() -> &'static BiomeSelector {
    BIOME_SELECTOR.get_or_init(BiomeSelector::default)
}


============================================================
FILE: biomes\terrain_gen.rs
============================================================

// ============================================
// Biome Terrain Generation - Генерация terrain по биому
// ============================================

use super::types::*;
use super::selector::biome_selector;
use super::registry::biome_registry;
use crate::gpu::terrain::generation::noise::{fbm2d, noise3d};

/// Генератор terrain с учётом биомов
pub struct BiomeTerrainGen;

impl BiomeTerrainGen {
    /// Получить высоту terrain с ПЛАВНЫМ переходом между биомами
    /// Использует континентальность напрямую для плавных склонов
    #[inline]
    pub fn get_height(x: f32, z: f32) -> f32 {
        let (biome_id, climate) = biome_selector().get_biome_with_climate(x, z);
        let biome = biome_registry().get(biome_id);
        
        // Континентальность определяет "горность" - это уже плавное значение из шума!
        let c = climate.continentalness;
        
        // Базовая высота равнины
        let plains_height = 20.0 + fbm2d(x * 0.005, z * 0.005, 3) * 8.0;
        
        // Если это не горы - просто возвращаем высоту биома
        if biome.terrain_type != TerrainType::Mountains3D {
            // Но даже для равнин добавляем небольшой подъём при высокой континентальности
            let lift = (c - 0.4).max(0.0) * 30.0;
            return Self::height_for_biome(x, z, biome, &climate) + lift;
        }
        
        // Для гор: плавный переход от равнины к горам на основе континентальности
        // c = 0.55 это граница гор, делаем плавный подъём от 0.3 до 0.8
        let mountain_factor = ((c - 0.3) / 0.5).clamp(0.0, 1.0);
        // Smoothstep для ещё более плавного перехода
        let mountain_factor = mountain_factor * mountain_factor * (3.0 - 2.0 * mountain_factor);
        
        // Высота горы
        let mountain_height = Self::raw_mountain_height(x, z, biome);
        
        // Интерполяция: равнина -> предгорья -> горы
        plains_height + (mountain_height - plains_height) * mountain_factor
    }
    
    /// Сырая высота горы без блендинга
    fn raw_mountain_height(x: f32, z: f32, biome: &BiomeDefinition) -> f32 {
        // Очень крупный масштаб для плавных склонов
        let main_shape = fbm2d(x * 0.0004, z * 0.0004, 4);
        let main_shape = main_shape.max(0.0).powf(0.8);
        
        // Вторичные холмы
        let secondary = fbm2d(x * 0.001, z * 0.001, 3) * 0.3;
        
        // Мягкие гребни
        let ridge_raw = fbm2d(x * 0.0015, z * 0.0015, 3);
        let ridge = 1.0 - (ridge_raw * 2.0 - 1.0).abs();
        let ridge = ridge * ridge * 0.2;
        
        // Детали
        let detail = fbm2d(x * 0.005, z * 0.005, 2) * 0.08;
        
        let combined = main_shape * 0.5 + secondary + ridge + detail;
        
        biome.base_height + combined * biome.height_variation
    }

    /// Генерация высоты для конкретного биома
    fn height_for_biome(x: f32, z: f32, biome: &BiomeDefinition, climate: &ClimateData) -> f32 {
        match biome.terrain_type {
            TerrainType::Flat => Self::flat_terrain(x, z, biome),
            TerrainType::Rolling => Self::rolling_terrain(x, z, biome, climate),
            TerrainType::Mountains3D => Self::mountain_terrain(x, z, biome),
            TerrainType::Valley => Self::valley_terrain(x, z, biome),
            TerrainType::Ocean => Self::ocean_terrain(x, z, biome),
        }
    }

    /// Плоский terrain (болота, тундра)
    fn flat_terrain(x: f32, z: f32, biome: &BiomeDefinition) -> f32 {
        let noise = fbm2d(x * 0.01, z * 0.01, 2);
        biome.base_height + noise * biome.height_variation
    }

    /// Холмистый terrain (равнины, леса)
    fn rolling_terrain(x: f32, z: f32, biome: &BiomeDefinition, climate: &ClimateData) -> f32 {
        let base = fbm2d(x * 0.005, z * 0.005, 4);
        let detail = fbm2d(x * 0.02, z * 0.02, 2) * 0.3;
        
        // Эрозия сглаживает terrain
        let erosion_factor = 1.0 - climate.erosion * 0.5;
        
        biome.base_height + (base + detail) * biome.height_variation * erosion_factor
    }

    /// Горный terrain - плавные реалистичные горы
    fn mountain_terrain(x: f32, z: f32, biome: &BiomeDefinition) -> f32 {
        // === Очень крупный масштаб для плавных склонов ===
        // Главная форма горы - огромный купол/конус
        let main_shape = fbm2d(x * 0.0003, z * 0.0003, 4);
        // Делаем форму более выпуклой (как купол)
        let main_shape = main_shape.max(0.0).powf(0.7);
        
        // === Вторичные холмы на склонах ===
        let secondary = fbm2d(x * 0.0008, z * 0.0008, 3) * 0.4;
        
        // === Мягкие гребни (не острые!) ===
        let ridge_raw = fbm2d(x * 0.001, z * 0.001, 3);
        let ridge = 1.0 - (ridge_raw * 2.0 - 1.0).abs();
        let ridge = ridge * ridge * 0.25; // Очень мягкие
        
        // === Небольшие вариации на поверхности ===
        let detail = fbm2d(x * 0.004, z * 0.004, 2) * 0.1;
        
        // === Комбинируем - главная форма доминирует ===
        let combined = main_shape * 0.6 + secondary + ridge + detail;
        
        // Плавная S-кривая для естественного профиля склона
        let smooth = combined * combined * (3.0 - 2.0 * combined);
        
        biome.base_height + smooth * biome.height_variation
    }

    /// Долины с крутыми стенами
    fn valley_terrain(x: f32, z: f32, biome: &BiomeDefinition) -> f32 {
        let base = fbm2d(x * 0.004, z * 0.004, 3);
        
        // Создаём V-образный профиль
        let valley_shape = (fbm2d(x * 0.002, z * 0.002, 2) * 2.0 - 1.0).abs();
        
        biome.base_height + base * biome.height_variation * valley_shape
    }

    /// Океанское дно
    fn ocean_terrain(x: f32, z: f32, biome: &BiomeDefinition) -> f32 {
        let base = fbm2d(x * 0.003, z * 0.003, 3);
        biome.base_height + base * biome.height_variation
    }

    /// 3D density для гор (карнизы, пещеры в горах)
    /// Возвращает density: > 0 = твёрдый блок, < 0 = воздух
    #[inline]
    pub fn get_3d_density(x: f32, y: f32, z: f32) -> f32 {
        let biome = biome_selector().get_biome_def(x as i32, z as i32);
        
        if biome.noise_3d_strength < 0.01 {
            // Нет 3D шума - используем простую карту высот
            let height = Self::get_height(x, z);
            return height - y;
        }

        // Базовая высота
        let base_height = Self::get_height(x, z);
        let height_density = base_height - y;

        // 3D шум для карнизов и нависаний
        let noise_3d = Self::sample_3d_noise(x, y, z);
        
        // Смешиваем: чем выше noise_3d_strength, тем больше влияние 3D шума
        let blend = biome.noise_3d_strength;
        height_density * (1.0 - blend * 0.5) + noise_3d * blend * 30.0
    }

    /// 3D шум для создания карнизов и пещер в горах
    fn sample_3d_noise(x: f32, y: f32, z: f32) -> f32 {
        // Крупный шум для больших структур
        let large = noise3d(x * 0.02, y * 0.02, z * 0.02);
        
        // Средний шум для карнизов
        let medium = noise3d(x * 0.05, y * 0.08, z * 0.05) * 0.5;
        
        // Мелкий шум для деталей
        let small = noise3d(x * 0.1, y * 0.1, z * 0.1) * 0.25;
        
        // Вертикальный градиент - больше пустот наверху
        let vertical_bias = (y * 0.01).tanh() * 0.2;
        
        large + medium + small + vertical_bias - 0.5
    }

    /// Проверка: есть ли блок в точке (для 3D terrain)
    #[inline]
    pub fn is_solid(x: f32, y: f32, z: f32) -> bool {
        Self::get_3d_density(x, y, z) > 0.0
    }
}

// Глобальные функции для удобства
pub fn get_biome_height(x: f32, z: f32) -> f32 {
    BiomeTerrainGen::get_height(x, z)
}

pub fn get_3d_density(x: f32, y: f32, z: f32) -> f32 {
    BiomeTerrainGen::get_3d_density(x, y, z)
}

pub fn is_solid_3d(x: f32, y: f32, z: f32) -> bool {
    BiomeTerrainGen::is_solid(x, y, z)
}


============================================================
FILE: biomes\types.rs
============================================================

// ============================================
// Biome Types - Типы биомов
// ============================================

use crate::gpu::blocks::BlockType;

/// ID биома
pub type BiomeId = u8;

// Константы биомов
pub const BIOME_OCEAN: BiomeId = 0;
pub const BIOME_PLAINS: BiomeId = 1;
pub const BIOME_DESERT: BiomeId = 2;
pub const BIOME_FOREST: BiomeId = 3;
pub const BIOME_TAIGA: BiomeId = 4;
pub const BIOME_TUNDRA: BiomeId = 5;
pub const BIOME_SWAMP: BiomeId = 6;
pub const BIOME_MOUNTAINS: BiomeId = 7;
pub const BIOME_SAVANNA: BiomeId = 8;
pub const BIOME_JUNGLE: BiomeId = 9;

/// Тип генерации terrain для биома
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TerrainType {
    /// Плоский terrain (болота, равнины)
    Flat,
    /// Стандартные холмы
    Rolling,
    /// Горы с 3D шумом (карнизы, пещеры)
    Mountains3D,
    /// Долины с крутыми стенами
    Valley,
    /// Океан (ниже уровня воды)
    Ocean,
}

/// Определение биома
#[derive(Clone, Debug)]
pub struct BiomeDefinition {
    pub id: BiomeId,
    pub name: &'static str,
    /// Поверхностный блок
    pub surface_block: BlockType,
    /// Подповерхностный блок
    pub subsurface_block: BlockType,
    /// Глубинный блок
    pub deep_block: BlockType,
    /// Базовая высота terrain
    pub base_height: f32,
    /// Амплитуда высоты
    pub height_variation: f32,
    /// Тип генерации terrain
    pub terrain_type: TerrainType,
    /// Температура (0.0 - холодно, 1.0 - жарко)
    pub temperature: f32,
    /// Влажность (0.0 - сухо, 1.0 - влажно)
    pub humidity: f32,
    /// Сила 3D шума для гор (0.0 - нет, 1.0 - максимум)
    pub noise_3d_strength: f32,
}

impl BiomeDefinition {
    pub const fn new(
        id: BiomeId,
        name: &'static str,
        surface_block: BlockType,
        subsurface_block: BlockType,
        deep_block: BlockType,
    ) -> Self {
        Self {
            id,
            name,
            surface_block,
            subsurface_block,
            deep_block,
            base_height: 20.0,
            height_variation: 10.0,
            terrain_type: TerrainType::Rolling,
            temperature: 0.5,
            humidity: 0.5,
            noise_3d_strength: 0.0,
        }
    }

    pub const fn with_terrain(mut self, base_height: f32, height_variation: f32, terrain_type: TerrainType) -> Self {
        self.base_height = base_height;
        self.height_variation = height_variation;
        self.terrain_type = terrain_type;
        self
    }

    pub const fn with_climate(mut self, temperature: f32, humidity: f32) -> Self {
        self.temperature = temperature;
        self.humidity = humidity;
        self
    }

    pub const fn with_3d_noise(mut self, strength: f32) -> Self {
        self.noise_3d_strength = strength;
        self
    }
}

/// Климатические данные для точки
#[derive(Clone, Copy, Debug)]
pub struct ClimateData {
    pub temperature: f32,
    pub humidity: f32,
    pub continentalness: f32,
    pub erosion: f32,
}


============================================================
FILE: blocks\block_breaker.rs
============================================================

// ============================================
// Block Breaker - Логика ломания блоков
// ============================================
// Обрабатывает:
// - Raycast от камеры к блоку
// - Прогресс ломания (анимация трещин)
// - Удаление блока из мира
// - Выделение целевого блока

use ultraviolet::Vec3;
use std::sync::Arc;
use std::sync::RwLock;
use crate::gpu::blocks::BlockType;
use crate::gpu::player::Player;
use crate::gpu::terrain::get_height;
use crate::gpu::terrain::WorldChanges;

/// Максимальная дистанция ломания блоков
pub const MAX_BREAK_DISTANCE: f32 = 5.0;

/// Скорость ломания (базовая, без инструментов)
pub const BASE_BREAK_SPEED: f32 = 1.0;

/// Результат raycast — информация о блоке под прицелом
#[derive(Debug, Clone, Copy)]
pub struct BlockHit {
    /// Позиция блока (целые координаты)
    pub block_pos: [i32; 3],
    
    /// Точка попадания луча (мировые координаты)
    pub hit_point: Vec3,
    
    /// Нормаль грани, в которую попал луч
    pub hit_normal: Vec3,
    
    /// Дистанция от глаз до точки попадания
    pub distance: f32,
    
    /// Тип блока
    pub block_type: BlockType,
}

/// Состояние процесса ломания
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum BreakState {
    /// Не ломаем
    Idle,
    /// В процессе ломания
    Breaking {
        /// Позиция ломаемого блока
        block_pos: [i32; 3],
        /// Прогресс (0.0 - 1.0)
        progress: f32,
    },
    /// Блок сломан (на один кадр)
    Broken {
        block_pos: [i32; 3],
        block_type: BlockType,
    },
}

/// Система ломания блоков
pub struct BlockBreaker {
    /// Текущее состояние
    state: BreakState,
    
    /// Блок под прицелом (если есть)
    target_block: Option<BlockHit>,
    
    /// Зажата ли кнопка ломания (ЛКМ)
    is_breaking: bool,
    
    /// Зажата ли кнопка установки (ПКМ)
    is_placing: bool,
    
    /// Максимальная дистанция
    max_distance: f32,
    
    /// Множитель скорости ломания (от инструмента)
    break_speed_multiplier: f32,
    
    /// Ссылка на изменения мира
    world_changes: Arc<RwLock<WorldChanges>>,
}

impl BlockBreaker {
    pub fn new(world_changes: Arc<RwLock<WorldChanges>>) -> Self {
        Self {
            state: BreakState::Idle,
            target_block: None,
            is_breaking: false,
            is_placing: false,
            max_distance: MAX_BREAK_DISTANCE,
            break_speed_multiplier: 1.0,
            world_changes,
        }
    }
    
    /// Обработка нажатия кнопки мыши
    pub fn process_mouse_button(&mut self, button: MouseButton, pressed: bool) -> Option<BlockHit> {
        match button {
            MouseButton::Left => {
                // Мгновенное ломание по клику
                if pressed {
                    if let Some(hit) = &self.target_block {
                        // Сразу ломаем блок
                        let broken_block = *hit;
                        
                        {
                            let mut changes = self.world_changes.write().unwrap();
                            changes.break_block(
                                broken_block.block_pos[0],
                                broken_block.block_pos[1],
                                broken_block.block_pos[2],
                            );
                        }
                        
                        return Some(broken_block);
                    }
                }
            }
            MouseButton::Right => {
                self.is_placing = pressed;
            }
            MouseButton::Middle => {
                // Средняя кнопка — пока не используется (можно для pick block)
            }
        }
        None
    }
    
    /// Установить множитель скорости (от инструмента)
    pub fn set_break_speed(&mut self, multiplier: f32) {
        self.break_speed_multiplier = multiplier;
    }
    
    /// Обновление каждый кадр — только raycast для выделения
    pub fn update(&mut self, player: &Player, _dt: f32) {
        // Raycast для поиска блока под прицелом
        self.target_block = self.raycast_block(player);
    }
    
    /// Raycast от глаз игрока в направлении взгляда
    fn raycast_block(&self, player: &Player) -> Option<BlockHit> {
        let origin = player.eye_position();
        let direction = player.forward();
        
        // DDA (Digital Differential Analyzer) алгоритм для воксельного raycast
        self.dda_raycast(origin, direction, self.max_distance)
    }
    
    /// DDA Raycast через воксельную сетку
    fn dda_raycast(&self, origin: Vec3, direction: Vec3, max_dist: f32) -> Option<BlockHit> {
        // Текущая позиция в блоках
        let mut block_x = origin.x.floor() as i32;
        let mut block_y = origin.y.floor() as i32;
        let mut block_z = origin.z.floor() as i32;
        
        // Направление шага (+1 или -1)
        let step_x = if direction.x >= 0.0 { 1 } else { -1 };
        let step_y = if direction.y >= 0.0 { 1 } else { -1 };
        let step_z = if direction.z >= 0.0 { 1 } else { -1 };
        
        // Дельта t для пересечения одного блока
        let t_delta_x = if direction.x.abs() < 1e-10 { f32::MAX } else { (1.0 / direction.x).abs() };
        let t_delta_y = if direction.y.abs() < 1e-10 { f32::MAX } else { (1.0 / direction.y).abs() };
        let t_delta_z = if direction.z.abs() < 1e-10 { f32::MAX } else { (1.0 / direction.z).abs() };
        
        // Начальные t до первой границы блока
        let mut t_max_x = if direction.x >= 0.0 {
            ((block_x + 1) as f32 - origin.x) / direction.x
        } else {
            (block_x as f32 - origin.x) / direction.x
        };
        let mut t_max_y = if direction.y >= 0.0 {
            ((block_y + 1) as f32 - origin.y) / direction.y
        } else {
            (block_y as f32 - origin.y) / direction.y
        };
        let mut t_max_z = if direction.z >= 0.0 {
            ((block_z + 1) as f32 - origin.z) / direction.z
        } else {
            (block_z as f32 - origin.z) / direction.z
        };
        
        // Нормаль последней пересечённой грани
        let mut hit_normal = Vec3::zero();
        let mut distance = 0.0_f32;
        
        // Итерируем пока не превысим дистанцию
        let max_steps = (max_dist * 2.0) as i32 + 1;
        
        for _ in 0..max_steps {
            // Проверяем текущий блок
            if let Some(block_type) = self.get_block_at(block_x, block_y, block_z) {
                if block_type != super::AIR {
                    // Нашли твёрдый блок!
                    let hit_point = origin + direction * distance;
                    
                    return Some(BlockHit {
                        block_pos: [block_x, block_y, block_z],
                        hit_point,
                        hit_normal,
                        distance,
                        block_type,
                    });
                }
            }
            
            // Переходим к следующему блоку (выбираем ближайшую границу)
            if t_max_x < t_max_y {
                if t_max_x < t_max_z {
                    distance = t_max_x;
                    t_max_x += t_delta_x;
                    block_x += step_x;
                    hit_normal = Vec3::new(-step_x as f32, 0.0, 0.0);
                } else {
                    distance = t_max_z;
                    t_max_z += t_delta_z;
                    block_z += step_z;
                    hit_normal = Vec3::new(0.0, 0.0, -step_z as f32);
                }
            } else {
                if t_max_y < t_max_z {
                    distance = t_max_y;
                    t_max_y += t_delta_y;
                    block_y += step_y;
                    hit_normal = Vec3::new(0.0, -step_y as f32, 0.0);
                } else {
                    distance = t_max_z;
                    t_max_z += t_delta_z;
                    block_z += step_z;
                    hit_normal = Vec3::new(0.0, 0.0, -step_z as f32);
                }
            }
            
            // Проверка дистанции
            if distance > max_dist {
                break;
            }
        }
        
        None
    }
    
    /// Получить тип блока в координатах
    fn get_block_at(&self, x: i32, y: i32, z: i32) -> Option<BlockType> {
        use crate::gpu::terrain::{CaveParams, is_cave};
        use crate::gpu::biomes::biome_selector;
        
        // Сначала проверяем изменения мира
        {
            let changes = self.world_changes.read().unwrap();
            if let Some(block_type) = changes.get_block(x, y, z) {
                return Some(block_type);
            }
        }
        
        // Иначе используем процедурную генерацию с биомами
        let terrain_height = get_height(x as f32, z as f32) as i32;
        
        // Над поверхностью — воздух
        if y > terrain_height {
            return Some(super::AIR);
        }
        
        // Проверяем пещеры
        let cave_params = CaveParams::default();
        let cave_ceiling = terrain_height - cave_params.surface_offset;
        
        if y >= cave_params.min_height && y < cave_ceiling {
            if is_cave(x, y, z, &cave_params) {
                return Some(super::AIR);
            }
        }
        
        // Получаем биом и используем его блоки
        let biome = biome_selector().get_biome_def(x, z);
        
        if y < -29 {
            Some(super::DEEPSLATE)
        } else if y < terrain_height - 4 {
            Some(biome.deep_block)
        } else if y < terrain_height {
            Some(biome.subsurface_block)
        } else {
            Some(biome.surface_block)
        }
    }
    
    // === Getters ===
    
    /// Блок под прицелом
    pub fn target_block(&self) -> Option<&BlockHit> {
        self.target_block.as_ref()
    }
    
    /// Текущее состояние ломания
    pub fn state(&self) -> &BreakState {
        &self.state
    }
    
    /// Прогресс ломания (0.0 - 1.0)
    pub fn break_progress(&self) -> f32 {
        match &self.state {
            BreakState::Breaking { progress, .. } => *progress,
            _ => 0.0,
        }
    }
    
    /// Позиция блока для выделения (если есть)
    pub fn highlight_block_pos(&self) -> Option<[i32; 3]> {
        self.target_block.as_ref().map(|hit| hit.block_pos)
    }
    
    /// Позиция для установки нового блока (рядом с целевым)
    pub fn placement_pos(&self) -> Option<[i32; 3]> {
        self.target_block.as_ref().map(|hit| {
            [
                hit.block_pos[0] + hit.hit_normal.x as i32,
                hit.block_pos[1] + hit.hit_normal.y as i32,
                hit.block_pos[2] + hit.hit_normal.z as i32,
            ]
        })
    }
    
    /// Мировые координаты точки для размещения суб-вокселя
    pub fn placement_world_pos(&self) -> Option<[f32; 3]> {
        self.target_block.as_ref().map(|hit| {
            // Смещаем точку попадания немного в направлении нормали
            let offset = 0.01;
            [
                hit.hit_point.x + hit.hit_normal.x * offset,
                hit.hit_point.y + hit.hit_normal.y * offset,
                hit.hit_point.z + hit.hit_normal.z * offset,
            ]
        })
    }
    
    /// Нужно ли установить блок (ПКМ нажата и есть цель)
    pub fn should_place(&self) -> bool {
        self.is_placing && self.target_block.is_some()
    }
}

/// Кнопки мыши
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MouseButton {
    Left,
    Right,
    Middle,
}

// Убран Default так как требуется world_changes


============================================================
FILE: blocks\definition.rs
============================================================

// ============================================
// Data-Driven Block Definition
// ============================================
// Структуры для загрузки блоков из JSON

use serde::{Deserialize, Serialize};

// ============================================
// Texture Definition - пиксельные текстуры
// ============================================

/// Размер текстуры (в пикселях)
pub const TEXTURE_SIZE: usize = 16;

/// Один пиксель текстуры [r, g, b, a] (0-255)
pub type PixelRGBA = [u8; 4];

/// Текстура грани блока
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TextureDef {
    /// Ссылка на PNG файл
    File(String),
    
    /// Inline пиксели (16x16 = 256 пикселей, row-major)
    /// Каждый пиксель: [r, g, b, a] или [r, g, b] или "#RRGGBB" или "#RRGGBBAA"
    Pixels {
        width: u8,
        height: u8,
        pixels: Vec<PixelValue>,
    },
    
    /// Палитра + индексы (компактный формат)
    Indexed {
        palette: Vec<PixelValue>,
        /// Индексы в палитру (width * height)
        indices: Vec<u8>,
        width: u8,
        height: u8,
    },
    
    /// Процедурная текстура
    Procedural {
        #[serde(rename = "type")]
        proc_type: ProceduralType,
        params: ProceduralParams,
    },
}

/// Значение пикселя (гибкий формат)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PixelValue {
    /// RGB массив [r, g, b]
    RGB([u8; 3]),
    /// RGBA массив [r, g, b, a]
    RGBA([u8; 4]),
    /// Hex строка "#RRGGBB" или "#RRGGBBAA"
    Hex(String),
    /// Индекс в палитру
    Index(u8),
}

impl PixelValue {
    pub fn to_rgba(&self) -> PixelRGBA {
        match self {
            PixelValue::RGB([r, g, b]) => [*r, *g, *b, 255],
            PixelValue::RGBA(rgba) => *rgba,
            PixelValue::Hex(s) => parse_hex_color(s),
            PixelValue::Index(_) => [255, 0, 255, 255], // Magenta = error
        }
    }
    
    pub fn to_rgb_f32(&self) -> [f32; 3] {
        let [r, g, b, _] = self.to_rgba();
        [r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0]
    }
}

fn parse_hex_color(s: &str) -> PixelRGBA {
    let s = s.trim_start_matches('#');
    match s.len() {
        6 => {
            let r = u8::from_str_radix(&s[0..2], 16).unwrap_or(255);
            let g = u8::from_str_radix(&s[2..4], 16).unwrap_or(0);
            let b = u8::from_str_radix(&s[4..6], 16).unwrap_or(255);
            [r, g, b, 255]
        }
        8 => {
            let r = u8::from_str_radix(&s[0..2], 16).unwrap_or(255);
            let g = u8::from_str_radix(&s[2..4], 16).unwrap_or(0);
            let b = u8::from_str_radix(&s[4..6], 16).unwrap_or(255);
            let a = u8::from_str_radix(&s[6..8], 16).unwrap_or(255);
            [r, g, b, a]
        }
        _ => [255, 0, 255, 255], // Magenta = error
    }
}

/// Типы процедурных текстур
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ProceduralType {
    Noise,
    Gradient,
    Checker,
    Bricks,
    Planks,
    Ore,
}

/// Параметры процедурной текстуры
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ProceduralParams {
    #[serde(default)]
    pub color1: Option<PixelValue>,
    #[serde(default)]
    pub color2: Option<PixelValue>,
    #[serde(default)]
    pub scale: Option<f32>,
    #[serde(default)]
    pub seed: Option<u32>,
    #[serde(default)]
    pub variation: Option<f32>,
}

impl Default for TextureDef {
    fn default() -> Self {
        TextureDef::File("missing.png".to_string())
    }
}

// ============================================
// Face Textures - текстуры для каждой грани
// ============================================

/// Текстуры граней блока
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FaceTextures {
    /// Одна текстура для всех граней
    All(TextureDef),
    
    /// Разные текстуры для граней
    PerFace {
        #[serde(default)]
        top: Option<TextureDef>,
        #[serde(default)]
        bottom: Option<TextureDef>,
        #[serde(default)]
        north: Option<TextureDef>,
        #[serde(default)]
        south: Option<TextureDef>,
        #[serde(default)]
        east: Option<TextureDef>,
        #[serde(default)]
        west: Option<TextureDef>,
        /// Fallback для сторон
        #[serde(default)]
        side: Option<TextureDef>,
    },
}

impl Default for FaceTextures {
    fn default() -> Self {
        FaceTextures::All(TextureDef::default())
    }
}

// ============================================
// Color Definition (legacy + simple cases)
// ============================================

/// Определение цвета блока из JSON (для простых случаев)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ColorDef {
    /// Один цвет для всех граней [r, g, b]
    Uniform([f32; 3]),
    /// Разные цвета для граней { top, side, bottom }
    PerFace {
        top: [f32; 3],
        side: [f32; 3],
        #[serde(default = "default_bottom")]
        bottom: [f32; 3],
    },
}

fn default_bottom() -> [f32; 3] {
    [0.5, 0.5, 0.5]
}

impl Default for ColorDef {
    fn default() -> Self {
        ColorDef::Uniform([0.5, 0.5, 0.5])
    }
}

impl ColorDef {
    pub fn top(&self) -> [f32; 3] {
        match self {
            ColorDef::Uniform(c) => *c,
            ColorDef::PerFace { top, .. } => *top,
        }
    }
    
    pub fn side(&self) -> [f32; 3] {
        match self {
            ColorDef::Uniform(c) => *c,
            ColorDef::PerFace { side, .. } => *side,
        }
    }
    
    pub fn bottom(&self) -> [f32; 3] {
        match self {
            ColorDef::Uniform(c) => *c,
            ColorDef::PerFace { bottom, .. } => *bottom,
        }
    }
}

/// Категория блока (для организации в инвентаре)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum BlockCategory {
    #[default]
    Basic,
    Stone,
    Ore,
    Wood,
    Nature,
    Building,
    Metal,
}

/// Звуки блока
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct BlockSounds {
    #[serde(default)]
    pub place: Option<String>,
    #[serde(default)]
    pub break_sound: Option<String>,
    #[serde(default)]
    pub step: Option<String>,
}

/// Определение блока из JSON
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockDefinition {
    /// Уникальный ID блока (string, например "minecraft:stone")
    pub id: String,
    
    /// Числовой ID для сериализации (0-255)
    pub numeric_id: u8,
    
    /// Отображаемое имя
    pub name: String,
    
    /// Цвет(а) блока
    #[serde(default)]
    pub color: ColorDef,
    
    /// Твёрдость (время ломания базовым инструментом)
    #[serde(default = "default_hardness")]
    pub hardness: f32,
    
    /// Прозрачный ли блок
    #[serde(default)]
    pub transparent: bool,
    
    /// Излучает ли свет
    #[serde(default)]
    pub emissive: bool,
    
    /// Уровень света (0-15)
    #[serde(default)]
    pub light_level: u8,
    
    /// Твёрдый ли блок (для коллизий)
    #[serde(default = "default_true")]
    pub solid: bool,
    
    /// Можно ли сломать
    #[serde(default = "default_true")]
    pub breakable: bool,
    
    /// Категория
    #[serde(default)]
    pub category: BlockCategory,
    
    /// Текстуры граней (пиксельные)
    #[serde(default)]
    pub textures: Option<FaceTextures>,
    
    /// Звуки
    #[serde(default)]
    pub sounds: BlockSounds,
    
    /// Дополнительные теги для модов
    #[serde(default)]
    pub tags: Vec<String>,
}

fn default_hardness() -> f32 { 1.0 }
fn default_true() -> bool { true }

impl Default for BlockDefinition {
    fn default() -> Self {
        Self {
            id: "unknown".to_string(),
            numeric_id: 0,
            name: "Unknown".to_string(),
            color: ColorDef::default(),
            hardness: 1.0,
            transparent: false,
            emissive: false,
            light_level: 0,
            solid: true,
            breakable: true,
            category: BlockCategory::Basic,
            textures: None,
            sounds: BlockSounds::default(),
            tags: Vec::new(),
        }
    }
}

/// Файл с определениями блоков
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlocksFile {
    /// Версия формата
    #[serde(default = "default_version")]
    pub version: String,
    
    /// Список блоков
    pub blocks: Vec<BlockDefinition>,
}

fn default_version() -> String { "1.0".to_string() }


============================================================
FILE: blocks\mod.rs
============================================================

// ============================================
// Библиотека блоков для GPU движка
// ============================================
// Data-Driven Architecture: блоки загружаются из JSON

mod types;
mod definition;
mod registry;
mod block_breaker;
mod worldgen;
pub mod texture_atlas;

pub use types::*;
pub use definition::*;
pub use registry::*;
pub use block_breaker::*;
pub use worldgen::*;


============================================================
FILE: blocks\registry.rs
============================================================

// ============================================
// Block Registry - Data-Driven из JSON
// ============================================
// Единый источник правды для всех блоков

use std::collections::HashMap;
use std::path::Path;
use std::fs;
use std::sync::{OnceLock, RwLock};

use super::definition::{BlockDefinition, BlocksFile, BlockCategory, ColorDef};

/// Динамический реестр блоков
pub struct BlockRegistry {
    /// Блоки по string ID
    blocks_by_id: HashMap<String, BlockDefinition>,
    /// Блоки по numeric ID
    blocks_by_numeric: HashMap<u8, BlockDefinition>,
    /// Маппинг string ID -> numeric ID
    id_to_numeric: HashMap<String, u8>,
    /// Маппинг numeric ID -> string ID
    numeric_to_id: HashMap<u8, String>,
}

impl BlockRegistry {
    pub fn new() -> Self {
        Self {
            blocks_by_id: HashMap::new(),
            blocks_by_numeric: HashMap::new(),
            id_to_numeric: HashMap::new(),
            numeric_to_id: HashMap::new(),
        }
    }
    
    /// Загрузить блоки из JSON строки
    pub fn load_from_json(&mut self, json: &str) -> Result<usize, String> {
        let blocks_file: BlocksFile = serde_json::from_str(json)
            .map_err(|e| format!("Failed to parse JSON: {}", e))?;
        
        let count = blocks_file.blocks.len();
        for block in blocks_file.blocks {
            self.register(block);
        }
        Ok(count)
    }
    
    /// Загрузить блоки из файла
    pub fn load_from_file<P: AsRef<Path>>(&mut self, path: P) -> Result<usize, String> {
        let content = fs::read_to_string(path.as_ref())
            .map_err(|e| format!("Failed to read file: {}", e))?;
        self.load_from_json(&content)
    }
    
    /// Загрузить все JSON из директории
    pub fn load_from_directory<P: AsRef<Path>>(&mut self, dir: P) -> Result<usize, String> {
        let dir = dir.as_ref();
        if !dir.exists() { return Ok(0); }
        
        let mut total = 0;
        for entry in fs::read_dir(dir).map_err(|e| e.to_string())? {
            let path = entry.map_err(|e| e.to_string())?.path();
            if path.extension().map_or(false, |ext| ext == "json") {
                if let Ok(count) = self.load_from_file(&path) {
                    total += count;
                }
            }
        }
        Ok(total)
    }
    
    /// Зарегистрировать блок
    pub fn register(&mut self, block: BlockDefinition) {
        let id = block.id.clone();
        let numeric = block.numeric_id;
        
        self.id_to_numeric.insert(id.clone(), numeric);
        self.numeric_to_id.insert(numeric, id.clone());
        self.blocks_by_id.insert(id, block.clone());
        self.blocks_by_numeric.insert(numeric, block);
    }
    
    /// Получить блок по string ID
    pub fn get(&self, id: &str) -> Option<&BlockDefinition> {
        self.blocks_by_id.get(id)
    }
    
    /// Получить блок по numeric ID
    pub fn get_by_numeric(&self, id: u8) -> Option<&BlockDefinition> {
        self.blocks_by_numeric.get(&id)
    }
    
    /// Получить numeric ID по string ID
    pub fn get_numeric_id(&self, id: &str) -> Option<u8> {
        self.id_to_numeric.get(id).copied()
    }
    
    /// Получить string ID по numeric ID  
    pub fn get_string_id(&self, numeric: u8) -> Option<&str> {
        self.numeric_to_id.get(&numeric).map(|s| s.as_str())
    }
    
    /// Все блоки
    pub fn all_blocks(&self) -> impl Iterator<Item = &BlockDefinition> {
        self.blocks_by_id.values()
    }
    
    /// Блоки по категории
    pub fn blocks_by_category(&self, category: BlockCategory) -> Vec<&BlockDefinition> {
        self.blocks_by_id.values()
            .filter(|b| b.category == category)
            .collect()
    }
    
    /// Количество блоков
    pub fn count(&self) -> usize {
        self.blocks_by_id.len()
    }
}

impl Default for BlockRegistry {
    fn default() -> Self { Self::new() }
}

// ============================================
// Global Registry Singleton
// ============================================

static GLOBAL_REGISTRY: OnceLock<RwLock<BlockRegistry>> = OnceLock::new();

/// Получить глобальный реестр блоков
pub fn global_registry() -> &'static RwLock<BlockRegistry> {
    GLOBAL_REGISTRY.get_or_init(|| {
        let mut registry = BlockRegistry::new();
        
        // Загружаем из встроенного JSON (default_blocks.json)
        if let Err(e) = registry.load_from_json(include_str!("../../../assets/blocks/default_blocks.json")) {
            log::warn!("Failed to load default blocks: {}", e);
            register_fallback_blocks(&mut registry);
        }
        
        // Загружаем моды
        let _ = registry.load_from_json(include_str!("../../../assets/blocks/example_mod.json"));
        let _ = registry.load_from_json(include_str!("../../../assets/blocks/street_art.json"));
        
        RwLock::new(registry)
    })
}

/// Инициализировать с модами
pub fn init_registry_with_mods<P: AsRef<Path>>(mods_dir: P) -> Result<(), String> {
    let registry = global_registry();
    let mut reg = registry.write().map_err(|_| "Lock poisoned")?;
    reg.load_from_directory(mods_dir)?;
    Ok(())
}

/// Fallback блоки если JSON не загрузился
fn register_fallback_blocks(registry: &mut BlockRegistry) {
    registry.register(BlockDefinition {
        id: "air".to_string(),
        numeric_id: 0,
        name: "Air".to_string(),
        color: ColorDef::Uniform([0.0, 0.0, 0.0]),
        transparent: true,
        solid: false,
        breakable: false,
        ..Default::default()
    });
    
    registry.register(BlockDefinition {
        id: "stone".to_string(),
        numeric_id: 1,
        name: "Stone".to_string(),
        color: ColorDef::Uniform([0.5, 0.5, 0.52]),
        ..Default::default()
    });
    
    registry.register(BlockDefinition {
        id: "grass".to_string(),
        numeric_id: 3,
        name: "Grass".to_string(),
        color: ColorDef::PerFace {
            top: [0.36, 0.60, 0.28],
            side: [0.55, 0.40, 0.26],
            bottom: [0.55, 0.40, 0.26],
        },
        ..Default::default()
    });
}


============================================================
FILE: blocks\texture_atlas.rs
============================================================

// ============================================
// Block Texture Atlas
// ============================================
// Генерирует текстурный атлас из JSON-определений блоков

use super::{global_registry, BlockDefinition};
use super::definition::{TextureDef, PixelValue, FaceTextures};

/// Размер одной текстуры в атласе
pub const TEXTURE_SIZE: u32 = 16;
/// Максимум текстур в атласе (16x16 = 256 блоков)
pub const ATLAS_SIZE: u32 = 16;
/// Размер атласа в пикселях
pub const ATLAS_PIXELS: u32 = ATLAS_SIZE * TEXTURE_SIZE;

/// Текстурный атлас блоков
pub struct BlockTextureAtlas {
    /// RGBA данные атласа (ATLAS_PIXELS x ATLAS_PIXELS x 4)
    pub data: Vec<u8>,
    /// Маппинг block_id -> позиция в атласе (x, y)
    pub block_positions: std::collections::HashMap<u8, (u32, u32)>,
}

impl BlockTextureAtlas {
    /// Создать атлас из реестра блоков
    pub fn from_registry() -> Self {
        let mut atlas = Self {
            data: vec![0u8; (ATLAS_PIXELS * ATLAS_PIXELS * 4) as usize],
            block_positions: std::collections::HashMap::new(),
        };
        
        if let Ok(registry) = global_registry().read() {
            let mut slot = 0u32;
            
            for def in registry.all_blocks() {
                if def.numeric_id == 0 { continue; } // Skip air
                
                let atlas_x = slot % ATLAS_SIZE;
                let atlas_y = slot / ATLAS_SIZE;
                
                atlas.block_positions.insert(def.numeric_id, (atlas_x, atlas_y));
                atlas.render_block_texture(def, atlas_x, atlas_y);
                
                slot += 1;
                if slot >= ATLAS_SIZE * ATLAS_SIZE { break; }
            }
        }
        
        atlas
    }
    
    /// Рендерит текстуру блока в атлас
    fn render_block_texture(&mut self, def: &BlockDefinition, atlas_x: u32, atlas_y: u32) {
        let base_x = atlas_x * TEXTURE_SIZE;
        let base_y = atlas_y * TEXTURE_SIZE;
        
        // Получаем текстуру (side для отображения в инвентаре)
        let texture = self.get_side_texture(def);
        
        match texture {
            Some(tex) => self.render_texture_def(&tex, base_x, base_y),
            None => self.render_solid_color(def, base_x, base_y),
        }
    }
    
    /// Получить текстуру боковой грани
    fn get_side_texture(&self, def: &BlockDefinition) -> Option<TextureDef> {
        match &def.textures {
            Some(FaceTextures::All(tex)) => Some(tex.clone()),
            Some(FaceTextures::PerFace { side, north, .. }) => {
                side.clone().or_else(|| north.clone())
            }
            None => None,
        }
    }
    
    /// Рендерит TextureDef в атлас
    fn render_texture_def(&mut self, tex: &TextureDef, base_x: u32, base_y: u32) {
        match tex {
            TextureDef::Pixels { width, height, pixels } => {
                self.render_pixels(*width as u32, *height as u32, pixels, base_x, base_y);
            }
            TextureDef::Indexed { palette, indices, width, height } => {
                self.render_indexed(palette, indices, *width as u32, *height as u32, base_x, base_y);
            }
            TextureDef::Procedural { proc_type, params } => {
                self.render_procedural(proc_type, params, base_x, base_y);
            }
            TextureDef::File(_) => {
                // TODO: загрузка из файла
                self.fill_magenta(base_x, base_y);
            }
        }
    }
    
    /// Рендерит inline пиксели
    fn render_pixels(&mut self, width: u32, height: u32, pixels: &[PixelValue], base_x: u32, base_y: u32) {
        for y in 0..TEXTURE_SIZE {
            for x in 0..TEXTURE_SIZE {
                // Масштабируем если размер не 16x16
                let src_x = (x * width / TEXTURE_SIZE) as usize;
                let src_y = (y * height / TEXTURE_SIZE) as usize;
                let idx = src_y * width as usize + src_x;
                
                let rgba = if idx < pixels.len() {
                    pixels[idx].to_rgba()
                } else {
                    [255, 0, 255, 255] // Magenta for missing
                };
                
                self.set_pixel(base_x + x, base_y + y, rgba);
            }
        }
    }
    
    /// Рендерит индексированную текстуру
    fn render_indexed(&mut self, palette: &[PixelValue], indices: &[u8], width: u32, height: u32, base_x: u32, base_y: u32) {
        for y in 0..TEXTURE_SIZE {
            for x in 0..TEXTURE_SIZE {
                let src_x = (x * width / TEXTURE_SIZE) as usize;
                let src_y = (y * height / TEXTURE_SIZE) as usize;
                let idx = src_y * width as usize + src_x;
                
                let rgba = if idx < indices.len() {
                    let palette_idx = indices[idx] as usize;
                    if palette_idx < palette.len() {
                        palette[palette_idx].to_rgba()
                    } else {
                        [255, 0, 255, 255]
                    }
                } else {
                    [255, 0, 255, 255]
                };
                
                self.set_pixel(base_x + x, base_y + y, rgba);
            }
        }
    }
    
    /// Рендерит процедурную текстуру
    fn render_procedural(&mut self, proc_type: &super::definition::ProceduralType, params: &super::definition::ProceduralParams, base_x: u32, base_y: u32) {
        use super::definition::ProceduralType;
        
        let color1 = params.color1.as_ref().map(|c| c.to_rgba()).unwrap_or([128, 128, 128, 255]);
        let color2 = params.color2.as_ref().map(|c| c.to_rgba()).unwrap_or([64, 64, 64, 255]);
        
        for y in 0..TEXTURE_SIZE {
            for x in 0..TEXTURE_SIZE {
                let rgba = match proc_type {
                    ProceduralType::Checker => {
                        if (x / 2 + y / 2) % 2 == 0 { color1 } else { color2 }
                    }
                    ProceduralType::Noise => {
                        let noise = simple_hash(x + base_x * 100, y + base_y * 100);
                        if noise > 128 { color1 } else { color2 }
                    }
                    ProceduralType::Gradient => {
                        let t = y as f32 / TEXTURE_SIZE as f32;
                        lerp_color(color1, color2, t)
                    }
                    ProceduralType::Bricks => {
                        let brick_h = 4;
                        let brick_w = 8;
                        let mortar = 1;
                        let row = y / brick_h;
                        let offset = if row % 2 == 0 { 0 } else { brick_w / 2 };
                        let bx = (x + offset) % brick_w;
                        let by = y % brick_h;
                        if bx < mortar || by < mortar { color2 } else { color1 }
                    }
                    _ => color1,
                };
                
                self.set_pixel(base_x + x, base_y + y, rgba);
            }
        }
    }
    
    /// Заполняет solid цветом из определения блока
    fn render_solid_color(&mut self, def: &BlockDefinition, base_x: u32, base_y: u32) {
        let [r, g, b] = def.color.side();
        let rgba = [(r * 255.0) as u8, (g * 255.0) as u8, (b * 255.0) as u8, 255];
        
        // Добавляем простую текстуру - обводку
        for y in 0..TEXTURE_SIZE {
            for x in 0..TEXTURE_SIZE {
                let edge = x == 0 || y == 0 || x == TEXTURE_SIZE - 1 || y == TEXTURE_SIZE - 1;
                let pixel = if edge {
                    [(rgba[0] as f32 * 0.7) as u8, (rgba[1] as f32 * 0.7) as u8, (rgba[2] as f32 * 0.7) as u8, 255]
                } else {
                    rgba
                };
                self.set_pixel(base_x + x, base_y + y, pixel);
            }
        }
    }
    
    /// Заполняет magenta (ошибка)
    fn fill_magenta(&mut self, base_x: u32, base_y: u32) {
        for y in 0..TEXTURE_SIZE {
            for x in 0..TEXTURE_SIZE {
                let checker = (x / 4 + y / 4) % 2 == 0;
                let rgba = if checker { [255, 0, 255, 255] } else { [0, 0, 0, 255] };
                self.set_pixel(base_x + x, base_y + y, rgba);
            }
        }
    }
    
    /// Устанавливает пиксель в атласе
    fn set_pixel(&mut self, x: u32, y: u32, rgba: [u8; 4]) {
        let idx = ((y * ATLAS_PIXELS + x) * 4) as usize;
        if idx + 3 < self.data.len() {
            self.data[idx] = rgba[0];
            self.data[idx + 1] = rgba[1];
            self.data[idx + 2] = rgba[2];
            self.data[idx + 3] = rgba[3];
        }
    }
    
    /// Получить UV координаты для блока
    pub fn get_uv(&self, block_id: u8) -> Option<(f32, f32, f32, f32)> {
        self.block_positions.get(&block_id).map(|&(x, y)| {
            let u0 = x as f32 / ATLAS_SIZE as f32;
            let v0 = y as f32 / ATLAS_SIZE as f32;
            let u1 = (x + 1) as f32 / ATLAS_SIZE as f32;
            let v1 = (y + 1) as f32 / ATLAS_SIZE as f32;
            (u0, v0, u1, v1)
        })
    }
}

/// Простой хеш для процедурных текстур
fn simple_hash(x: u32, y: u32) -> u8 {
    let n = x.wrapping_mul(374761393).wrapping_add(y.wrapping_mul(668265263));
    let n = (n ^ (n >> 13)).wrapping_mul(1274126177);
    ((n ^ (n >> 16)) & 0xFF) as u8
}

/// Линейная интерполяция цветов
fn lerp_color(a: [u8; 4], b: [u8; 4], t: f32) -> [u8; 4] {
    [
        (a[0] as f32 * (1.0 - t) + b[0] as f32 * t) as u8,
        (a[1] as f32 * (1.0 - t) + b[1] as f32 * t) as u8,
        (a[2] as f32 * (1.0 - t) + b[2] as f32 * t) as u8,
        255,
    ]
}


============================================================
FILE: blocks\types.rs
============================================================

// ============================================
// Block Types - Data-Driven Architecture
// ============================================
// BlockType = u8 (numeric_id). Все данные из JSON.

/// BlockType - просто numeric_id блока
pub type BlockType = u8;

// Константы для всех блоков (соответствуют numeric_id в JSON)
pub const AIR: BlockType = 0;
pub const STONE: BlockType = 1;
pub const DIRT: BlockType = 2;
pub const GRASS: BlockType = 3;
pub const SAND: BlockType = 4;
pub const GRAVEL: BlockType = 5;
pub const COBBLESTONE: BlockType = 10;
pub const MOSSY_COBBLESTONE: BlockType = 11;
pub const GRANITE: BlockType = 12;
pub const DIORITE: BlockType = 13;
pub const ANDESITE: BlockType = 14;
pub const DEEPSLATE: BlockType = 15;
pub const COAL_ORE: BlockType = 20;
pub const IRON_ORE: BlockType = 21;
pub const GOLD_ORE: BlockType = 22;
pub const DIAMOND_ORE: BlockType = 23;
pub const EMERALD_ORE: BlockType = 24;
pub const REDSTONE_ORE: BlockType = 25;
pub const LAPIS_ORE: BlockType = 26;
pub const COPPER_ORE: BlockType = 27;
pub const OAK_LOG: BlockType = 30;
pub const OAK_PLANKS: BlockType = 31;
pub const OAK_LEAVES: BlockType = 32;
pub const BIRCH_LOG: BlockType = 33;
pub const BIRCH_PLANKS: BlockType = 34;
pub const BIRCH_LEAVES: BlockType = 35;
pub const SPRUCE_LOG: BlockType = 36;
pub const SPRUCE_PLANKS: BlockType = 37;
pub const SPRUCE_LEAVES: BlockType = 38;
pub const WATER: BlockType = 50;
pub const LAVA: BlockType = 51;
pub const ICE: BlockType = 52;
pub const SNOW: BlockType = 53;
pub const CLAY: BlockType = 54;
pub const BRICKS: BlockType = 60;
pub const STONE_BRICKS: BlockType = 61;
pub const OBSIDIAN: BlockType = 62;
pub const GLASS: BlockType = 63;
pub const IRON_BLOCK: BlockType = 70;
pub const GOLD_BLOCK: BlockType = 71;
pub const DIAMOND_BLOCK: BlockType = 72;
pub const EMERALD_BLOCK: BlockType = 73;
pub const COPPER_BLOCK: BlockType = 74;

// Custom blocks (100+)
pub const CUSTOM_100: BlockType = 100;
pub const CUSTOM_101: BlockType = 101;
pub const CUSTOM_102: BlockType = 102;
pub const CUSTOM_103: BlockType = 103;
pub const CUSTOM_104: BlockType = 104;

/// Проверка: блок твёрдый?
#[inline]
pub fn is_solid(block: BlockType) -> bool {
    block != AIR && block != WATER && block != GLASS
}

/// Проверка: блок прозрачный?
#[inline]
pub fn is_transparent(block: BlockType) -> bool {
    matches!(block, AIR | WATER | GLASS | OAK_LEAVES | BIRCH_LEAVES | SPRUCE_LEAVES)
}

/// Получить цвет блока из реестра
#[inline]
pub fn get_block_color(block: BlockType) -> [f32; 3] {
    if let Ok(registry) = super::global_registry().read() {
        if let Some(def) = registry.get_by_numeric(block) {
            return def.color.top();
        }
    }
    [0.5, 0.5, 0.5]
}

/// Получить цвета граней (top, side) из реестра
#[inline]
pub fn get_face_colors(block: BlockType) -> ([f32; 3], [f32; 3]) {
    if let Ok(registry) = super::global_registry().read() {
        if let Some(def) = registry.get_by_numeric(block) {
            return (def.color.top(), def.color.side());
        }
    }
    ([0.5, 0.5, 0.5], [0.4, 0.4, 0.4])
}

/// Получить имя блока из реестра
#[inline]
pub fn get_block_name(block: BlockType) -> String {
    if let Ok(registry) = super::global_registry().read() {
        if let Some(def) = registry.get_by_numeric(block) {
            return def.name.clone();
        }
    }
    format!("block_{}", block)
}

/// Получить hardness блока
#[inline]
pub fn get_block_hardness(block: BlockType) -> f32 {
    if let Ok(registry) = super::global_registry().read() {
        if let Some(def) = registry.get_by_numeric(block) {
            return def.hardness;
        }
    }
    1.0
}


============================================================
FILE: blocks\worldgen.rs
============================================================

// ============================================
// World Generation Block Resolver
// ============================================
// Получает блоки для генерации мира из реестра по string ID

use super::{BlockType, global_registry};
use super::types::*;

/// Кэшированные ID блоков для быстрого доступа при генерации
pub struct WorldGenBlocks {
    pub bedrock: BlockType,
    pub stone: BlockType,
    pub dirt: BlockType,
    pub air: BlockType,
    pub sand: BlockType,
    pub grass: BlockType,
    pub snow: BlockType,
    pub coal_ore: BlockType,
    pub iron_ore: BlockType,
    pub gold_ore: BlockType,
    pub diamond_ore: BlockType,
    pub copper_ore: BlockType,
    pub water: BlockType,
    pub lava: BlockType,
}

impl Default for WorldGenBlocks {
    fn default() -> Self { Self::new() }
}

impl WorldGenBlocks {
    pub fn new() -> Self {
        Self {
            bedrock: resolve_block("deepslate"),
            stone: resolve_block("stone"),
            dirt: resolve_block("dirt"),
            air: resolve_block("air"),
            sand: resolve_block("sand"),
            grass: resolve_block("grass"),
            snow: resolve_block("snow"),
            coal_ore: resolve_block("coal_ore"),
            iron_ore: resolve_block("iron_ore"),
            gold_ore: resolve_block("gold_ore"),
            diamond_ore: resolve_block("diamond_ore"),
            copper_ore: resolve_block("copper_ore"),
            water: resolve_block("water"),
            lava: resolve_block("lava"),
        }
    }
    
    #[inline]
    pub fn surface_block(&self, height: f32) -> BlockType {
        if height < 8.0 { self.sand }
        else if height < 30.0 { self.grass }
        else if height < 50.0 { self.stone }
        else { self.snow }
    }
    
    #[inline]
    pub fn subsurface_block(&self, height: f32) -> BlockType {
        if height < 8.0 { self.sand }
        else if height >= 50.0 { self.stone }
        else { self.dirt }
    }
    
    #[inline]
    pub fn block_at_depth(&self, y: i32, surface_y: i32, surface_height: f32) -> BlockType {
        if y > surface_y { self.air }
        else if y < -29 { self.bedrock }
        else if y < surface_y - 4 { self.stone }
        else if y < surface_y { self.subsurface_block(surface_height) }
        else { self.surface_block(surface_height) }
    }
}

/// Резолвит string ID в BlockType через реестр
pub fn resolve_block(id: &str) -> BlockType {
    if let Ok(registry) = global_registry().read() {
        if let Some(numeric_id) = registry.get_numeric_id(id) {
            return numeric_id;
        }
    }
    // Fallback
    match id {
        "air" => AIR,
        "stone" => STONE,
        "dirt" => DIRT,
        "grass" => GRASS,
        "sand" => SAND,
        "gravel" => GRAVEL,
        "deepslate" => DEEPSLATE,
        "snow" => SNOW,
        "water" => WATER,
        "lava" => LAVA,
        "coal_ore" => COAL_ORE,
        "iron_ore" => IRON_ORE,
        "gold_ore" => GOLD_ORE,
        "diamond_ore" => DIAMOND_ORE,
        "copper_ore" => COPPER_ORE,
        _ => STONE,
    }
}

/// Резолвит BlockType в string ID
pub fn block_to_id(block: BlockType) -> &'static str {
    if let Ok(registry) = global_registry().read() {
        if let Some(id) = registry.get_string_id(block) {
            return Box::leak(id.to_string().into_boxed_str());
        }
    }
    match block {
        AIR => "air",
        STONE => "stone",
        DIRT => "dirt",
        GRASS => "grass",
        SAND => "sand",
        GRAVEL => "gravel",
        DEEPSLATE => "deepslate",
        SNOW => "snow",
        WATER => "water",
        LAVA => "lava",
        _ => "unknown",
    }
}

use std::sync::OnceLock;
static WORLDGEN_BLOCKS: OnceLock<WorldGenBlocks> = OnceLock::new();

pub fn worldgen_blocks() -> &'static WorldGenBlocks {
    WORLDGEN_BLOCKS.get_or_init(WorldGenBlocks::new)
}


============================================================
FILE: core\app.rs
============================================================

// ============================================
// App - Главный обработчик приложения
// ============================================

use std::sync::Arc;
use std::time::Instant;
use winit::{
    application::ApplicationHandler,
    event::{DeviceEvent, ElementState, KeyEvent, WindowEvent},
    event_loop::{ActiveEventLoop, ControlFlow, EventLoop},
    keyboard::{KeyCode, PhysicalKey},
    window::{Window, WindowId},
};

use crate::gpu::core::GameResources;
use crate::gpu::systems::{
    InitSystem, InputSystem, InputAction, BlockInteractionSystem,
    MenuSystem, SaveSystem, UpdateSystem, RenderSystem,
};
use crate::gpu::blocks::MouseButton;

/// Главное приложение
pub struct App {
    resources: GameResources,
}

impl App {
    pub fn new() -> Self {
        Self {
            resources: InitSystem::create_resources(),
        }
    }
}

impl ApplicationHandler for App {
    fn resumed(&mut self, event_loop: &ActiveEventLoop) {
        if self.resources.window.is_none() {
            let window_attrs = Window::default_attributes()
                .with_title("GPU Infinite Terrain - Press F5 to toggle camera mode")
                .with_inner_size(winit::dpi::LogicalSize::new(1280, 720));
            
            let window = Arc::new(event_loop.create_window(window_attrs).unwrap());
            
            InitSystem::init_rendering(&mut self.resources, window);
            
            // Захватываем курсор при старте
            InputSystem::grab_cursor(&mut self.resources, true);
        }
    }

    fn window_event(&mut self, event_loop: &ActiveEventLoop, _id: WindowId, event: WindowEvent) {
        match event {
            WindowEvent::CloseRequested => {
                SaveSystem::save_world(&self.resources);
                event_loop.exit();
            }
            
            WindowEvent::Resized(physical_size) => {
                if let Some(renderer) = &mut self.resources.renderer {
                    renderer.resize(physical_size);
                    self.resources.camera.resize(physical_size.width, physical_size.height);
                    self.resources.menu.resize(physical_size.width, physical_size.height);
                    
                    if let Some(gui_renderer) = &mut self.resources.gui_renderer {
                        gui_renderer.resize(renderer.queue(), physical_size.width, physical_size.height);
                    }
                }
            }
            
            WindowEvent::KeyboardInput {
                event: KeyEvent {
                    physical_key: PhysicalKey::Code(keycode),
                    state,
                    ..
                },
                ..
            } => {
                if let Some(action) = InputSystem::process_keyboard(&mut self.resources, keycode, state) {
                    match action {
                        InputAction::SaveWorld => {
                            SaveSystem::save_world(&self.resources);
                        }
                        InputAction::CycleTime => {
                            if let Some(renderer) = &mut self.resources.renderer {
                                let current = renderer.time_of_day();
                                let next = if current < 0.25 { 0.35 }
                                    else if current < 0.5 { 0.5 }
                                    else if current < 0.75 { 0.7 }
                                    else { 0.0 };
                                renderer.set_time_of_day(next);
                            }
                        }
                        InputAction::SlowTime => {
                            if let Some(renderer) = &mut self.resources.renderer {
                                renderer.set_time_speed(10.0);
                            }
                        }
                        InputAction::FastTime => {
                            if let Some(renderer) = &mut self.resources.renderer {
                                renderer.set_time_speed(120.0);
                            }
                        }
                        _ => {}
                    }
                }
            }
            
            WindowEvent::RedrawRequested => {
                let now = Instant::now();
                let dt = (now - self.resources.last_frame).as_secs_f32();
                self.resources.last_frame = now;
                let time = (now - self.resources.start_time).as_secs_f32();
                
                // Update
                UpdateSystem::update(&mut self.resources, dt, time);
                
                // Render
                RenderSystem::render(&mut self.resources, time, dt, event_loop);
                
                if let Some(window) = &self.resources.window {
                    window.request_redraw();
                }
            }
            
            WindowEvent::MouseInput { state, button, .. } => {
                let pressed = state == ElementState::Pressed;
                
                // Проверяем инвентарь первым
                let inventory_visible = if let Some(gui) = &self.resources.gui_renderer {
                    gui.inventory_ref().is_visible()
                } else {
                    false
                };
                
                if inventory_visible {
                    if button == winit::event::MouseButton::Left {
                        if pressed {
                            MenuSystem::handle_mouse_down(&mut self.resources);
                        } else {
                            MenuSystem::handle_mouse_up(&mut self.resources);
                        }
                    }
                } else if self.resources.menu.is_visible() {
                    // Меню открыто
                    if button == winit::event::MouseButton::Left {
                        self.resources.menu_mouse_pressed = pressed;
                    }
                    
                    if pressed && button == winit::event::MouseButton::Left {
                        MenuSystem::handle_click(&mut self.resources, event_loop);
                    }
                } else if self.resources.cursor_grabbed {
                    // Игровой режим
                    if pressed {
                        match button {
                            winit::event::MouseButton::Left => {
                                BlockInteractionSystem::handle_break(&mut self.resources);
                            }
                            winit::event::MouseButton::Right => {
                                BlockInteractionSystem::handle_place(&mut self.resources);
                            }
                            winit::event::MouseButton::Middle => {
                                BlockInteractionSystem::handle_pick_block(&mut self.resources);
                            }
                            _ => {}
                        }
                    }
                }
            }
            
            WindowEvent::CursorMoved { position, .. } => {
                self.resources.mouse_pos = (position.x as f32, position.y as f32);
            }
            
            _ => {}
        }
    }

    fn device_event(
        &mut self,
        _event_loop: &ActiveEventLoop,
        _device_id: winit::event::DeviceId,
        event: DeviceEvent,
    ) {
        if self.resources.menu.is_visible() {
            return;
        }
        
        match event {
            DeviceEvent::MouseMotion { delta } => {
                InputSystem::process_mouse_motion(&mut self.resources, delta);
            }
            
            DeviceEvent::MouseWheel { delta } => {
                InputSystem::process_mouse_wheel(&mut self.resources, delta);
            }
            
            _ => {}
        }
    }

    fn about_to_wait(&mut self, _event_loop: &ActiveEventLoop) {
        if let Some(window) = &self.resources.window {
            window.request_redraw();
        }
    }
}

/// Запуск игры
pub fn run() {
    env_logger::init();
    
    println!("=== Controls ===");
    println!("WASD - Move");
    println!("Mouse - Look around");
    println!("Space - Jump / Fly up");
    println!("Shift/Ctrl - Sprint / Fly down");
    println!("F - Toggle flight mode");
    println!("LMB - Break block");
    println!("RMB - Place block");
    println!("F5 - Toggle camera mode (1st/3rd person)");
    println!("F6 - Save world");
    println!("Mouse wheel / +/- - Adjust camera distance");
    println!("T - Cycle time of day");
    println!("[ / ] - Slow/fast time speed");
    println!("Escape - Open menu");
    println!("================");
    
    let event_loop = EventLoop::new().unwrap();
    event_loop.set_control_flow(ControlFlow::Poll);
    
    let mut app = App::new();
    event_loop.run_app(&mut app).unwrap();
}


============================================================
FILE: core\config.rs
============================================================

// ============================================
// Config - Константы и настройки игры
// ============================================

/// Путь к файлу сохранения
pub const SAVE_FILE: &str = "world.dat";

/// Сид мира по умолчанию
pub const DEFAULT_SEED: u64 = 12345;


============================================================
FILE: core\mod.rs
============================================================

// ============================================
// Core Module - Основные компоненты и ресурсы
// ============================================

pub mod app;
mod resources;
mod config;

pub use app::App;
pub use resources::GameResources;
pub use config::{SAVE_FILE, DEFAULT_SEED};


============================================================
FILE: core\resources.rs
============================================================

// ============================================
// Resources - Общие ресурсы игры
// ============================================

use std::sync::Arc;
use std::sync::RwLock;
use std::time::Instant;
use winit::window::Window;

use crate::gpu::player::Camera;
use crate::gpu::player::{Player, PlayerController};
use crate::gpu::render::Renderer;
use crate::gpu::blocks::BlockBreaker;
use crate::gpu::terrain::WorldChanges;
use crate::gpu::gui::{GameMenu, GuiRenderer};
use crate::gpu::subvoxel::{SubVoxelStorage, SubVoxelLevel};
use crate::gpu::subvoxel::SubVoxelRenderer;
use crate::gpu::audio::AudioSystem;

/// Все игровые ресурсы в одном месте
pub struct GameResources {
    // Window & Rendering
    pub window: Option<Arc<Window>>,
    pub renderer: Option<Renderer>,
    pub gui_renderer: Option<GuiRenderer>,
    pub subvoxel_renderer: Option<SubVoxelRenderer>,
    
    // Player entity
    pub player: Player,
    pub player_controller: PlayerController,
    
    // Camera
    pub camera: Camera,
    
    // Block interaction
    pub block_breaker: BlockBreaker,
    
    // World data
    pub world_changes: Arc<RwLock<WorldChanges>>,
    pub subvoxel_storage: Arc<RwLock<SubVoxelStorage>>,
    pub current_subvoxel_level: SubVoxelLevel,
    pub world_seed: u64,
    
    // GUI
    pub menu: GameMenu,
    
    // Audio
    pub audio_system: Option<AudioSystem>,
    
    // Timing
    pub start_time: Instant,
    pub last_frame: Instant,
    
    // Input state
    pub cursor_grabbed: bool,
    pub mouse_pos: (f32, f32),
    pub menu_mouse_pressed: bool,
}


============================================================
FILE: gui\crosshair.rs
============================================================

// ============================================
// Crosshair & Block Highlight - UI элементы
// ============================================
// Прицел в центре экрана и выделение блока

use bytemuck::{Pod, Zeroable};
use wgpu::util::DeviceExt;

/// Вершина для UI (2D позиция + цвет)
#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct UiVertex {
    pub position: [f32; 2],
    pub color: [f32; 4],
}

impl UiVertex {
    pub fn desc() -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<UiVertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                wgpu::VertexAttribute {
                    offset: 0,
                    shader_location: 0,
                    format: wgpu::VertexFormat::Float32x2,
                },
                wgpu::VertexAttribute {
                    offset: 8,
                    shader_location: 1,
                    format: wgpu::VertexFormat::Float32x4,
                },
            ],
        }
    }
}

/// Прицел (crosshair)
pub struct Crosshair {
    vertex_buffer: wgpu::Buffer,
    vertex_count: u32,
    pipeline: wgpu::RenderPipeline,
}

impl Crosshair {
    pub fn new(device: &wgpu::Device, surface_format: wgpu::TextureFormat) -> Self {
        // Создаём вершины прицела (крест в центре экрана)
        let size = 0.02; // Размер в NDC
        let thickness = 0.003;
        let color = [1.0, 1.0, 1.0, 0.8]; // Белый полупрозрачный
        
        let vertices = vec![
            // Горизонтальная линия
            UiVertex { position: [-size, -thickness], color },
            UiVertex { position: [size, -thickness], color },
            UiVertex { position: [size, thickness], color },
            UiVertex { position: [-size, -thickness], color },
            UiVertex { position: [size, thickness], color },
            UiVertex { position: [-size, thickness], color },
            
            // Вертикальная линия
            UiVertex { position: [-thickness, -size], color },
            UiVertex { position: [thickness, -size], color },
            UiVertex { position: [thickness, size], color },
            UiVertex { position: [-thickness, -size], color },
            UiVertex { position: [thickness, size], color },
            UiVertex { position: [-thickness, size], color },
        ];
        
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Crosshair Vertex Buffer"),
            contents: bytemuck::cast_slice(&vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });
        
        // Шейдер для UI
        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("UI Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("../shaders/ui.wgsl").into()),
        });
        
        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("UI Pipeline Layout"),
            bind_group_layouts: &[],
            push_constant_ranges: &[],
        });
        
        let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Crosshair Pipeline"),
            layout: Some(&pipeline_layout),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: Some("vs_main"),
                buffers: &[UiVertex::desc()],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format: surface_format,
                    blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleList,
                ..Default::default()
            },
            depth_stencil: None, // UI рисуется поверх всего
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
            cache: None,
        });
        
        Self {
            vertex_buffer,
            vertex_count: vertices.len() as u32,
            pipeline,
        }
    }
    
    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        render_pass.draw(0..self.vertex_count, 0..1);
    }
}

/// Вершина для 3D wireframe
#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct WireVertex {
    pub position: [f32; 3],
    pub color: [f32; 4],
}

impl WireVertex {
    pub fn desc() -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<WireVertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                wgpu::VertexAttribute {
                    offset: 0,
                    shader_location: 0,
                    format: wgpu::VertexFormat::Float32x3,
                },
                wgpu::VertexAttribute {
                    offset: 12,
                    shader_location: 1,
                    format: wgpu::VertexFormat::Float32x4,
                },
            ],
        }
    }
}

/// Выделение блока (wireframe куб)
pub struct BlockHighlight {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    index_count: u32,
    pipeline: wgpu::RenderPipeline,
    
    // Uniform для позиции блока и view-proj матрицы
    uniform_buffer: wgpu::Buffer,
    uniform_bind_group: wgpu::BindGroup,
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
struct HighlightUniforms {
    view_proj: [[f32; 4]; 4],
    block_pos: [f32; 3],
    block_size: f32,
}

impl BlockHighlight {
    pub fn new(device: &wgpu::Device, surface_format: wgpu::TextureFormat) -> Self {
        // Вершины единичного куба (будет масштабироваться в шейдере)
        let color = [0.0, 0.0, 0.0, 0.6]; // Чёрный полупрозрачный
        
        let vertices = vec![
            // 8 вершин куба (0 to 1)
            WireVertex { position: [0.0, 0.0, 0.0], color },
            WireVertex { position: [1.0, 0.0, 0.0], color },
            WireVertex { position: [1.0, 1.0, 0.0], color },
            WireVertex { position: [0.0, 1.0, 0.0], color },
            WireVertex { position: [0.0, 0.0, 1.0], color },
            WireVertex { position: [1.0, 0.0, 1.0], color },
            WireVertex { position: [1.0, 1.0, 1.0], color },
            WireVertex { position: [0.0, 1.0, 1.0], color },
        ];
        
        // Индексы для линий (12 рёбер куба)
        let indices: Vec<u32> = vec![
            // Нижняя грань
            0, 1, 1, 2, 2, 3, 3, 0,
            // Верхняя грань
            4, 5, 5, 6, 6, 7, 7, 4,
            // Вертикальные рёбра
            0, 4, 1, 5, 2, 6, 3, 7,
        ];
        
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Block Highlight Vertex Buffer"),
            contents: bytemuck::cast_slice(&vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });
        
        let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Block Highlight Index Buffer"),
            contents: bytemuck::cast_slice(&indices),
            usage: wgpu::BufferUsages::INDEX,
        });
        
        // Uniform buffer
        let uniforms = HighlightUniforms {
            view_proj: ultraviolet::Mat4::identity().into(),
            block_pos: [0.0, 0.0, 0.0],
            block_size: 1.0,
        };
        
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Block Highlight Uniform Buffer"),
            contents: bytemuck::cast_slice(&[uniforms]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });
        
        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Block Highlight Bind Group Layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });
        
        let uniform_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Block Highlight Bind Group"),
            layout: &bind_group_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: uniform_buffer.as_entire_binding(),
            }],
        });
        
        // Шейдер
        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Block Highlight Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("../shaders/highlight.wgsl").into()),
        });
        
        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Block Highlight Pipeline Layout"),
            bind_group_layouts: &[&bind_group_layout],
            push_constant_ranges: &[],
        });
        
        let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Block Highlight Pipeline"),
            layout: Some(&pipeline_layout),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: Some("vs_main"),
                buffers: &[WireVertex::desc()],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format: surface_format,
                    blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::LineList,
                ..Default::default()
            },
            depth_stencil: Some(wgpu::DepthStencilState {
                format: wgpu::TextureFormat::Depth32Float,
                depth_write_enabled: false,
                depth_compare: wgpu::CompareFunction::GreaterEqual, // Reversed-Z
                stencil: wgpu::StencilState::default(),
                bias: wgpu::DepthBiasState::default(),
            }),
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
            cache: None,
        });
        
        Self {
            vertex_buffer,
            index_buffer,
            index_count: indices.len() as u32,
            pipeline,
            uniform_buffer,
            uniform_bind_group,
        }
    }
    
    /// Обновить позицию выделяемого блока
    pub fn update(&self, queue: &wgpu::Queue, view_proj: [[f32; 4]; 4], block_pos: [i32; 3]) {
        self.update_with_size(queue, view_proj, [block_pos[0] as f32, block_pos[1] as f32, block_pos[2] as f32], 1.0);
    }
    
    /// Обновить позицию и размер выделяемого блока (для суб-вокселей)
    pub fn update_with_size(&self, queue: &wgpu::Queue, view_proj: [[f32; 4]; 4], block_pos: [f32; 3], size: f32) {
        let uniforms = HighlightUniforms {
            view_proj,
            block_pos,
            block_size: size,
        };
        queue.write_buffer(&self.uniform_buffer, 0, bytemuck::cast_slice(&[uniforms]));
    }
    
    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_bind_group(0, &self.uniform_bind_group, &[]);
        render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        render_pass.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
        render_pass.draw_indexed(0..self.index_count, 0, 0..1);
    }
}


============================================================
FILE: gui\fps_counter.rs
============================================================

// ============================================
// FPS Counter - Счётчик кадров в секунду
// ============================================
// Отображает FPS в левом верхнем углу экрана
// Использует 7-сегментный дисплей для цифр

use bytemuck::{Pod, Zeroable};
use wgpu::util::DeviceExt;

/// Вершина для UI (2D позиция + цвет)
#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct FpsVertex {
    pub position: [f32; 2],
    pub color: [f32; 4],
}

impl FpsVertex {
    pub fn desc() -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<FpsVertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                wgpu::VertexAttribute {
                    offset: 0,
                    shader_location: 0,
                    format: wgpu::VertexFormat::Float32x2,
                },
                wgpu::VertexAttribute {
                    offset: 8,
                    shader_location: 1,
                    format: wgpu::VertexFormat::Float32x4,
                },
            ],
        }
    }
}

/// FPS Counter
pub struct FpsCounter {
    vertex_buffer: wgpu::Buffer,
    pipeline: wgpu::RenderPipeline,
    
    // FPS tracking
    frame_count: u32,
    last_fps_update: std::time::Instant,
    current_fps: u32,
    
    // Максимальное количество вершин (для 4 цифр + "FPS:" текст)
    max_vertices: u32,
    current_vertex_count: u32,
    
    queue: std::sync::Arc<wgpu::Queue>,
}

impl FpsCounter {
    pub fn new(device: &wgpu::Device, queue: std::sync::Arc<wgpu::Queue>, surface_format: wgpu::TextureFormat) -> Self {
        // Создаём буфер с запасом для 4 цифр (каждая цифра до 7 сегментов * 6 вершин)
        let max_vertices = 4 * 7 * 6 + 100; // Запас для "FPS:" текста
        
        let vertex_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("FPS Counter Vertex Buffer"),
            size: (max_vertices as usize * std::mem::size_of::<FpsVertex>()) as u64,
            usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
            mapped_at_creation: false,
        });
        
        // Шейдер для UI (тот же что и для crosshair)
        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("FPS UI Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("../shaders/ui.wgsl").into()),
        });
        
        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("FPS Pipeline Layout"),
            bind_group_layouts: &[],
            push_constant_ranges: &[],
        });
        
        let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("FPS Pipeline"),
            layout: Some(&pipeline_layout),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: Some("vs_main"),
                buffers: &[FpsVertex::desc()],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format: surface_format,
                    blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleList,
                ..Default::default()
            },
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
            cache: None,
        });
        
        Self {
            vertex_buffer,
            pipeline,
            frame_count: 0,
            last_fps_update: std::time::Instant::now(),
            current_fps: 0,
            max_vertices,
            current_vertex_count: 0,
            queue,
        }
    }
    
    /// Вызывать каждый кадр для обновления счётчика
    pub fn update(&mut self) {
        self.frame_count += 1;
        
        let now = std::time::Instant::now();
        let elapsed = now.duration_since(self.last_fps_update).as_secs_f32();
        
        // Обновляем FPS раз в секунду
        if elapsed >= 1.0 {
            self.current_fps = (self.frame_count as f32 / elapsed) as u32;
            self.frame_count = 0;
            self.last_fps_update = now;
            
            // Перестраиваем геометрию
            self.rebuild_geometry();
        }
    }
    
    fn rebuild_geometry(&mut self) {
        let mut vertices = Vec::new();
        
        // Позиция в левом верхнем углу (NDC: -1 to 1)
        let start_x = -0.95;
        let start_y = 0.90;
        let digit_width = 0.04;
        let digit_height = 0.07;
        let digit_spacing = 0.05;
        let segment_thickness = 0.008;
        
        let color = [1.0, 1.0, 0.0, 0.9]; // Жёлтый
        
        // Отображаем FPS число
        let fps_str = format!("{}", self.current_fps);
        let mut x = start_x;
        
        for ch in fps_str.chars() {
            if let Some(digit) = ch.to_digit(10) {
                self.add_digit(&mut vertices, x, start_y, digit_width, digit_height, segment_thickness, digit as u8, color);
            }
            x += digit_spacing;
        }
        
        self.current_vertex_count = vertices.len() as u32;
        
        if !vertices.is_empty() {
            self.queue.write_buffer(&self.vertex_buffer, 0, bytemuck::cast_slice(&vertices));
        }
    }
    
    /// Добавляет цифру в виде 7-сегментного дисплея
    fn add_digit(&self, vertices: &mut Vec<FpsVertex>, x: f32, y: f32, w: f32, h: f32, t: f32, digit: u8, color: [f32; 4]) {
        // Сегменты 7-сегментного дисплея:
        //  AAA
        // F   B
        //  GGG
        // E   C
        //  DDD
        
        let segments = match digit {
            0 => [true, true, true, true, true, true, false],    // ABCDEF
            1 => [false, true, true, false, false, false, false], // BC
            2 => [true, true, false, true, true, false, true],   // ABDEG
            3 => [true, true, true, true, false, false, true],   // ABCDG
            4 => [false, true, true, false, false, true, true],  // BCFG
            5 => [true, false, true, true, false, true, true],   // ACDFG
            6 => [true, false, true, true, true, true, true],    // ACDEFG
            7 => [true, true, true, false, false, false, false], // ABC
            8 => [true, true, true, true, true, true, true],     // ABCDEFG
            9 => [true, true, true, true, false, true, true],    // ABCDFG
            _ => [false; 7],
        };
        
        let half_h = h / 2.0;
        
        // A - верхний горизонтальный
        if segments[0] {
            self.add_horizontal_segment(vertices, x, y, w, t, color);
        }
        // B - правый верхний вертикальный
        if segments[1] {
            self.add_vertical_segment(vertices, x + w - t, y - t, half_h - t, t, color);
        }
        // C - правый нижний вертикальный
        if segments[2] {
            self.add_vertical_segment(vertices, x + w - t, y - half_h, half_h - t, t, color);
        }
        // D - нижний горизонтальный
        if segments[3] {
            self.add_horizontal_segment(vertices, x, y - h + t, w, t, color);
        }
        // E - левый нижний вертикальный
        if segments[4] {
            self.add_vertical_segment(vertices, x, y - half_h, half_h - t, t, color);
        }
        // F - левый верхний вертикальный
        if segments[5] {
            self.add_vertical_segment(vertices, x, y - t, half_h - t, t, color);
        }
        // G - средний горизонтальный
        if segments[6] {
            self.add_horizontal_segment(vertices, x, y - half_h + t / 2.0, w, t, color);
        }
    }
    
    fn add_horizontal_segment(&self, vertices: &mut Vec<FpsVertex>, x: f32, y: f32, w: f32, t: f32, color: [f32; 4]) {
        // Два треугольника для прямоугольника
        vertices.push(FpsVertex { position: [x, y], color });
        vertices.push(FpsVertex { position: [x + w, y], color });
        vertices.push(FpsVertex { position: [x + w, y - t], color });
        
        vertices.push(FpsVertex { position: [x, y], color });
        vertices.push(FpsVertex { position: [x + w, y - t], color });
        vertices.push(FpsVertex { position: [x, y - t], color });
    }
    
    fn add_vertical_segment(&self, vertices: &mut Vec<FpsVertex>, x: f32, y: f32, h: f32, t: f32, color: [f32; 4]) {
        vertices.push(FpsVertex { position: [x, y], color });
        vertices.push(FpsVertex { position: [x + t, y], color });
        vertices.push(FpsVertex { position: [x + t, y - h], color });
        
        vertices.push(FpsVertex { position: [x, y], color });
        vertices.push(FpsVertex { position: [x + t, y - h], color });
        vertices.push(FpsVertex { position: [x, y - h], color });
    }
    
    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
        if self.current_vertex_count > 0 {
            render_pass.set_pipeline(&self.pipeline);
            render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
            render_pass.draw(0..self.current_vertex_count, 0..1);
        }
    }
}


============================================================
FILE: gui\menu.rs
============================================================

// ============================================
// Game Menu - Hytale-style GPU rendered menu
// Modern glassmorphism design with neon accents
// ============================================

use bytemuck::{Pod, Zeroable};
use wgpu::util::DeviceExt;
use std::time::Instant;

/// Состояние меню
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MenuState {
    Hidden,
    Main,
    Settings,
}

/// Действие из меню
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MenuAction {
    None,
    Resume,
    Settings,
    BackToMain,
    SaveSettings,  // Сохранить настройки и применить LOD
    QuitToDesktop,
}

/// Тип элемента UI
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
pub enum ElementType {
    Button = 0,
    ButtonHover = 1,
    ButtonPrimary = 2,
    ButtonDanger = 3,
    Panel = 4,
    Slider = 5,
    Select = 6,
    Title = 7,
    Overlay = 8,
}

#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct MenuUniforms {
    pub view_proj: [[f32; 4]; 4],
    pub screen_size: [f32; 2],
    pub time: f32,
    pub menu_state: f32,
}

#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct MenuInstance {
    pub pos: [f32; 2],
    pub size: [f32; 2],
    pub state: u32,
    pub extra: f32,  // Для слайдеров - значение 0-1
}

pub struct UIElement {
    pub id: &'static str,
    pub label: String,
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub element_type: ElementType,
    pub hover: bool,
    pub value: f32,  // Для слайдеров
    pub visible: bool,
}

impl UIElement {
    fn new_button(id: &'static str, label: &str, width: f32, height: f32) -> Self {
        Self {
            id,
            label: label.to_string(),
            x: 0.0,
            y: 0.0,
            width,
            height,
            element_type: ElementType::Button,
            hover: false,
            value: 0.0,
            visible: true,
        }
    }
    
    fn new_primary(id: &'static str, label: &str, width: f32, height: f32) -> Self {
        Self {
            id,
            label: label.to_string(),
            x: 0.0,
            y: 0.0,
            width,
            height,
            element_type: ElementType::ButtonPrimary,
            hover: false,
            value: 0.0,
            visible: true,
        }
    }
    
    fn new_danger(id: &'static str, label: &str, width: f32, height: f32) -> Self {
        Self {
            id,
            label: label.to_string(),
            x: 0.0,
            y: 0.0,
            width,
            height,
            element_type: ElementType::ButtonDanger,
            hover: false,
            value: 0.0,
            visible: true,
        }
    }
    
    fn new_slider(id: &'static str, label: &str, width: f32, initial: f32) -> Self {
        Self {
            id,
            label: label.to_string(),
            x: 0.0,
            y: 0.0,
            width,
            height: 20.0,  // Увеличенная высота для лучшей видимости
            element_type: ElementType::Slider,
            hover: false,
            value: initial,
            visible: true,
        }
    }
    
    fn contains(&self, mx: f32, my: f32) -> bool {
        mx >= self.x && mx <= self.x + self.width && 
        my >= self.y && my <= self.y + self.height
    }
    
    fn get_state(&self) -> u32 {
        if self.hover && self.element_type == ElementType::Button {
            ElementType::ButtonHover as u32
        } else {
            self.element_type as u32
        }
    }
}

/// GPU-рендерер меню в стиле Hytale
pub struct MenuSystem {
    // UI элементы по экранам
    main_elements: Vec<UIElement>,
    settings_elements: Vec<UIElement>,
    
    // GPU ресурсы
    instance_buffer: wgpu::Buffer,
    uniform_buffer: wgpu::Buffer,
    bind_group: wgpu::BindGroup,
    pipeline: wgpu::RenderPipeline,
    vertex_buffer: wgpu::Buffer,
    
    // Состояние
    current_state: MenuState,
    screen_width: f32,
    screen_height: f32,
    start_time: Instant,
    
    // Панели
    panel_main: UIElement,
    panel_settings: UIElement,
    overlay: UIElement,
}

impl MenuSystem {
    pub fn new(
        device: &wgpu::Device,
        format: wgpu::TextureFormat,
        _layout: &wgpu::BindGroupLayout,
        width: u32,
        height: u32,
    ) -> Self {
        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Menu Bind Group Layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });
        
        let uniforms = MenuUniforms {
            view_proj: [
                [1.0, 0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0],
            ],
            screen_size: [width as f32, height as f32],
            time: 0.0,
            menu_state: 0.0,
        };
        
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Menu Uniform Buffer"),
            contents: bytemuck::cast_slice(&[uniforms]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });
        
        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Menu Bind Group"),
            layout: &bind_group_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: uniform_buffer.as_entire_binding(),
            }],
        });
        
        // Квадрат (2 треугольника)
        let vertices: Vec<[f32; 2]> = vec![
            [0.0, 0.0], [1.0, 0.0], [1.0, 1.0],
            [0.0, 0.0], [1.0, 1.0], [0.0, 1.0],
        ];
        
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Menu Vertex Buffer"),
            contents: bytemuck::cast_slice(&vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });
        
        let instance_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("Menu Instance Buffer"),
            size: (std::mem::size_of::<MenuInstance>() * 50) as u64,
            usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
            mapped_at_creation: false,
        });
        
        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Menu Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("menu.wgsl").into()),
        });
        
        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Menu Pipeline Layout"),
            bind_group_layouts: &[&bind_group_layout],
            push_constant_ranges: &[],
        });
        
        let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Menu Pipeline"),
            layout: Some(&pipeline_layout),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: Some("vs_main"),
                buffers: &[
                    wgpu::VertexBufferLayout {
                        array_stride: 8,
                        step_mode: wgpu::VertexStepMode::Vertex,
                        attributes: &[wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x2,
                            offset: 0,
                            shader_location: 0,
                        }],
                    },
                    wgpu::VertexBufferLayout {
                        array_stride: std::mem::size_of::<MenuInstance>() as u64,
                        step_mode: wgpu::VertexStepMode::Instance,
                        attributes: &[
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Float32x2,
                                offset: 0,
                                shader_location: 1,
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Float32x2,
                                offset: 8,
                                shader_location: 2,
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Uint32,
                                offset: 16,
                                shader_location: 3,
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Float32,
                                offset: 20,
                                shader_location: 4,
                            },
                        ],
                    },
                ],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format,
                    blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState::default(),
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
            cache: None,
        });
        
        // ========== Главное меню ==========
        let main_elements = vec![
            UIElement::new_primary("resume", "Back to Game", 380.0, 56.0),
            UIElement::new_button("settings", "Settings", 380.0, 56.0),
            UIElement::new_button("stats", "Statistics", 380.0, 56.0),
            UIElement::new_danger("quit", "Quit to Menu", 380.0, 56.0),
        ];
        
        // ========== Меню настроек ==========
        let settings_elements = vec![
            UIElement::new_slider("lod0", "LOD0", 160.0, 0.5),
            UIElement::new_slider("lod1", "LOD1", 160.0, 0.5),
            UIElement::new_slider("lod2", "LOD2", 160.0, 0.5),
            UIElement::new_slider("lod3", "LOD3", 160.0, 0.5),
            UIElement::new_primary("save", "Save", 380.0, 56.0),
            UIElement::new_button("back", "Back", 380.0, 56.0),
        ];
        
        // Панели
        let panel_main = UIElement {
            id: "panel_main",
            label: String::new(),
            x: 0.0,
            y: 0.0,
            width: 420.0,
            height: 380.0,
            element_type: ElementType::Panel,
            hover: false,
            value: 0.0,
            visible: true,
        };
        
        let panel_settings = UIElement {
            id: "panel_settings",
            label: String::new(),
            x: 0.0,
            y: 0.0,
            width: 420.0,
            height: 480.0,
            element_type: ElementType::Panel,
            hover: false,
            value: 0.0,
            visible: true,
        };
        
        let overlay = UIElement {
            id: "overlay",
            label: String::new(),
            x: 0.0,
            y: 0.0,
            width: width as f32,
            height: height as f32,
            element_type: ElementType::Overlay,
            hover: false,
            value: 0.0,
            visible: true,
        };
        
        let mut menu = Self {
            main_elements,
            settings_elements,
            instance_buffer,
            uniform_buffer,
            bind_group,
            pipeline,
            vertex_buffer,
            current_state: MenuState::Hidden,
            screen_width: width as f32,
            screen_height: height as f32,
            start_time: Instant::now(),
            panel_main,
            panel_settings,
            overlay,
        };
        
        menu.update_layout();
        menu
    }
    
    pub fn update_layout(&mut self) {
        let cx = self.screen_width / 2.0;
        let cy = self.screen_height / 2.0;
        
        // Overlay на весь экран
        self.overlay.width = self.screen_width;
        self.overlay.height = self.screen_height;
        
        // ========== Main Menu Layout ==========
        let panel_w = 420.0;
        let panel_h = 380.0;
        self.panel_main.x = cx - panel_w / 2.0;
        self.panel_main.y = cy - panel_h / 2.0;
        self.panel_main.width = panel_w;
        self.panel_main.height = panel_h;
        
        let start_y = self.panel_main.y + 80.0;
        let btn_spacing = 66.0;
        
        for (i, elem) in self.main_elements.iter_mut().enumerate() {
            elem.x = cx - elem.width / 2.0;
            elem.y = start_y + i as f32 * btn_spacing;
            
            // Отступ перед кнопкой выхода
            if elem.id == "quit" {
                elem.y += 20.0;
            }
        }
        
        // ========== Settings Menu Layout ==========
        let settings_h = 480.0;
        self.panel_settings.x = cx - panel_w / 2.0;
        self.panel_settings.y = cy - settings_h / 2.0;
        self.panel_settings.width = panel_w;
        self.panel_settings.height = settings_h;
        
        let settings_start_y = self.panel_settings.y + 100.0;
        let slider_spacing = 50.0;
        
        // LOD слайдеры в сетке 2x2
        let grid_left = self.panel_settings.x + 30.0;
        let grid_right = cx + 15.0;
        
        if self.settings_elements.len() >= 4 {
            // LOD0
            self.settings_elements[0].x = grid_left;
            self.settings_elements[0].y = settings_start_y;
            // LOD1
            self.settings_elements[1].x = grid_right;
            self.settings_elements[1].y = settings_start_y;
            // LOD2
            self.settings_elements[2].x = grid_left;
            self.settings_elements[2].y = settings_start_y + slider_spacing;
            // LOD3
            self.settings_elements[3].x = grid_right;
            self.settings_elements[3].y = settings_start_y + slider_spacing;
        }
        
        // Кнопки внизу
        let buttons_y = self.panel_settings.y + settings_h - 140.0;
        if self.settings_elements.len() >= 6 {
            self.settings_elements[4].x = cx - self.settings_elements[4].width / 2.0;
            self.settings_elements[4].y = buttons_y;
            
            self.settings_elements[5].x = cx - self.settings_elements[5].width / 2.0;
            self.settings_elements[5].y = buttons_y + 60.0;
        }
    }
    
    pub fn resize(&mut self, width: u32, height: u32) {
        self.screen_width = width as f32;
        self.screen_height = height as f32;
        self.update_layout();
    }
    
    pub fn handle_mouse_move(&mut self, mx: f32, my: f32) {
        if self.current_state == MenuState::Hidden {
            return;
        }
        
        let elements = match self.current_state {
            MenuState::Main => &mut self.main_elements,
            MenuState::Settings => &mut self.settings_elements,
            MenuState::Hidden => return,
        };
        
        for elem in elements.iter_mut() {
            elem.hover = elem.contains(mx, my);
        }
    }
    
    pub fn handle_click(&mut self, mx: f32, my: f32) -> MenuAction {
        if self.current_state == MenuState::Hidden {
            return MenuAction::None;
        }
        
        match self.current_state {
            MenuState::Main => {
                for elem in &self.main_elements {
                    if elem.contains(mx, my) {
                        match elem.id {
                            "resume" => {
                                self.current_state = MenuState::Hidden;
                                return MenuAction::Resume;
                            }
                            "settings" => {
                                self.current_state = MenuState::Settings;
                                return MenuAction::Settings;
                            }
                            "quit" => {
                                return MenuAction::QuitToDesktop;
                            }
                            _ => {}
                        }
                    }
                }
            }
            MenuState::Settings => {
                for elem in &self.settings_elements {
                    if elem.contains(mx, my) {
                        match elem.id {
                            "save" => {
                                self.current_state = MenuState::Main;
                                return MenuAction::SaveSettings;
                            }
                            "back" => {
                                self.current_state = MenuState::Main;
                                return MenuAction::BackToMain;
                            }
                            _ => {}
                        }
                    }
                }
            }
            MenuState::Hidden => {}
        }
        
        MenuAction::None
    }
    
    /// Обработка перетаскивания слайдера
    pub fn handle_drag(&mut self, mx: f32, my: f32, pressed: bool) {
        if self.current_state != MenuState::Settings || !pressed {
            return;
        }
        
        for elem in &mut self.settings_elements {
            if elem.element_type == ElementType::Slider {
                // Расширенная зона для слайдера (по высоте)
                let slider_hit_height = 20.0;
                let in_y = my >= elem.y - slider_hit_height / 2.0 
                        && my <= elem.y + slider_hit_height / 2.0;
                let in_x = mx >= elem.x && mx <= elem.x + elem.width;
                
                if in_x && in_y {
                    elem.value = ((mx - elem.x) / elem.width).clamp(0.0, 1.0);
                }
            }
        }
    }
    
    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>, queue: &wgpu::Queue) {
        if self.current_state == MenuState::Hidden {
            return;
        }
        
        let time = self.start_time.elapsed().as_secs_f32();
        
        let uniforms = MenuUniforms {
            view_proj: [
                [1.0, 0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [0.0, 0.0, 0.0, 1.0],
            ],
            screen_size: [self.screen_width, self.screen_height],
            time,
            menu_state: match self.current_state {
                MenuState::Main => 0.0,
                MenuState::Settings => 1.0,
                MenuState::Hidden => 0.0,
            },
        };
        queue.write_buffer(&self.uniform_buffer, 0, bytemuck::cast_slice(&[uniforms]));
        
        // Собираем все instances
        let mut instances: Vec<MenuInstance> = Vec::new();
        
        // 1. Overlay (затемнение фона)
        instances.push(MenuInstance {
            pos: [self.overlay.x, self.overlay.y],
            size: [self.overlay.width, self.overlay.height],
            state: ElementType::Overlay as u32,
            extra: 0.0,
        });
        
        // 2. Панель
        let panel = match self.current_state {
            MenuState::Main => &self.panel_main,
            MenuState::Settings => &self.panel_settings,
            MenuState::Hidden => &self.panel_main,
        };
        instances.push(MenuInstance {
            pos: [panel.x, panel.y],
            size: [panel.width, panel.height],
            state: ElementType::Panel as u32,
            extra: 0.0,
        });
        
        // 3. Элементы UI
        let elements = match self.current_state {
            MenuState::Main => &self.main_elements,
            MenuState::Settings => &self.settings_elements,
            MenuState::Hidden => &self.main_elements,
        };
        
        for elem in elements {
            if !elem.visible {
                continue;
            }
            instances.push(MenuInstance {
                pos: [elem.x, elem.y],
                size: [elem.width, elem.height],
                state: elem.get_state(),
                extra: elem.value,
            });
        }
        
        queue.write_buffer(&self.instance_buffer, 0, bytemuck::cast_slice(&instances));
        
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_bind_group(0, &self.bind_group, &[]);
        render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        render_pass.set_vertex_buffer(1, self.instance_buffer.slice(..));
        render_pass.draw(0..6, 0..instances.len() as u32);
    }
    
    pub fn toggle(&mut self) {
        self.current_state = match self.current_state {
            MenuState::Hidden => MenuState::Main,
            _ => MenuState::Hidden,
        };
    }
    
    pub fn is_visible(&self) -> bool {
        self.current_state != MenuState::Hidden
    }
    
    pub fn show(&mut self) {
        self.current_state = MenuState::Main;
    }
    
    pub fn hide(&mut self) {
        self.current_state = MenuState::Hidden;
    }
    
    pub fn state(&self) -> MenuState {
        self.current_state
    }
    
    /// Получить значения LOD слайдеров
    pub fn get_lod_values(&self) -> [f32; 4] {
        let mut values = [0.5; 4];
        for (i, elem) in self.settings_elements.iter().take(4).enumerate() {
            values[i] = elem.value;
        }
        values
    }
    
    /// Получить параметры текста для рендеринга
    pub fn get_text_params(&self) -> Vec<super::TextParams> {
        use super::{TextParams, TextAlign};
        
        let mut texts = Vec::new();
        let cx = self.screen_width / 2.0;
        
        match self.current_state {
            MenuState::Main => {
                // Заголовок "HYTALE"
                texts.push(TextParams {
                    x: cx,
                    y: self.panel_main.y + 25.0,
                    text: "HYTALE".to_string(),
                    size: 28.0,
                    color: [0.0, 0.94, 1.0, 1.0], // Cyan accent
                    align: TextAlign::Center,
                    max_width: None,
                });
                
                // Подзаголовок
                texts.push(TextParams {
                    x: cx,
                    y: self.panel_main.y + 55.0,
                    text: "World: Creative_Zone_01".to_string(),
                    size: 12.0,
                    color: [1.0, 1.0, 1.0, 0.5],
                    align: TextAlign::Center,
                    max_width: None,
                });
                
                // Текст кнопок
                for elem in &self.main_elements {
                    println!("Button text: '{}' at ({}, {})", elem.label, elem.x + elem.width / 2.0, elem.y + elem.height / 2.0 - 8.0);
                    texts.push(TextParams {
                        x: elem.x + elem.width / 2.0,
                        y: elem.y + elem.height / 2.0 - 8.0,
                        text: elem.label.clone(),
                        size: 16.0,
                        color: [1.0, 1.0, 1.0, 1.0], // Белый для всех
                        align: TextAlign::Center,
                        max_width: None,
                    });
                }
            }
            MenuState::Settings => {
                // Заголовок
                texts.push(TextParams {
                    x: cx,
                    y: self.panel_settings.y + 30.0,
                    text: "Settings".to_string(),
                    size: 22.0,
                    color: [0.0, 0.94, 1.0, 1.0],
                    align: TextAlign::Center,
                    max_width: None,
                });
                
                // Секция LOD
                texts.push(TextParams {
                    x: self.panel_settings.x + 30.0,
                    y: self.panel_settings.y + 75.0,
                    text: "LOD Distances".to_string(),
                    size: 11.0,
                    color: [1.0, 1.0, 1.0, 0.5],
                    align: TextAlign::Left,
                    max_width: None,
                });
                
                // Лейблы и значения слайдеров
                for (i, elem) in self.settings_elements.iter().take(4).enumerate() {
                    let lod_name = format!("LOD{}", i);
                    let lod_value = format!("{}", (elem.value * 512.0) as i32);
                    
                    // Название слайдера
                    texts.push(TextParams {
                        x: elem.x,
                        y: elem.y - 18.0,
                        text: lod_name,
                        size: 14.0,
                        color: [1.0, 1.0, 1.0, 1.0],
                        align: TextAlign::Left,
                        max_width: None,
                    });
                    
                    // Значение
                    texts.push(TextParams {
                        x: elem.x + elem.width,
                        y: elem.y - 18.0,
                        text: lod_value,
                        size: 14.0,
                        color: [0.0, 0.94, 1.0, 1.0],
                        align: TextAlign::Right,
                        max_width: None,
                    });
                }
                
                // Текст кнопок
                for elem in self.settings_elements.iter().skip(4) {
                    texts.push(TextParams {
                        x: elem.x + elem.width / 2.0,
                        y: elem.y + elem.height / 2.0 - 8.0,
                        text: elem.label.clone(),
                        size: 16.0,
                        color: if elem.element_type == ElementType::ButtonPrimary {
                            [0.0, 0.0, 0.0, 1.0]
                        } else {
                            [1.0, 1.0, 1.0, 1.0]
                        },
                        align: TextAlign::Center,
                        max_width: None,
                    });
                }
            }
            MenuState::Hidden => {}
        }
        
        texts
    }
}

// ============================================
// Legacy GameMenu wrapper для совместимости
// ============================================

use super::layout::{LayoutNode, Rect};

pub struct GameMenu {
    state: MenuState,
    width: u32,
    height: u32,
}

impl GameMenu {
    pub fn new(width: u32, height: u32) -> Self {
        Self {
            state: MenuState::Hidden,
            width,
            height,
        }
    }
    
    pub fn toggle(&mut self) {
        self.state = match self.state {
            MenuState::Hidden => MenuState::Main,
            _ => MenuState::Hidden,
        };
    }
    
    pub fn hide(&mut self) {
        self.state = MenuState::Hidden;
    }
    
    pub fn is_visible(&self) -> bool {
        self.state != MenuState::Hidden
    }
    
    pub fn layout(&self) -> Vec<LayoutNode> {
        if !self.is_visible() {
            return Vec::new();
        }
        
        let center_x = self.width as f32 / 2.0;
        let start_y = self.height as f32 / 4.0;
        
        vec![
            LayoutNode {
                rect: Rect { x: center_x - 200.0, y: start_y, width: 400.0, height: 40.0 },
                id: Some("resume".to_string()),
            },
            LayoutNode {
                rect: Rect { x: center_x - 200.0, y: start_y + 50.0, width: 195.0, height: 40.0 },
                id: Some("settings".to_string()),
            },
            LayoutNode {
                rect: Rect { x: center_x + 5.0, y: start_y + 50.0, width: 195.0, height: 40.0 },
                id: Some("lan".to_string()),
            },
            LayoutNode {
                rect: Rect { x: center_x - 200.0, y: start_y + 100.0, width: 400.0, height: 40.0 },
                id: Some("quit".to_string()),
            },
        ]
    }
    
    pub fn resize(&mut self, width: u32, height: u32) {
        self.width = width;
        self.height = height;
    }
    
    pub fn process_click(&mut self, x: f32, y: f32) -> MenuAction {
        if self.state == MenuState::Hidden {
            return MenuAction::None;
        }
        
        for node in self.layout() {
            if node.rect.contains(x, y) {
                if let Some(id) = &node.id {
                    match id.as_str() {
                        "resume" => {
                            self.hide();
                            return MenuAction::Resume;
                        }
                        "settings" => {
                            self.state = MenuState::Settings;
                            return MenuAction::Settings;
                        }
                        "quit" => {
                            return MenuAction::QuitToDesktop;
                        }
                        _ => {}
                    }
                }
            }
        }
        
        MenuAction::None
    }
}


============================================================
FILE: gui\menu.wgsl
============================================================

// ============================================
// Menu UI Shader - Hytale-style modern design
// Glassmorphism + Neon accents + Smooth animations
// ============================================

struct GlobalUniforms {
    view_proj: mat4x4<f32>,
    screen_size: vec2<f32>,
    time: f32,
    menu_state: f32, // 0: main, 1: settings
}

@group(0) @binding(0) var<uniform> global: GlobalUniforms;

struct VertexInput {
    @location(0) position: vec2<f32>,
}

struct InstanceInput {
    @location(1) pos: vec2<f32>,
    @location(2) size: vec2<f32>,
    @location(3) state: u32,          // 0: Normal, 1: Hover, 2: Primary, 3: Danger, 4: Panel, 5: Slider
    @location(4) extra: f32,          // Slider value (0-1) or animation progress
}

struct VertexOutput {
    @builtin(position) clip_pos: vec4<f32>,
    @location(0) uv: vec2<f32>,
    @location(1) @interpolate(flat) size: vec2<f32>,
    @location(2) @interpolate(flat) state: u32,
    @location(3) @interpolate(flat) extra: f32,
    @location(4) world_pos: vec2<f32>,
}

// Цветовая палитра Hytale
const ACCENT: vec3<f32> = vec3<f32>(0.0, 0.94, 1.0);           // #00f0ff - cyan
const BG_BLUR: vec4<f32> = vec4<f32>(0.039, 0.071, 0.11, 0.85); // rgba(10, 18, 28, 0.85)
const TEXT_MAIN: vec3<f32> = vec3<f32>(1.0, 1.0, 1.0);
const TEXT_DIM: vec3<f32> = vec3<f32>(1.0, 1.0, 1.0);
const PANEL_RADIUS: f32 = 24.0;
const ITEM_RADIUS: f32 = 14.0;

@vertex
fn vs_main(in: VertexInput, inst: InstanceInput) -> VertexOutput {
    var out: VertexOutput;
    
    let pixel_pos = inst.pos + in.position * inst.size;
    let ndc_x = (pixel_pos.x / global.screen_size.x) * 2.0 - 1.0;
    let ndc_y = (1.0 - pixel_pos.y / global.screen_size.y) * 2.0 - 1.0;
    
    out.clip_pos = vec4<f32>(ndc_x, ndc_y, 0.0, 1.0);
    out.uv = in.position;
    out.size = inst.size;
    out.state = inst.state;
    out.extra = inst.extra;
    out.world_pos = pixel_pos;
    
    return out;
}

// SDF для скруглённого прямоугольника
fn sdf_rounded_rect(p: vec2<f32>, size: vec2<f32>, radius: f32) -> f32 {
    let q = abs(p - size * 0.5) - size * 0.5 + vec2<f32>(radius);
    return length(max(q, vec2<f32>(0.0))) + min(max(q.x, q.y), 0.0) - radius;
}

// Плавный шум для текстуры
fn noise(p: vec2<f32>) -> f32 {
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f);
    
    let a = hash2d(i);
    let b = hash2d(i + vec2<f32>(1.0, 0.0));
    let c = hash2d(i + vec2<f32>(0.0, 1.0));
    let d = hash2d(i + vec2<f32>(1.0, 1.0));
    
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

fn hash2d(p: vec2<f32>) -> f32 {
    return fract(sin(dot(p, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

// Glow эффект
fn glow(d: f32, intensity: f32, spread: f32) -> f32 {
    return intensity / (1.0 + abs(d) * spread);
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    let px = in.uv * in.size;
    let w = in.size.x;
    let h = in.size.y;
    let time = global.time;
    
    // Определяем радиус скругления в зависимости от типа элемента
    var radius = ITEM_RADIUS;
    if (in.state == 4u) { radius = PANEL_RADIUS; } // Panel
    
    // SDF расстояние до края
    let d = sdf_rounded_rect(px, in.size, radius);
    
    // Отсекаем пиксели за пределами скруглённого прямоугольника
    if (d > 0.5) {
        discard;
    }
    
    // ========== PANEL (state 4) - Основная панель меню ==========
    if (in.state == 4u) {
        // Glassmorphism фон
        var bg = BG_BLUR;
        
        // Тонкая светлая рамка
        let border_dist = abs(d + 1.0);
        if (border_dist < 1.5) {
            let border_alpha = 1.0 - border_dist / 1.5;
            bg = mix(bg, vec4<f32>(1.0, 1.0, 1.0, 0.15), border_alpha * 0.3);
        }
        
        // Лёгкий градиент сверху вниз
        let gradient = 1.0 - in.uv.y * 0.1;
        bg.r *= gradient;
        bg.g *= gradient;
        bg.b *= gradient;
        
        // Тонкий шум для текстуры стекла
        let n = noise(px * 0.1 + time * 0.5) * 0.02;
        bg.r += n;
        bg.g += n;
        bg.b += n;
        
        return bg;
    }
    
    // ========== PRIMARY BUTTON (state 2) - Акцентная кнопка ==========
    if (in.state == 2u) {
        var color = vec4<f32>(ACCENT, 1.0);
        
        // Hover эффект - подсветка
        let hover_glow = glow(d, 0.3, 0.1);
        color.r += hover_glow * 0.2;
        color.g += hover_glow * 0.2;
        color.b += hover_glow * 0.2;
        
        // Пульсация
        let pulse = sin(time * 3.0) * 0.05 + 0.95;
        color.r *= pulse;
        color.g *= pulse;
        color.b *= pulse;
        
        // Внутренний градиент
        let inner_gradient = 1.0 - in.uv.y * 0.2;
        color.r *= inner_gradient;
        color.g *= inner_gradient;
        color.b *= inner_gradient;
        
        // Glow по краям
        if (d > -3.0) {
            let edge_glow = 1.0 - (-d / 3.0);
            color = mix(color, vec4<f32>(1.0, 1.0, 1.0, 1.0), edge_glow * 0.3);
        }
        
        return color;
    }
    
    // ========== NORMAL BUTTON (state 0) ==========
    if (in.state == 0u) {
        // Полупрозрачный фон
        var color = vec4<f32>(1.0, 1.0, 1.0, 0.05);
        
        // Рамка
        if (d > -1.5) {
            let border_alpha = 1.0 - (-d / 1.5);
            color = mix(color, vec4<f32>(1.0, 1.0, 1.0, 0.15), border_alpha);
        }
        
        return color;
    }
    
    // ========== HOVER BUTTON (state 1) ==========
    if (in.state == 1u) {
        // Подсвеченный фон при наведении
        var color = vec4<f32>(1.0, 1.0, 1.0, 0.12);
        
        // Акцентная рамка
        if (d > -2.0) {
            let border_alpha = 1.0 - (-d / 2.0);
            color = mix(color, vec4<f32>(ACCENT, 0.8), border_alpha);
        }
        
        // Glow эффект
        let g = glow(d, 0.15, 0.08);
        color.r += ACCENT.r * g;
        color.g += ACCENT.g * g;
        color.b += ACCENT.b * g;
        
        // Сдвиг вправо (анимация) - имитируем через градиент
        let shift_gradient = smoothstep(0.0, 0.1, in.uv.x);
        color.a *= shift_gradient * 0.5 + 0.5;
        
        return color;
    }
    
    // ========== DANGER BUTTON (state 3) ==========
    if (in.state == 3u) {
        var color = vec4<f32>(1.0, 1.0, 1.0, 0.05);
        
        // Красноватая рамка
        let danger_color = vec3<f32>(1.0, 0.2, 0.2);
        if (d > -1.5) {
            let border_alpha = 1.0 - (-d / 1.5);
            color = mix(color, vec4<f32>(danger_color * 0.3, 0.3), border_alpha);
        }
        
        return color;
    }
    
    // ========== SLIDER (state 5) ==========
    if (in.state == 5u) {
        let slider_value = in.extra;
        
        // Трек слайдера (тонкая полоска по центру)
        let track_height = 4.0;
        let track_y = h * 0.5;
        let in_track = abs(px.y - track_y) < track_height * 0.5;
        
        // Фон трека
        var color = vec4<f32>(1.0, 1.0, 1.0, 0.1);
        
        if (in_track) {
            // Заполненная часть
            let fill_width = w * slider_value;
            if (px.x < fill_width) {
                let fill_progress = px.x / max(fill_width, 1.0);
                color = vec4<f32>(ACCENT * (0.7 + fill_progress * 0.3), 0.9);
            }
        }
        
        // Ползунок (thumb) - круглый
        let thumb_x = w * slider_value;
        let thumb_radius = 10.0;
        let thumb_center = vec2<f32>(clamp(thumb_x, thumb_radius, w - thumb_radius), h * 0.5);
        let thumb_dist = length(px - thumb_center);
        
        if (thumb_dist < thumb_radius + 2.0) {
            // Glow вокруг ползунка
            if (thumb_dist >= thumb_radius) {
                let glow_alpha = 1.0 - (thumb_dist - thumb_radius) / 2.0;
                color = mix(color, vec4<f32>(ACCENT, 0.5), glow_alpha * 0.5);
            } else {
                // Сам ползунок
                let inner_alpha = 1.0 - thumb_dist / thumb_radius;
                color = vec4<f32>(ACCENT, 0.9 + inner_alpha * 0.1);
                
                // Блик сверху
                if (px.y < thumb_center.y - thumb_radius * 0.3) {
                    color = mix(color, vec4<f32>(1.0, 1.0, 1.0, 1.0), 0.2);
                }
            }
        }
        
        return color;
    }
    
    // ========== SELECT/DROPDOWN (state 6) ==========
    if (in.state == 6u) {
        var color = vec4<f32>(1.0, 1.0, 1.0, 0.05);
        
        // Рамка
        if (d > -1.5) {
            let border_alpha = 1.0 - (-d / 1.5);
            color = mix(color, vec4<f32>(1.0, 1.0, 1.0, 0.15), border_alpha);
        }
        
        // Стрелка вниз (простой треугольник справа)
        let arrow_center = vec2<f32>(w - 20.0, h * 0.5);
        let arrow_size = 6.0;
        let ap = px - arrow_center;
        
        // Проверка попадания в треугольник
        if (ap.y > -arrow_size * 0.5 && ap.y < arrow_size * 0.5) {
            let expected_x = (arrow_size * 0.5 - abs(ap.y)) * 1.5;
            if (abs(ap.x) < expected_x) {
                color = vec4<f32>(TEXT_DIM * 0.5, 1.0);
            }
        }
        
        return color;
    }
    
    // ========== TITLE/HEADER (state 7) ==========
    if (in.state == 7u) {
        // Прозрачный фон, только для позиционирования текста
        // Акцентный цвет для заголовка
        var color = vec4<f32>(0.0, 0.0, 0.0, 0.0);
        
        // Подчёркивание
        if (in.uv.y > 0.9) {
            let line_alpha = smoothstep(0.9, 1.0, in.uv.y);
            color = vec4<f32>(ACCENT * 0.5, line_alpha * 0.3);
        }
        
        return color;
    }
    
    // ========== OVERLAY (state 8) - Затемнение фона ==========
    if (in.state == 8u) {
        // Радиальный градиент затемнения
        let center = global.screen_size * 0.5;
        let dist_from_center = length(in.world_pos - center) / length(global.screen_size * 0.5);
        
        // Центр светлее, края темнее
        let darkness = mix(0.2, 0.8, dist_from_center);
        
        return vec4<f32>(0.0, 0.0, 0.0, darkness);
    }
    
    // Fallback
    return vec4<f32>(1.0, 0.0, 1.0, 1.0);
}


============================================================
FILE: gui\mod.rs
============================================================

// ============================================
// GUI Module - Minecraft-style menu rendering
// ============================================

mod menu;
mod text;
mod crosshair;
mod fps_counter;
pub mod hotbar;
pub mod inventory;

pub use menu::{GameMenu, MenuState, MenuAction, MenuSystem};
pub use text::{TextRenderer, TextParams, TextAlign};
pub use hotbar::{Hotbar, HotbarItem, HotbarRenderer, HotbarSlot};
pub use crosshair::{Crosshair, BlockHighlight, UiVertex, WireVertex};
pub use fps_counter::FpsCounter;
pub use inventory::{Inventory, InventoryRenderer};

/// GPU рендерер для меню
pub struct GuiRenderer {
    menu_system: MenuSystem,
    text_renderer: TextRenderer,
    hotbar_renderer: hotbar::HotbarRenderer,
    hotbar: Hotbar,
    inventory_renderer: inventory::InventoryRenderer,
    inventory: Inventory,
    screen_width: u32,
    screen_height: u32,
}

impl GuiRenderer {
    pub fn new(
        device: &wgpu::Device,
        queue: &wgpu::Queue,
        format: wgpu::TextureFormat,
        global_bind_group_layout: &wgpu::BindGroupLayout,
        width: u32,
        height: u32,
    ) -> Self {
        let menu_system = MenuSystem::new(device, format, global_bind_group_layout, width, height);
        let text_renderer = TextRenderer::new(device, queue, format, width, height);
        let hotbar_renderer = hotbar::HotbarRenderer::new(device, format, width, height);
        let hotbar = Hotbar::new();
        let inventory_renderer = inventory::InventoryRenderer::new(device, format, width, height);
        let inventory = Inventory::new();
        
        Self { 
            menu_system,
            text_renderer,
            hotbar_renderer,
            hotbar,
            inventory_renderer,
            inventory,
            screen_width: width,
            screen_height: height,
        }
    }
    
    pub fn resize(&mut self, queue: &wgpu::Queue, width: u32, height: u32) {
        self.menu_system.resize(width, height);
        self.text_renderer.resize(queue, width, height);
        self.hotbar_renderer.resize(width, height);
        self.inventory_renderer.resize(width, height);
        self.screen_width = width;
        self.screen_height = height;
    }
    
    pub fn menu_system(&mut self) -> &mut MenuSystem {
        &mut self.menu_system
    }
    
    pub fn hotbar(&mut self) -> &mut Hotbar {
        &mut self.hotbar
    }
    
    pub fn inventory(&mut self) -> &mut Inventory {
        &mut self.inventory
    }
    
    pub fn inventory_ref(&self) -> &Inventory {
        &self.inventory
    }
    
    pub fn inventory_renderer(&self) -> &inventory::InventoryRenderer {
        &self.inventory_renderer
    }
    
    pub fn inventory_renderer_mut(&mut self) -> &mut inventory::InventoryRenderer {
        &mut self.inventory_renderer
    }
    
    pub fn screen_size(&self) -> (f32, f32) {
        (self.screen_width as f32, self.screen_height as f32)
    }
    
    /// Рендерит меню используя encoder (создаёт свой render pass)
    pub fn render(
        &mut self,
        device: &wgpu::Device,
        encoder: &mut wgpu::CommandEncoder,
        view: &wgpu::TextureView,
        queue: &wgpu::Queue,
        mouse_pos: (f32, f32),
    ) {
        // Рендерим хотбар (всегда, если не в меню)
        if !self.menu_system.is_visible() && self.hotbar.is_visible() {
            let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some("Hotbar Render Pass"),
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view,
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Load,
                        store: wgpu::StoreOp::Store,
                    },
                })],
                depth_stencil_attachment: None,
                timestamp_writes: None,
                occlusion_query_set: None,
            });
            
            self.hotbar_renderer.render(&mut render_pass, queue, &self.hotbar);
        }
        
        // Рендерим инвентарь
        if self.inventory.is_visible() {
            self.inventory_renderer.update_inventory_scroll(&mut self.inventory);
            
            {
                let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                    label: Some("Inventory Render Pass"),
                    color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                        view,
                        resolve_target: None,
                        ops: wgpu::Operations {
                            load: wgpu::LoadOp::Load,
                            store: wgpu::StoreOp::Store,
                        },
                    })],
                    depth_stencil_attachment: None,
                    timestamp_writes: None,
                    occlusion_query_set: None,
                });
                
                self.inventory_renderer.render(&mut render_pass, queue, &self.inventory);
            }
            
            // Рендерим перетаскиваемый блок поверх всего
            if self.inventory.dragging().is_some() {
                let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                    label: Some("Dragging Block Render Pass"),
                    color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                        view,
                        resolve_target: None,
                        ops: wgpu::Operations {
                            load: wgpu::LoadOp::Load,
                            store: wgpu::StoreOp::Store,
                        },
                    })],
                    depth_stencil_attachment: None,
                    timestamp_writes: None,
                    occlusion_query_set: None,
                });
                
                self.inventory_renderer.render_dragging(&mut render_pass, queue, &self.inventory, mouse_pos.0, mouse_pos.1);
            }
            
            // Рендерим текст инвентаря
            let (panel_x, panel_y) = self.inventory_renderer.panel_pos();
            let (panel_w, _) = self.inventory_renderer.panel_size();
            
            let texts = vec![
                TextParams {
                    x: panel_x + panel_w / 2.0,
                    y: panel_y + 18.0,
                    text: "INVENTORY".to_string(),
                    size: 20.0,
                    color: [0.0, 0.94, 1.0, 1.0],
                    align: TextAlign::Center,
                    max_width: None,
                },
            ];
            self.text_renderer.render(device, encoder, view, queue, &texts);
            return;
        }
        
        if !self.menu_system.is_visible() {
            return;
        }
        
        // Рендерим UI элементы меню
        {
            let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some("Menu Render Pass"),
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view,
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Load,
                        store: wgpu::StoreOp::Store,
                    },
                })],
                depth_stencil_attachment: None,
                timestamp_writes: None,
                occlusion_query_set: None,
            });
            
            self.menu_system.render(&mut render_pass, queue);
        }
        
        // Рендерим текст поверх
        let texts = self.menu_system.get_text_params();
        self.text_renderer.render(device, encoder, view, queue, &texts);
    }
}

// Заглушки для layout (для совместимости)
pub mod layout {
    #[derive(Debug, Clone)]
    pub struct LayoutNode {
        pub rect: Rect,
        pub id: Option<String>,
    }
    
    #[derive(Debug, Clone, Copy, Default)]
    pub struct Rect {
        pub x: f32,
        pub y: f32,
        pub width: f32,
        pub height: f32,
    }
    
    impl Rect {
        pub fn contains(&self, px: f32, py: f32) -> bool {
            px >= self.x && px <= self.x + self.width &&
            py >= self.y && py <= self.y + self.height
        }
    }
}


============================================================
FILE: gui\text.rs
============================================================

// ============================================
// Text Renderer - Рендеринг текста через wgpu_text
// ============================================

use wgpu_text::glyph_brush::{
    ab_glyph::FontRef, Section, Text,
};
use wgpu_text::BrushBuilder;

/// Выравнивание текста
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TextAlign {
    Left,
    Center,
    Right,
}

/// Параметры текста для рендеринга
#[derive(Clone)]
pub struct TextParams {
    pub x: f32,
    pub y: f32,
    pub text: String,
    pub size: f32,
    pub color: [f32; 4],
    pub align: TextAlign,
    pub max_width: Option<f32>,
}

impl TextParams {
    pub fn new(text: &str, x: f32, y: f32, size: f32) -> Self {
        Self {
            x,
            y,
            text: text.to_string(),
            size,
            color: [1.0, 1.0, 1.0, 1.0],
            align: TextAlign::Left,
            max_width: None,
        }
    }
    
    pub fn centered(text: &str, x: f32, y: f32, size: f32) -> Self {
        Self {
            x,
            y,
            text: text.to_string(),
            size,
            color: [1.0, 1.0, 1.0, 1.0],
            align: TextAlign::Center,
            max_width: None,
        }
    }
    
    pub fn with_color(mut self, color: [f32; 4]) -> Self {
        self.color = color;
        self
    }
}

/// GPU рендерер текста
pub struct TextRenderer {
    brush: wgpu_text::TextBrush<FontRef<'static>>,
    screen_width: u32,
    screen_height: u32,
}

impl TextRenderer {
    pub fn new(
        device: &wgpu::Device,
        _queue: &wgpu::Queue,
        format: wgpu::TextureFormat,
        width: u32,
        height: u32,
    ) -> Self {
        // Загружаем шрифт
        let font_data: &'static [u8] = include_bytes!("../../../assets/fonts/Roboto-Regular.ttf");
        let font = FontRef::try_from_slice(font_data).expect("Failed to load font");
        
        let brush = BrushBuilder::using_font(font)
            .build(device, width, height, format);
        
        Self {
            brush,
            screen_width: width,
            screen_height: height,
        }
    }
    
    pub fn resize(&mut self, queue: &wgpu::Queue, width: u32, height: u32) {
        self.screen_width = width;
        self.screen_height = height;
        self.brush.resize_view(width as f32, height as f32, queue);
    }
    
    /// Подготовить и отрендерить текст
    pub fn render(
        &mut self,
        device: &wgpu::Device,
        encoder: &mut wgpu::CommandEncoder,
        view: &wgpu::TextureView,
        queue: &wgpu::Queue,
        texts: &[TextParams],
    ) {
        if texts.is_empty() {
            return;
        }
        
        // Собираем все секции
        let sections: Vec<Section> = texts.iter().map(|params| {
            // Вычисляем ширину текста приблизительно
            let approx_width = params.text.chars().count() as f32 * params.size * 0.5;
            
            // Корректируем позицию в зависимости от выравнивания
            let pos_x = match params.align {
                TextAlign::Center => params.x - approx_width / 2.0,
                TextAlign::Right => params.x - approx_width,
                TextAlign::Left => params.x,
            };
            
            Section::default()
                .add_text(
                    Text::new(&params.text)
                        .with_scale(params.size)
                        .with_color(params.color),
                )
                .with_screen_position((pos_x, params.y))
        }).collect();
        
        // Передаём все секции одним вызовом
        self.brush.queue(device, queue, sections).unwrap();
        
        // Рендерим
        {
            let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some("Text Render Pass"),
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view,
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Load,
                        store: wgpu::StoreOp::Store,
                    },
                })],
                depth_stencil_attachment: None,
                timestamp_writes: None,
                occlusion_query_set: None,
            });
            
            self.brush.draw(&mut render_pass);
        }
    }
}


============================================================
FILE: gui\hotbar\hotbar.wgsl
============================================================

// ============================================
// Hotbar Shader - Hi-Tech glassmorphism style
// Cyan neon accents + blur effect + animations
// ============================================

struct HotbarUniforms {
    screen_size: vec2<f32>,
    time: f32,
    selected_slot: f32,
}

@group(0) @binding(0) var<uniform> uniforms: HotbarUniforms;

struct VertexInput {
    @location(0) position: vec2<f32>,
}

struct InstanceInput {
    @location(1) pos: vec2<f32>,
    @location(2) size: vec2<f32>,
    @location(3) slot_index: u32,
    @location(4) is_selected: u32,
    @location(5) has_item: u32,
    @location(6) top_color: vec4<f32>,
    @location(7) side_color: vec4<f32>,
}

struct VertexOutput {
    @builtin(position) clip_pos: vec4<f32>,
    @location(0) uv: vec2<f32>,
    @location(1) @interpolate(flat) size: vec2<f32>,
    @location(2) @interpolate(flat) slot_index: u32,
    @location(3) @interpolate(flat) is_selected: u32,
    @location(4) @interpolate(flat) has_item: u32,
    @location(5) @interpolate(flat) top_color: vec4<f32>,
    @location(6) @interpolate(flat) side_color: vec4<f32>,
    @location(7) world_pos: vec2<f32>,
}

// Цветовая палитра Hi-Tech
const ACCENT: vec3<f32> = vec3<f32>(0.0, 0.953, 1.0);           // #00f3ff - cyan
const BG_DARK: vec4<f32> = vec4<f32>(0.0, 0.039, 0.078, 0.4);   // rgba(0, 10, 20, 0.4)
const SLOT_BG: vec4<f32> = vec4<f32>(0.0, 0.078, 0.118, 0.6);   // rgba(0, 20, 30, 0.6)
const BORDER_COLOR: vec3<f32> = vec3<f32>(0.0, 1.0, 1.0);       // Cyan border

@vertex
fn vs_main(in: VertexInput, inst: InstanceInput) -> VertexOutput {
    var out: VertexOutput;
    
    let pixel_pos = inst.pos + in.position * inst.size;
    let ndc_x = (pixel_pos.x / uniforms.screen_size.x) * 2.0 - 1.0;
    let ndc_y = (1.0 - pixel_pos.y / uniforms.screen_size.y) * 2.0 - 1.0;
    
    out.clip_pos = vec4<f32>(ndc_x, ndc_y, 0.0, 1.0);
    out.uv = in.position;
    out.size = inst.size;
    out.slot_index = inst.slot_index;
    out.is_selected = inst.is_selected;
    out.has_item = inst.has_item;
    out.top_color = inst.top_color;
    out.side_color = inst.side_color;
    out.world_pos = pixel_pos;
    
    return out;
}

// SDF для скруглённого прямоугольника
fn sdf_rounded_rect(p: vec2<f32>, size: vec2<f32>, radius: f32) -> f32 {
    let q = abs(p - size * 0.5) - size * 0.5 + vec2<f32>(radius);
    return length(max(q, vec2<f32>(0.0))) + min(max(q.x, q.y), 0.0) - radius;
}

// SDF для скошенного угла (clip-path эффект)
fn sdf_clipped_rect(p: vec2<f32>, size: vec2<f32>, clip_size: f32) -> f32 {
    // Основной прямоугольник
    let rect_d = sdf_rounded_rect(p, size, 0.0);
    
    // Скошенный угол в правом нижнем углу
    let corner = vec2<f32>(size.x - clip_size, size.y);
    let to_corner = p - corner;
    let clip_d = to_corner.x + to_corner.y - clip_size;
    
    return max(rect_d, clip_d);
}

// Простой шум
fn hash(p: vec2<f32>) -> f32 {
    return fract(sin(dot(p, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

// Процедурная текстура блока (точки, вариации)
fn block_texture(uv: vec2<f32>, base_color: vec3<f32>, seed: u32) -> f32 {
    var variation = 0.0;
    
    // Пиксельная сетка 8x8
    let pixel_size = 0.125;
    let pixel_uv = floor(uv / pixel_size);
    let pixel_seed = pixel_uv + vec2<f32>(f32(seed) * 7.3, f32(seed) * 3.7);
    
    let noise_val = hash(pixel_seed * 0.17);
    
    // Светлые и тёмные точки
    if (noise_val > 0.82) {
        variation = 0.08;
    } else if (noise_val < 0.18) {
        variation = -0.06;
    }
    
    // Дополнительный мелкий шум
    let fine_noise = hash(uv * 23.0 + vec2<f32>(f32(seed))) * 0.04 - 0.02;
    variation += fine_noise;
    
    return variation;
}

// Glow эффект
fn glow(d: f32, intensity: f32, spread: f32) -> f32 {
    return intensity / (1.0 + abs(d) * spread);
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    let px = in.uv * in.size;
    let w = in.size.x;
    let h = in.size.y;
    let time = uniforms.time;
    
    // ========== BACKGROUND (slot_index == 99) ==========
    if (in.slot_index == 99u) {
        let radius = 8.0;
        let d = sdf_rounded_rect(px, in.size, radius);
        
        // Отсекаем за пределами
        if (d > 0.5) {
            discard;
        }
        
        // Glassmorphism фон
        var color = BG_DARK;
        
        // Тонкая рамка сверху (декоративная полоска)
        if (d > -2.0 && d <= 0.0) {
            let border_alpha = 1.0 - (-d / 2.0);
            color = mix(color, vec4<f32>(BORDER_COLOR * 0.2, 0.2), border_alpha * 0.5);
        }
        
        // Градиентная полоска сверху по центру
        let center_x = w * 0.5;
        let stripe_width = w * 0.6;
        let dist_from_center = abs(px.x - center_x);
        if (px.y < 2.0 && dist_from_center < stripe_width * 0.5) {
            let stripe_alpha = 1.0 - dist_from_center / (stripe_width * 0.5);
            let stripe_y_alpha = 1.0 - px.y / 2.0;
            color = mix(color, vec4<f32>(ACCENT, 0.8), stripe_alpha * stripe_y_alpha * 0.7);
        }
        
        return color;
    }
    
    // ========== SLOT ==========
    let clip_size = h * 0.15; // 15% скос угла
    let d = sdf_clipped_rect(px, in.size, clip_size);
    
    // Отсекаем за пределами формы
    if (d > 0.5) {
        discard;
    }
    
    var color: vec4<f32>;
    
    // ========== SELECTED SLOT ==========
    if (in.is_selected == 1u) {
        // Яркий фон для выбранного слота
        color = vec4<f32>(ACCENT * 0.15, 0.15);
        
        // Яркая рамка
        if (d > -2.5) {
            let border_alpha = 1.0 - (-d / 2.5);
            color = mix(color, vec4<f32>(ACCENT, 0.8), border_alpha);
        }
        
        // Внутреннее свечение
        let inner_glow = glow(d, 0.2, 0.05);
        color.r += ACCENT.r * inner_glow * 0.3;
        color.g += ACCENT.g * inner_glow * 0.3;
        color.b += ACCENT.b * inner_glow * 0.3;
        
        // Внешнее свечение (glow)
        let outer_glow = glow(d + 5.0, 0.6, 0.1);
        color.r += ACCENT.r * outer_glow * 0.2;
        color.g += ACCENT.g * outer_glow * 0.2;
        color.b += ACCENT.b * outer_glow * 0.2;
        
        // Пульсация
        let pulse = sin(time * 3.0) * 0.1 + 0.9;
        color.r *= pulse;
        color.g *= pulse;
        color.b *= pulse;
        
    } else {
        // ========== NORMAL SLOT ==========
        color = SLOT_BG;
        
        // Тонкая рамка
        if (d > -1.5) {
            let border_alpha = 1.0 - (-d / 1.5);
            color = mix(color, vec4<f32>(BORDER_COLOR * 0.3, 0.3), border_alpha);
        }
    }
    
    // ========== ITEM RENDERING - 3D ISOMETRIC CUBE WITH TEXTURE ==========
    if (in.has_item == 1u) {
        let center = in.size * 0.5;
        
        // Локальные координаты относительно центра
        let p = px - center;
        
        let top_col = in.top_color.rgb;
        let side_col = in.side_color.rgb;
        
        // Размеры куба
        let cube_w = min(w, h) * 0.30;
        let cube_h = cube_w * 0.5;
        let cube_d = cube_w * 1.1;  // Высота боковых граней
        
        // Центрирование: куб идёт от -cube_h (верх ромба) до cube_h + cube_d (низ)
        // Общая высота = cube_h + cube_h + cube_d = 2*cube_h + cube_d
        // Центр должен быть на 0, значит смещаем на половину высоты минус cube_h
        let total_h = cube_h + cube_d;
        let offset_y = -total_h * 0.5 + cube_h * 0.5;
        let p_off = vec2<f32>(p.x, p.y - offset_y);
        
        var drawn = false;
        
        // === ВЕРХНЯЯ ГРАНЬ (ромб) ===
        let rhombus_check = abs(p_off.x) / cube_w + abs(p_off.y) / cube_h;
        
        if (rhombus_check < 1.0 && p_off.y < cube_h) {
            // UV координаты для верхней грани
            let uv = vec2<f32>(
                (p_off.x / cube_w + 1.0) * 0.5,
                (p_off.y / cube_h + 1.0) * 0.5
            );
            
            // Текстурные детали
            var tex_var = block_texture(uv, top_col, in.slot_index);
            
            // Обводка по краям ромба
            let edge_dist = 1.0 - rhombus_check;
            if (edge_dist < 0.15) {
                tex_var -= 0.12 * (1.0 - edge_dist / 0.15);
            }
            
            let lit_top = top_col * (1.1 + tex_var);
            color = vec4<f32>(min(lit_top, vec3<f32>(1.0)), 1.0);
            drawn = true;
        }
        
        // === ЛЕВАЯ ГРАНЬ ===
        if (p_off.x <= 0.0 && !drawn) {
            let t = -p_off.x / cube_w;
            let y_top_line = cube_h * (1.0 - t);
            let y_bottom_line = cube_h + cube_d - cube_h * t;
            
            if (p_off.y >= y_top_line && p_off.y <= y_bottom_line && p_off.x >= -cube_w) {
                // UV для левой грани
                let uv = vec2<f32>(
                    t,
                    (p_off.y - y_top_line) / (y_bottom_line - y_top_line)
                );
                
                var tex_var = block_texture(uv, side_col, in.slot_index + 10u);
                
                // Обводка
                let edge_x = min(t, 1.0 - t);
                let edge_y = min(uv.y, 1.0 - uv.y);
                let edge = min(edge_x, edge_y);
                if (edge < 0.1) {
                    tex_var -= 0.1 * (1.0 - edge / 0.1);
                }
                
                let left_col = side_col * (0.8 + tex_var);
                color = vec4<f32>(left_col, 1.0);
                drawn = true;
            }
        }
        
        // === ПРАВАЯ ГРАНЬ ===
        if (p_off.x >= 0.0 && !drawn) {
            let t = p_off.x / cube_w;
            let y_top_line = cube_h * (1.0 - t);
            let y_bottom_line = cube_h + cube_d - cube_h * t;
            
            if (p_off.y >= y_top_line && p_off.y <= y_bottom_line && p_off.x <= cube_w) {
                // UV для правой грани
                let uv = vec2<f32>(
                    t,
                    (p_off.y - y_top_line) / (y_bottom_line - y_top_line)
                );
                
                var tex_var = block_texture(uv, side_col, in.slot_index + 20u);
                
                // Обводка
                let edge_x = min(t, 1.0 - t);
                let edge_y = min(uv.y, 1.0 - uv.y);
                let edge = min(edge_x, edge_y);
                if (edge < 0.1) {
                    tex_var -= 0.1 * (1.0 - edge / 0.1);
                }
                
                let right_col = side_col * (0.55 + tex_var);
                color = vec4<f32>(right_col, 1.0);
                drawn = true;
            }
        }
    }
    
    // ========== KEY BIND NUMBER ==========
    // Рисуем цифру в левом верхнем углу
    let key_num = in.slot_index + 1u;
    let digit_pos = vec2<f32>(8.0, 8.0);
    let digit_size = 10.0;
    
    // Простое отображение цифры через SDF (упрощённо - точка)
    let digit_center = digit_pos + vec2<f32>(digit_size * 0.5, digit_size * 0.5);
    let digit_dist = length(px - digit_center);
    
    // Подсветка области цифры (текст будет рендериться отдельно)
    if (digit_dist < digit_size) {
        let digit_alpha = 0.1 * (1.0 - digit_dist / digit_size);
        color = mix(color, vec4<f32>(ACCENT, 0.3), digit_alpha);
    }
    
    return color;
}


============================================================
FILE: gui\hotbar\mod.rs
============================================================

// ============================================
// Hotbar - Hi-Tech style inventory bar
// Glassmorphism + Neon cyan accents
// ============================================

mod render;

pub use render::{HotbarRenderer, HotbarSlot};

use crate::gpu::blocks::{BlockType, get_face_colors, AIR, STONE, DIRT, GRASS, OAK_PLANKS, COBBLESTONE, WATER};

/// Количество слотов в хотбаре
pub const HOTBAR_SLOTS: usize = 9;

/// Размер одного слота в пикселях
pub const SLOT_SIZE: f32 = 64.0;

/// Отступ между слотами
pub const SLOT_GAP: f32 = 10.0;

/// Отступ от низа экрана
pub const BOTTOM_PADDING: f32 = 40.0;

/// Состояние хотбара
pub struct Hotbar {
    /// Слоты с предметами (None = пустой слот)
    slots: [Option<HotbarItem>; HOTBAR_SLOTS],
    /// Индекс выбранного слота (0-8)
    selected: usize,
    /// Видимость хотбара
    visible: bool,
}

/// Предмет в слоте хотбара
#[derive(Clone, Debug)]
pub struct HotbarItem {
    /// Тип блока
    pub block_type: BlockType,
    /// Количество (для стакающихся предметов)
    pub count: u32,
    /// Цвет верхней грани (RGB)
    pub top_color: [f32; 3],
    /// Цвет боковых граней (RGB)
    pub side_color: [f32; 3],
}

impl HotbarItem {
    /// Создать предмет из типа блока
    pub fn from_block(block_type: BlockType) -> Self {
        let (top, side) = get_face_colors(block_type);
        Self {
            block_type,
            count: 1,
            top_color: top,
            side_color: side,
        }
    }
}

impl Default for Hotbar {
    fn default() -> Self {
        Self::new()
    }
}

impl Hotbar {
    pub fn new() -> Self {
        // Создаём хотбар с несколькими стартовыми блоками
        let mut slots: [Option<HotbarItem>; HOTBAR_SLOTS] = Default::default();
        
        // Стартовые блоки
        slots[0] = Some(HotbarItem::from_block(STONE));
        slots[1] = Some(HotbarItem::from_block(DIRT));
        slots[2] = Some(HotbarItem::from_block(GRASS));
        slots[3] = Some(HotbarItem::from_block(OAK_PLANKS));
        slots[4] = Some(HotbarItem::from_block(COBBLESTONE));
        slots[5] = Some(HotbarItem::from_block(WATER));
        
        Self {
            slots,
            selected: 0,
            visible: true,
        }
    }
    
    /// Выбрать слот по индексу (0-8)
    pub fn select(&mut self, index: usize) {
        if index < HOTBAR_SLOTS {
            self.selected = index;
        }
    }
    
    /// Выбрать слот по клавише (1-9)
    pub fn select_by_key(&mut self, key: u32) {
        if key >= 1 && key <= 9 {
            self.selected = (key - 1) as usize;
        }
    }
    
    /// Получить индекс выбранного слота
    pub fn selected(&self) -> usize {
        self.selected
    }
    
    /// Получить предмет в выбранном слоте
    pub fn selected_item(&self) -> Option<&HotbarItem> {
        self.slots[self.selected].as_ref()
    }
    
    /// Получить тип блока в выбранном слоте (для установки)
    pub fn selected_block_type(&self) -> Option<BlockType> {
        self.slots[self.selected].as_ref().map(|item| item.block_type)
    }
    
    /// Получить предмет в слоте по индексу
    pub fn get_item(&self, index: usize) -> Option<&HotbarItem> {
        self.slots.get(index).and_then(|s| s.as_ref())
    }
    
    /// Установить предмет в слот
    pub fn set_item(&mut self, index: usize, item: Option<HotbarItem>) {
        if index < HOTBAR_SLOTS {
            self.slots[index] = item;
        }
    }
    
    /// Pick block - взять блок и добавить в хотбар
    /// Возвращает true если блок был добавлен
    pub fn pick_block(&mut self, block_type: BlockType) -> bool {
        // Не добавляем воздух
        if block_type == AIR {
            return false;
        }
        
        // Сначала ищем этот блок в хотбаре
        for (i, slot) in self.slots.iter().enumerate() {
            if let Some(item) = slot {
                if item.block_type == block_type {
                    // Блок уже есть - просто выбираем этот слот
                    self.selected = i;
                    return true;
                }
            }
        }
        
        // Блока нет - ищем пустой слот
        for (i, slot) in self.slots.iter_mut().enumerate() {
            if slot.is_none() {
                *slot = Some(HotbarItem::from_block(block_type));
                self.selected = i;
                return true;
            }
        }
        
        // Нет пустых слотов - заменяем текущий выбранный
        self.slots[self.selected] = Some(HotbarItem::from_block(block_type));
        true
    }
    
    /// Получить все слоты
    pub fn slots(&self) -> &[Option<HotbarItem>; HOTBAR_SLOTS] {
        &self.slots
    }
    
    /// Показать/скрыть хотбар
    pub fn set_visible(&mut self, visible: bool) {
        self.visible = visible;
    }
    
    /// Проверить видимость
    pub fn is_visible(&self) -> bool {
        self.visible
    }
    
    /// Обработка клика мыши (возвращает true если клик был по хотбару)
    pub fn handle_click(&mut self, mx: f32, my: f32, screen_width: f32, screen_height: f32) -> bool {
        if !self.visible {
            return false;
        }
        
        let hotbar_width = HOTBAR_SLOTS as f32 * SLOT_SIZE + (HOTBAR_SLOTS - 1) as f32 * SLOT_GAP;
        let hotbar_x = (screen_width - hotbar_width) / 2.0;
        let hotbar_y = screen_height - BOTTOM_PADDING - SLOT_SIZE;
        
        // Проверяем попадание в область хотбара
        if my >= hotbar_y && my <= hotbar_y + SLOT_SIZE {
            for i in 0..HOTBAR_SLOTS {
                let slot_x = hotbar_x + i as f32 * (SLOT_SIZE + SLOT_GAP);
                if mx >= slot_x && mx <= slot_x + SLOT_SIZE {
                    self.selected = i;
                    return true;
                }
            }
        }
        
        false
    }
    
    /// Прокрутка колёсиком мыши
    pub fn scroll(&mut self, delta: i32) {
        if delta > 0 {
            self.selected = (self.selected + 1) % HOTBAR_SLOTS;
        } else if delta < 0 {
            self.selected = (self.selected + HOTBAR_SLOTS - 1) % HOTBAR_SLOTS;
        }
    }
}


============================================================
FILE: gui\hotbar\render.rs
============================================================

// ============================================
// Hotbar GPU Renderer - Hi-Tech glassmorphism style
// ============================================

use bytemuck::{Pod, Zeroable};
use wgpu::util::DeviceExt;
use std::time::Instant;

use super::{Hotbar, HotbarItem, HOTBAR_SLOTS, SLOT_SIZE, SLOT_GAP, BOTTOM_PADDING};

/// Uniforms для шейдера хотбара
#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct HotbarUniforms {
    pub screen_size: [f32; 2],
    pub time: f32,
    pub selected_slot: f32,
}

/// Данные одного слота для GPU
#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct HotbarSlot {
    pub pos: [f32; 2],         // Позиция слота
    pub size: [f32; 2],        // Размер слота
    pub slot_index: u32,       // Индекс слота (0-8)
    pub is_selected: u32,      // 1 если выбран, 0 иначе
    pub has_item: u32,         // 1 если есть предмет
    pub _padding: u32,
    pub top_color: [f32; 4],   // Цвет верхней грани (RGBA)
    pub side_color: [f32; 4],  // Цвет боковых граней (RGBA)
}

/// GPU рендерер хотбара
pub struct HotbarRenderer {
    // GPU ресурсы
    pipeline: wgpu::RenderPipeline,
    vertex_buffer: wgpu::Buffer,
    instance_buffer: wgpu::Buffer,
    uniform_buffer: wgpu::Buffer,
    bind_group: wgpu::BindGroup,
    
    // Состояние
    screen_width: f32,
    screen_height: f32,
    start_time: Instant,
}

impl HotbarRenderer {
    pub fn new(
        device: &wgpu::Device,
        format: wgpu::TextureFormat,
        width: u32,
        height: u32,
    ) -> Self {
        // Bind group layout
        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Hotbar Bind Group Layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });
        
        // Uniform buffer
        let uniforms = HotbarUniforms {
            screen_size: [width as f32, height as f32],
            time: 0.0,
            selected_slot: 0.0,
        };
        
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Hotbar Uniform Buffer"),
            contents: bytemuck::cast_slice(&[uniforms]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });
        
        // Bind group
        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Hotbar Bind Group"),
            layout: &bind_group_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: uniform_buffer.as_entire_binding(),
            }],
        });
        
        // Vertex buffer (квадрат из 2 треугольников)
        let vertices: Vec<[f32; 2]> = vec![
            [0.0, 0.0], [1.0, 0.0], [1.0, 1.0],
            [0.0, 0.0], [1.0, 1.0], [0.0, 1.0],
        ];
        
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Hotbar Vertex Buffer"),
            contents: bytemuck::cast_slice(&vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });
        
        // Instance buffer (для всех слотов + фон)
        let instance_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("Hotbar Instance Buffer"),
            size: (std::mem::size_of::<HotbarSlot>() * (HOTBAR_SLOTS + 1)) as u64,
            usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
            mapped_at_creation: false,
        });
        
        // Shader
        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Hotbar Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("hotbar.wgsl").into()),
        });
        
        // Pipeline layout
        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Hotbar Pipeline Layout"),
            bind_group_layouts: &[&bind_group_layout],
            push_constant_ranges: &[],
        });
        
        // Render pipeline
        let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Hotbar Pipeline"),
            layout: Some(&pipeline_layout),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: Some("vs_main"),
                buffers: &[
                    // Vertex buffer
                    wgpu::VertexBufferLayout {
                        array_stride: 8,
                        step_mode: wgpu::VertexStepMode::Vertex,
                        attributes: &[wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x2,
                            offset: 0,
                            shader_location: 0,
                        }],
                    },
                    // Instance buffer
                    wgpu::VertexBufferLayout {
                        array_stride: std::mem::size_of::<HotbarSlot>() as u64,
                        step_mode: wgpu::VertexStepMode::Instance,
                        attributes: &[
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Float32x2,
                                offset: 0,
                                shader_location: 1, // pos
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Float32x2,
                                offset: 8,
                                shader_location: 2, // size
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Uint32,
                                offset: 16,
                                shader_location: 3, // slot_index
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Uint32,
                                offset: 20,
                                shader_location: 4, // is_selected
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Uint32,
                                offset: 24,
                                shader_location: 5, // has_item
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Float32x4,
                                offset: 32,
                                shader_location: 6, // top_color
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Float32x4,
                                offset: 48,
                                shader_location: 7, // side_color
                            },
                        ],
                    },
                ],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format,
                    blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState::default(),
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
            cache: None,
        });
        
        Self {
            pipeline,
            vertex_buffer,
            instance_buffer,
            uniform_buffer,
            bind_group,
            screen_width: width as f32,
            screen_height: height as f32,
            start_time: Instant::now(),
        }
    }
    
    pub fn resize(&mut self, width: u32, height: u32) {
        self.screen_width = width as f32;
        self.screen_height = height as f32;
    }
    
    pub fn render<'a>(
        &'a self,
        render_pass: &mut wgpu::RenderPass<'a>,
        queue: &wgpu::Queue,
        hotbar: &Hotbar,
    ) {
        if !hotbar.is_visible() {
            return;
        }
        
        let time = self.start_time.elapsed().as_secs_f32();
        
        // Обновляем uniforms
        let uniforms = HotbarUniforms {
            screen_size: [self.screen_width, self.screen_height],
            time,
            selected_slot: hotbar.selected() as f32,
        };
        queue.write_buffer(&self.uniform_buffer, 0, bytemuck::cast_slice(&[uniforms]));
        
        // Вычисляем позиции слотов
        let hotbar_width = HOTBAR_SLOTS as f32 * SLOT_SIZE + (HOTBAR_SLOTS - 1) as f32 * SLOT_GAP;
        let hotbar_x = (self.screen_width - hotbar_width) / 2.0;
        let hotbar_y = self.screen_height - BOTTOM_PADDING - SLOT_SIZE;
        
        let mut instances: Vec<HotbarSlot> = Vec::with_capacity(HOTBAR_SLOTS + 1);
        
        // Фон хотбара (первый instance с slot_index = 99)
        let bg_padding = 10.0;
        instances.push(HotbarSlot {
            pos: [hotbar_x - bg_padding, hotbar_y - bg_padding],
            size: [hotbar_width + bg_padding * 2.0, SLOT_SIZE + bg_padding * 2.0],
            slot_index: 99, // Специальный индекс для фона
            is_selected: 0,
            has_item: 0,
            _padding: 0,
            top_color: [0.0, 0.0, 0.0, 0.0],
            side_color: [0.0, 0.0, 0.0, 0.0],
        });
        
        // Слоты
        for i in 0..HOTBAR_SLOTS {
            let slot_x = hotbar_x + i as f32 * (SLOT_SIZE + SLOT_GAP);
            let item = hotbar.get_item(i);
            
            let (top_color, side_color) = if let Some(it) = item {
                ([it.top_color[0], it.top_color[1], it.top_color[2], 1.0],
                 [it.side_color[0], it.side_color[1], it.side_color[2], 1.0])
            } else {
                ([0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0])
            };
            
            instances.push(HotbarSlot {
                pos: [slot_x, hotbar_y],
                size: [SLOT_SIZE, SLOT_SIZE],
                slot_index: i as u32,
                is_selected: if i == hotbar.selected() { 1 } else { 0 },
                has_item: if item.is_some() { 1 } else { 0 },
                _padding: 0,
                top_color,
                side_color,
            });
        }
        
        queue.write_buffer(&self.instance_buffer, 0, bytemuck::cast_slice(&instances));
        
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_bind_group(0, &self.bind_group, &[]);
        render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        render_pass.set_vertex_buffer(1, self.instance_buffer.slice(..));
        render_pass.draw(0..6, 0..instances.len() as u32);
    }
}


============================================================
FILE: gui\inventory\inventory.wgsl
============================================================

// ============================================
// Inventory Shader - Hi-Tech glassmorphism style
// Cyan neon accents + scrollable grid
// ============================================

struct InventoryUniforms {
    screen_size: vec2<f32>,
    time: f32,
    scroll: f32,
    panel_pos: vec2<f32>,
    panel_size: vec2<f32>,
}

@group(0) @binding(0) var<uniform> uniforms: InventoryUniforms;

struct VertexInput {
    @location(0) position: vec2<f32>,
}

struct InstanceInput {
    @location(1) pos: vec2<f32>,
    @location(2) size: vec2<f32>,
    @location(3) slot_type: u32,
    @location(4) is_hovered: u32,
    @location(5) has_item: u32,
    @location(6) top_color: vec4<f32>,
    @location(7) side_color: vec4<f32>,
}

struct VertexOutput {
    @builtin(position) clip_pos: vec4<f32>,
    @location(0) uv: vec2<f32>,
    @location(1) @interpolate(flat) size: vec2<f32>,
    @location(2) @interpolate(flat) slot_type: u32,
    @location(3) @interpolate(flat) is_hovered: u32,
    @location(4) @interpolate(flat) has_item: u32,
    @location(5) @interpolate(flat) top_color: vec4<f32>,
    @location(6) @interpolate(flat) side_color: vec4<f32>,
    @location(7) world_pos: vec2<f32>,
}

// Цветовая палитра Hi-Tech
const ACCENT: vec3<f32> = vec3<f32>(0.0, 0.953, 1.0);
const BG_DARK: vec4<f32> = vec4<f32>(0.02, 0.05, 0.08, 0.95);
const SLOT_BG: vec4<f32> = vec4<f32>(0.0, 0.078, 0.118, 0.7);
const BORDER_COLOR: vec3<f32> = vec3<f32>(0.0, 0.8, 1.0);

@vertex
fn vs_main(in: VertexInput, inst: InstanceInput) -> VertexOutput {
    var out: VertexOutput;
    
    let pixel_pos = inst.pos + in.position * inst.size;
    let ndc_x = (pixel_pos.x / uniforms.screen_size.x) * 2.0 - 1.0;
    let ndc_y = (1.0 - pixel_pos.y / uniforms.screen_size.y) * 2.0 - 1.0;
    
    out.clip_pos = vec4<f32>(ndc_x, ndc_y, 0.0, 1.0);
    out.uv = in.position;
    out.size = inst.size;
    out.slot_type = inst.slot_type;
    out.is_hovered = inst.is_hovered;
    out.has_item = inst.has_item;
    out.top_color = inst.top_color;
    out.side_color = inst.side_color;
    out.world_pos = pixel_pos;
    
    return out;
}

fn sdf_rounded_rect(p: vec2<f32>, size: vec2<f32>, radius: f32) -> f32 {
    let q = abs(p - size * 0.5) - size * 0.5 + vec2<f32>(radius);
    return length(max(q, vec2<f32>(0.0))) + min(max(q.x, q.y), 0.0) - radius;
}

fn sdf_clipped_rect(p: vec2<f32>, size: vec2<f32>, clip_size: f32) -> f32 {
    let rect_d = sdf_rounded_rect(p, size, 0.0);
    let corner = vec2<f32>(size.x - clip_size, size.y);
    let to_corner = p - corner;
    let clip_d = to_corner.x + to_corner.y - clip_size;
    return max(rect_d, clip_d);
}

fn hash(p: vec2<f32>) -> f32 {
    return fract(sin(dot(p, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

fn block_texture(uv: vec2<f32>, seed: u32) -> f32 {
    var variation = 0.0;
    let pixel_size = 0.125;
    let pixel_uv = floor(uv / pixel_size);
    let pixel_seed = pixel_uv + vec2<f32>(f32(seed) * 7.3, f32(seed) * 3.7);
    let noise_val = hash(pixel_seed * 0.17);
    
    if (noise_val > 0.82) {
        variation = 0.08;
    } else if (noise_val < 0.18) {
        variation = -0.06;
    }
    
    let fine_noise = hash(uv * 23.0 + vec2<f32>(f32(seed))) * 0.04 - 0.02;
    variation += fine_noise;
    
    return variation;
}

fn glow(d: f32, intensity: f32, spread: f32) -> f32 {
    return intensity / (1.0 + abs(d) * spread);
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    let px = in.uv * in.size;
    let w = in.size.x;
    let h = in.size.y;
    let time = uniforms.time;
    
    // ========== OVERLAY (slot_type == 0) ==========
    if (in.slot_type == 0u) {
        return vec4<f32>(0.0, 0.0, 0.0, 0.7);
    }
    
    // ========== PANEL (slot_type == 1) ==========
    if (in.slot_type == 1u) {
        let radius = 12.0;
        let d = sdf_rounded_rect(px, in.size, radius);
        
        if (d > 0.5) {
            discard;
        }
        
        var color = BG_DARK;
        
        // Рамка
        if (d > -2.0) {
            let border_alpha = 1.0 - (-d / 2.0);
            color = mix(color, vec4<f32>(BORDER_COLOR * 0.4, 0.6), border_alpha);
        }
        
        // Градиент сверху
        let top_gradient = 1.0 - px.y / h;
        let accent_add = ACCENT * top_gradient * 0.02;
        color = vec4<f32>(color.rgb + accent_add, color.a);
        
        return color;
    }
    
    // ========== HEADER (slot_type == 5) ==========
    if (in.slot_type == 5u) {
        let radius = 12.0;
        let d = sdf_rounded_rect(px, vec2<f32>(w, h + radius), radius);
        
        if (d > 0.5 || px.y > h) {
            discard;
        }
        
        var color = vec4<f32>(0.0, 0.06, 0.1, 0.9);
        
        // Нижняя граница заголовка
        if (px.y > h - 2.0) {
            let line_alpha = (px.y - (h - 2.0)) / 2.0;
            color = mix(color, vec4<f32>(ACCENT, 0.8), line_alpha);
        }
        
        // Декоративная полоска сверху
        let center_x = w * 0.5;
        let stripe_width = w * 0.4;
        let dist_from_center = abs(px.x - center_x);
        if (px.y < 3.0 && dist_from_center < stripe_width * 0.5) {
            let stripe_alpha = 1.0 - dist_from_center / (stripe_width * 0.5);
            let stripe_y_alpha = 1.0 - px.y / 3.0;
            color = mix(color, vec4<f32>(ACCENT, 0.9), stripe_alpha * stripe_y_alpha * 0.8);
        }
        
        return color;
    }
    
    // ========== SCROLLBAR TRACK (slot_type == 3) ==========
    if (in.slot_type == 3u) {
        let radius = 6.0;
        let d = sdf_rounded_rect(px, in.size, radius);
        
        if (d > 0.5) {
            discard;
        }
        
        return vec4<f32>(0.0, 0.04, 0.06, 0.5);
    }
    
    // ========== SCROLLBAR THUMB (slot_type == 4) ==========
    if (in.slot_type == 4u) {
        let radius = 5.0;
        let d = sdf_rounded_rect(px, in.size, radius);
        
        if (d > 0.5) {
            discard;
        }
        
        var color = vec4<f32>(ACCENT * 0.6, 0.8);
        
        // Свечение
        if (d > -2.0) {
            let border_alpha = 1.0 - (-d / 2.0);
            color = mix(color, vec4<f32>(ACCENT, 1.0), border_alpha * 0.5);
        }
        
        return color;
    }
    
    // ========== SLOT (slot_type == 2) или DRAGGING (slot_type == 6) ==========
    let is_dragging = in.slot_type == 6u;
    let clip_size = h * 0.12;
    let d = sdf_clipped_rect(px, in.size, clip_size);
    
    if (d > 0.5) {
        discard;
    }
    
    var color: vec4<f32>;
    
    if (in.is_hovered == 1u || is_dragging) {
        // Подсвеченный слот
        color = vec4<f32>(ACCENT * 0.2, 0.3);
        
        if (d > -2.5) {
            let border_alpha = 1.0 - (-d / 2.5);
            color = mix(color, vec4<f32>(ACCENT, 0.9), border_alpha);
        }
        
        let inner_glow = glow(d, 0.3, 0.04);
        color = vec4<f32>(color.rgb + ACCENT * inner_glow * 0.4, color.a);
        
        let pulse = sin(time * 4.0) * 0.1 + 0.95;
        color = vec4<f32>(color.rgb * pulse, color.a);
    } else {
        // Обычный слот
        color = SLOT_BG;
        
        if (d > -1.5) {
            let border_alpha = 1.0 - (-d / 1.5);
            color = mix(color, vec4<f32>(BORDER_COLOR * 0.3, 0.4), border_alpha);
        }
    }
    
    // ========== ITEM RENDERING - 3D ISOMETRIC CUBE ==========
    if (in.has_item == 1u) {
        let center = in.size * 0.5;
        let p = px - center;
        
        let top_col = in.top_color.rgb;
        let side_col = in.side_color.rgb;
        
        let cube_w = min(w, h) * 0.32;
        let cube_h = cube_w * 0.5;
        let cube_d = cube_w * 1.1;
        
        let total_h = cube_h + cube_d;
        let offset_y = -total_h * 0.5 + cube_h * 0.5;
        let p_off = vec2<f32>(p.x, p.y - offset_y);
        
        var drawn = false;
        
        // Верхняя грань (ромб)
        let rhombus_check = abs(p_off.x) / cube_w + abs(p_off.y) / cube_h;
        
        if (rhombus_check < 1.0 && p_off.y < cube_h) {
            let uv = vec2<f32>(
                (p_off.x / cube_w + 1.0) * 0.5,
                (p_off.y / cube_h + 1.0) * 0.5
            );
            
            var tex_var = block_texture(uv, u32(in.world_pos.x * 0.1));
            
            let edge_dist = 1.0 - rhombus_check;
            if (edge_dist < 0.15) {
                tex_var -= 0.12 * (1.0 - edge_dist / 0.15);
            }
            
            let lit_top = top_col * (1.1 + tex_var);
            color = vec4<f32>(min(lit_top, vec3<f32>(1.0)), 1.0);
            drawn = true;
        }
        
        // Левая грань
        if (p_off.x <= 0.0 && !drawn) {
            let t = -p_off.x / cube_w;
            let y_top_line = cube_h * (1.0 - t);
            let y_bottom_line = cube_h + cube_d - cube_h * t;
            
            if (p_off.y >= y_top_line && p_off.y <= y_bottom_line && p_off.x >= -cube_w) {
                let uv = vec2<f32>(
                    t,
                    (p_off.y - y_top_line) / (y_bottom_line - y_top_line)
                );
                
                var tex_var = block_texture(uv, u32(in.world_pos.x * 0.1) + 10u);
                
                let edge_x = min(t, 1.0 - t);
                let edge_y = min(uv.y, 1.0 - uv.y);
                let edge = min(edge_x, edge_y);
                if (edge < 0.1) {
                    tex_var -= 0.1 * (1.0 - edge / 0.1);
                }
                
                let left_col = side_col * (0.8 + tex_var);
                color = vec4<f32>(left_col, 1.0);
                drawn = true;
            }
        }
        
        // Правая грань
        if (p_off.x >= 0.0 && !drawn) {
            let t = p_off.x / cube_w;
            let y_top_line = cube_h * (1.0 - t);
            let y_bottom_line = cube_h + cube_d - cube_h * t;
            
            if (p_off.y >= y_top_line && p_off.y <= y_bottom_line && p_off.x <= cube_w) {
                let uv = vec2<f32>(
                    t,
                    (p_off.y - y_top_line) / (y_bottom_line - y_top_line)
                );
                
                var tex_var = block_texture(uv, u32(in.world_pos.x * 0.1) + 20u);
                
                let edge_x = min(t, 1.0 - t);
                let edge_y = min(uv.y, 1.0 - uv.y);
                let edge = min(edge_x, edge_y);
                if (edge < 0.1) {
                    tex_var -= 0.1 * (1.0 - edge / 0.1);
                }
                
                let right_col = side_col * (0.55 + tex_var);
                color = vec4<f32>(right_col, 1.0);
                drawn = true;
            }
        }
    }
    
    return color;
}


============================================================
FILE: gui\inventory\mod.rs
============================================================

// ============================================
// Inventory - Full-screen block inventory
// Hi-Tech glassmorphism style with scrollbar
// Press E to toggle
// ============================================

mod render;

pub use render::InventoryRenderer;

use crate::gpu::blocks::{
    BlockType, global_registry, BlockCategory as DataBlockCategory,
    get_face_colors, get_block_name, AIR,
    STONE, DIRT, GRASS, SAND, GRAVEL,
    COBBLESTONE, MOSSY_COBBLESTONE, GRANITE, DIORITE, ANDESITE, DEEPSLATE,
    COAL_ORE, IRON_ORE, GOLD_ORE, DIAMOND_ORE, EMERALD_ORE, REDSTONE_ORE, LAPIS_ORE, COPPER_ORE,
    OAK_LOG, OAK_PLANKS, OAK_LEAVES, BIRCH_LOG, BIRCH_PLANKS, BIRCH_LEAVES,
    SPRUCE_LOG, SPRUCE_PLANKS, SPRUCE_LEAVES,
    WATER, LAVA, ICE, SNOW, CLAY,
    BRICKS, STONE_BRICKS, OBSIDIAN, GLASS,
    IRON_BLOCK, GOLD_BLOCK, DIAMOND_BLOCK, EMERALD_BLOCK, COPPER_BLOCK,
    CUSTOM_100, CUSTOM_101, CUSTOM_102, CUSTOM_103, CUSTOM_104,
};

/// Количество колонок в инвентаре
pub const INVENTORY_COLS: usize = 8;

/// Размер одного слота в пикселях
pub const INV_SLOT_SIZE: f32 = 72.0;

/// Отступ между слотами
pub const INV_SLOT_GAP: f32 = 8.0;

/// Отступ от краёв панели
pub const INV_PADDING: f32 = 20.0;

/// Высота заголовка
pub const HEADER_HEIGHT: f32 = 50.0;

/// Ширина скроллбара
pub const SCROLLBAR_WIDTH: f32 = 12.0;

/// Категория блоков
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BlockCategory {
    All,
    Basic,
    Stone,
    Ores,
    Wood,
    Nature,
    Building,
    Metal,
}

impl BlockCategory {
    pub fn name(&self) -> &'static str {
        match self {
            BlockCategory::All => "All Blocks",
            BlockCategory::Basic => "Basic",
            BlockCategory::Stone => "Stone",
            BlockCategory::Ores => "Ores",
            BlockCategory::Wood => "Wood",
            BlockCategory::Nature => "Nature",
            BlockCategory::Building => "Building",
            BlockCategory::Metal => "Metal",
        }
    }
}

/// Предмет в инвентаре
#[derive(Clone, Debug)]
pub struct InventoryItem {
    pub block_type: BlockType,
    pub name: &'static str,
    pub top_color: [f32; 3],
    pub side_color: [f32; 3],
    pub category: BlockCategory,
}

impl InventoryItem {
    pub fn from_block(block_type: BlockType) -> Self {
        let name = get_block_name(block_type);
        let (top, side) = get_face_colors(block_type);
        let category = Self::categorize(block_type);
        
        Self {
            block_type,
            name: Box::leak(name.into_boxed_str()),
            top_color: top,
            side_color: side,
            category,
        }
    }
    
    fn categorize(block_type: BlockType) -> BlockCategory {
        // Сначала пробуем получить категорию из реестра
        if let Ok(registry) = global_registry().read() {
            if let Some(def) = registry.get_by_numeric(block_type) {
                return match def.category {
                    DataBlockCategory::Basic => BlockCategory::Basic,
                    DataBlockCategory::Stone => BlockCategory::Stone,
                    DataBlockCategory::Ore => BlockCategory::Ores,
                    DataBlockCategory::Wood => BlockCategory::Wood,
                    DataBlockCategory::Nature => BlockCategory::Nature,
                    DataBlockCategory::Building => BlockCategory::Building,
                    DataBlockCategory::Metal => BlockCategory::Metal,
                };
            }
        }
        
        // Fallback для встроенных блоков
        match block_type {
            STONE | DIRT | GRASS | SAND | GRAVEL => BlockCategory::Basic,
            
            COBBLESTONE | MOSSY_COBBLESTONE | GRANITE | DIORITE | ANDESITE | DEEPSLATE => BlockCategory::Stone,
            
            COAL_ORE | IRON_ORE | GOLD_ORE | DIAMOND_ORE | EMERALD_ORE | 
            REDSTONE_ORE | LAPIS_ORE | COPPER_ORE => BlockCategory::Ores,
            
            OAK_LOG | OAK_PLANKS | OAK_LEAVES | BIRCH_LOG | BIRCH_PLANKS | 
            BIRCH_LEAVES | SPRUCE_LOG | SPRUCE_PLANKS | SPRUCE_LEAVES => BlockCategory::Wood,
            
            WATER | LAVA | ICE | SNOW | CLAY => BlockCategory::Nature,
            
            BRICKS | STONE_BRICKS | OBSIDIAN | GLASS => BlockCategory::Building,
            
            IRON_BLOCK | GOLD_BLOCK | DIAMOND_BLOCK | EMERALD_BLOCK | COPPER_BLOCK => BlockCategory::Metal,
            
            _ => BlockCategory::Basic,
        }
    }
}

/// Состояние инвентаря
pub struct Inventory {
    /// Все доступные блоки
    items: Vec<InventoryItem>,
    /// Видимость инвентаря
    visible: bool,
    /// Текущая позиция скролла (0.0 - 1.0)
    scroll: f32,
    /// Максимальный скролл
    max_scroll: f32,
    /// Выбранный блок (для передачи в хотбар)
    selected_block: Option<BlockType>,
    /// Текущая категория
    category: BlockCategory,
    /// Индекс слота под курсором
    hovered_slot: Option<usize>,
    /// Перетаскиваемый блок (drag & drop)
    dragging_block: Option<BlockType>,
}

impl Default for Inventory {
    fn default() -> Self {
        Self::new()
    }
}

impl Inventory {
    pub fn new() -> Self {
        let items = Self::create_all_items();
        
        Self {
            items,
            visible: false,
            scroll: 0.0,
            max_scroll: 0.0,
            selected_block: None,
            category: BlockCategory::All,
            hovered_slot: None,
            dragging_block: None,
        }
    }
    
    fn create_all_items() -> Vec<InventoryItem> {
        let mut items = Vec::new();
        
        // Сначала добавляем блоки из глобального реестра (data-driven)
        if let Ok(registry) = global_registry().read() {
            for def in registry.all_blocks() {
                // Пропускаем Air
                if def.numeric_id == 0 {
                    continue;
                }
                
                // BlockType = u8, просто используем numeric_id
                let block_type: BlockType = def.numeric_id;
                let category = match def.category {
                    DataBlockCategory::Basic => BlockCategory::Basic,
                    DataBlockCategory::Stone => BlockCategory::Stone,
                    DataBlockCategory::Ore => BlockCategory::Ores,
                    DataBlockCategory::Wood => BlockCategory::Wood,
                    DataBlockCategory::Nature => BlockCategory::Nature,
                    DataBlockCategory::Building => BlockCategory::Building,
                    DataBlockCategory::Metal => BlockCategory::Metal,
                };
                
                items.push(InventoryItem {
                    block_type,
                    name: Box::leak(def.name.clone().into_boxed_str()),
                    top_color: def.color.top(),
                    side_color: def.color.side(),
                    category,
                });
            }
        }
        
        // Если реестр пуст, используем fallback со встроенными блоками
        if items.is_empty() {
            items = Self::create_builtin_items();
        }
        
        // Сортируем по numeric_id для консистентности
        items.sort_by_key(|i| i.block_type);
        
        items
    }
    
    /// Fallback: встроенные блоки (если реестр не загружен)
    fn create_builtin_items() -> Vec<InventoryItem> {
        let block_types: [BlockType; 47] = [
            // Basic
            STONE, DIRT, GRASS, SAND, GRAVEL,
            // Stone
            COBBLESTONE, MOSSY_COBBLESTONE, GRANITE, DIORITE, ANDESITE, DEEPSLATE,
            // Ores
            COAL_ORE, IRON_ORE, GOLD_ORE, DIAMOND_ORE, EMERALD_ORE, REDSTONE_ORE, LAPIS_ORE, COPPER_ORE,
            // Wood
            OAK_LOG, OAK_PLANKS, OAK_LEAVES, BIRCH_LOG, BIRCH_PLANKS, BIRCH_LEAVES,
            SPRUCE_LOG, SPRUCE_PLANKS, SPRUCE_LEAVES,
            // Nature
            WATER, LAVA, ICE, SNOW, CLAY,
            // Building
            BRICKS, STONE_BRICKS, OBSIDIAN, GLASS,
            // Metal blocks
            IRON_BLOCK, GOLD_BLOCK, DIAMOND_BLOCK, EMERALD_BLOCK, COPPER_BLOCK,
            // Custom blocks (from mods)
            CUSTOM_100, CUSTOM_101, CUSTOM_102, CUSTOM_103, CUSTOM_104,
        ];
        
        block_types.iter()
            .filter(|&&bt| bt != AIR)
            .map(|&bt| InventoryItem::from_block(bt))
            .collect()
    }
    
    /// Перезагрузить блоки из реестра (после загрузки модов)
    pub fn reload_from_registry(&mut self) {
        self.items = Self::create_all_items();
        self.scroll = 0.0;
    }
    
    /// Переключить видимость
    pub fn toggle(&mut self) {
        self.visible = !self.visible;
        if self.visible {
            self.selected_block = None;
            self.hovered_slot = None;
        }
    }
    
    /// Показать инвентарь
    pub fn show(&mut self) {
        self.visible = true;
        self.selected_block = None;
    }
    
    /// Скрыть инвентарь
    pub fn hide(&mut self) {
        self.visible = false;
    }
    
    /// Проверить видимость
    pub fn is_visible(&self) -> bool {
        self.visible
    }
    
    /// Получить отфильтрованные предметы
    pub fn filtered_items(&self) -> Vec<&InventoryItem> {
        if self.category == BlockCategory::All {
            self.items.iter().collect()
        } else {
            self.items.iter().filter(|i| i.category == self.category).collect()
        }
    }
    
    /// Получить все предметы
    pub fn items(&self) -> &[InventoryItem] {
        &self.items
    }
    
    /// Получить текущий скролл
    pub fn scroll(&self) -> f32 {
        self.scroll
    }
    
    /// Установить скролл
    pub fn set_scroll(&mut self, scroll: f32) {
        self.scroll = scroll.clamp(0.0, self.max_scroll);
    }
    
    /// Обновить максимальный скролл
    pub fn update_max_scroll(&mut self, visible_rows: usize, total_rows: usize) {
        if total_rows > visible_rows {
            self.max_scroll = (total_rows - visible_rows) as f32;
        } else {
            self.max_scroll = 0.0;
        }
        self.scroll = self.scroll.clamp(0.0, self.max_scroll);
    }
    
    /// Прокрутка колёсиком (delta > 0 = скролл вверх, delta < 0 = скролл вниз)
    pub fn scroll_by(&mut self, delta: f32) {
        // Крутим вверх (delta > 0) -> scroll уменьшается (контент вниз)
        // Крутим вниз (delta < 0) -> scroll увеличивается (контент вверх)
        self.scroll = (self.scroll - delta).clamp(0.0, self.max_scroll);
    }
    
    /// Получить выбранный блок и сбросить
    pub fn take_selected_block(&mut self) -> Option<BlockType> {
        self.selected_block.take()
    }
    
    /// Установить выбранный блок
    pub fn select_block(&mut self, block_type: BlockType) {
        self.selected_block = Some(block_type);
    }
    
    /// Получить текущую категорию
    pub fn category(&self) -> BlockCategory {
        self.category
    }
    
    /// Установить категорию
    pub fn set_category(&mut self, category: BlockCategory) {
        self.category = category;
        self.scroll = 0.0;
    }
    
    /// Установить hovered слот
    pub fn set_hovered(&mut self, slot: Option<usize>) {
        self.hovered_slot = slot;
    }
    
    /// Получить hovered слот
    pub fn hovered(&self) -> Option<usize> {
        self.hovered_slot
    }
    
    /// Обработка клика (начало drag)
    pub fn handle_click(&mut self, slot_index: usize) -> Option<BlockType> {
        let items = self.filtered_items();
        if slot_index < items.len() {
            let block_type = items[slot_index].block_type;
            // Начинаем перетаскивание
            self.dragging_block = Some(block_type);
            return Some(block_type);
        }
        None
    }
    
    /// Начать перетаскивание блока
    pub fn start_drag(&mut self, block_type: BlockType) {
        self.dragging_block = Some(block_type);
    }
    
    /// Получить перетаскиваемый блок
    pub fn dragging(&self) -> Option<BlockType> {
        self.dragging_block
    }
    
    /// Завершить перетаскивание (drop)
    pub fn end_drag(&mut self) -> Option<BlockType> {
        self.dragging_block.take()
    }
    
    /// Отменить перетаскивание
    pub fn cancel_drag(&mut self) {
        self.dragging_block = None;
    }
    
    /// Получить максимальный скролл
    pub fn max_scroll(&self) -> f32 {
        self.max_scroll
    }
}


============================================================
FILE: gui\inventory\render.rs
============================================================

// ============================================
// Inventory GPU Renderer - Hi-Tech glassmorphism
// ============================================

use bytemuck::{Pod, Zeroable};
use wgpu::util::DeviceExt;
use std::time::Instant;

use super::{
    Inventory,
    INVENTORY_COLS, INV_SLOT_SIZE, INV_SLOT_GAP, INV_PADDING,
    HEADER_HEIGHT, SCROLLBAR_WIDTH,
};
use crate::gpu::blocks::{BlockType, get_face_colors};

/// Uniforms для шейдера инвентаря
#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct InventoryUniforms {
    pub screen_size: [f32; 2],
    pub time: f32,
    pub scroll: f32,
    pub panel_pos: [f32; 2],
    pub panel_size: [f32; 2],
}

/// Данные одного слота для GPU
#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct InventorySlot {
    pub pos: [f32; 2],
    pub size: [f32; 2],
    pub slot_type: u32,      // 0=overlay, 1=panel, 2=slot, 3=scrollbar, 4=scrollthumb, 5=header
    pub is_hovered: u32,
    pub has_item: u32,
    pub _padding: u32,
    pub top_color: [f32; 4],
    pub side_color: [f32; 4],
}

/// GPU рендерер инвентаря
pub struct InventoryRenderer {
    pipeline: wgpu::RenderPipeline,
    vertex_buffer: wgpu::Buffer,
    instance_buffer: wgpu::Buffer,
    uniform_buffer: wgpu::Buffer,
    bind_group: wgpu::BindGroup,
    
    screen_width: f32,
    screen_height: f32,
    start_time: Instant,
    
    // Кэшированные размеры панели
    panel_x: f32,
    panel_y: f32,
    panel_width: f32,
    panel_height: f32,
    content_height: f32,
    visible_rows: usize,
}

impl InventoryRenderer {
    pub fn new(
        device: &wgpu::Device,
        format: wgpu::TextureFormat,
        width: u32,
        height: u32,
    ) -> Self {
        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Inventory Bind Group Layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });
        
        let uniforms = InventoryUniforms {
            screen_size: [width as f32, height as f32],
            time: 0.0,
            scroll: 0.0,
            panel_pos: [0.0, 0.0],
            panel_size: [0.0, 0.0],
        };
        
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Inventory Uniform Buffer"),
            contents: bytemuck::cast_slice(&[uniforms]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });
        
        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Inventory Bind Group"),
            layout: &bind_group_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: uniform_buffer.as_entire_binding(),
            }],
        });
        
        let vertices: Vec<[f32; 2]> = vec![
            [0.0, 0.0], [1.0, 0.0], [1.0, 1.0],
            [0.0, 0.0], [1.0, 1.0], [0.0, 1.0],
        ];
        
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Inventory Vertex Buffer"),
            contents: bytemuck::cast_slice(&vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });
        
        // Буфер для ~100 слотов + UI элементы
        let instance_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("Inventory Instance Buffer"),
            size: (std::mem::size_of::<InventorySlot>() * 120) as u64,
            usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
            mapped_at_creation: false,
        });
        
        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Inventory Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("inventory.wgsl").into()),
        });
        
        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Inventory Pipeline Layout"),
            bind_group_layouts: &[&bind_group_layout],
            push_constant_ranges: &[],
        });
        
        let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Inventory Pipeline"),
            layout: Some(&pipeline_layout),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: Some("vs_main"),
                buffers: &[
                    wgpu::VertexBufferLayout {
                        array_stride: 8,
                        step_mode: wgpu::VertexStepMode::Vertex,
                        attributes: &[wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x2,
                            offset: 0,
                            shader_location: 0,
                        }],
                    },
                    wgpu::VertexBufferLayout {
                        array_stride: std::mem::size_of::<InventorySlot>() as u64,
                        step_mode: wgpu::VertexStepMode::Instance,
                        attributes: &[
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Float32x2,
                                offset: 0,
                                shader_location: 1,
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Float32x2,
                                offset: 8,
                                shader_location: 2,
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Uint32,
                                offset: 16,
                                shader_location: 3,
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Uint32,
                                offset: 20,
                                shader_location: 4,
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Uint32,
                                offset: 24,
                                shader_location: 5,
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Float32x4,
                                offset: 32,
                                shader_location: 6,
                            },
                            wgpu::VertexAttribute {
                                format: wgpu::VertexFormat::Float32x4,
                                offset: 48,
                                shader_location: 7,
                            },
                        ],
                    },
                ],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format,
                    blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState::default(),
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
            cache: None,
        });
        
        let mut renderer = Self {
            pipeline,
            vertex_buffer,
            instance_buffer,
            uniform_buffer,
            bind_group,
            screen_width: width as f32,
            screen_height: height as f32,
            start_time: Instant::now(),
            panel_x: 0.0,
            panel_y: 0.0,
            panel_width: 0.0,
            panel_height: 0.0,
            content_height: 0.0,
            visible_rows: 0,
        };
        
        renderer.update_layout();
        renderer
    }
    
    pub fn resize(&mut self, width: u32, height: u32) {
        self.screen_width = width as f32;
        self.screen_height = height as f32;
        self.update_layout();
    }
    
    fn update_layout(&mut self) {
        // Размер панели - 70% экрана по ширине, 60% по высоте (чтобы хотбар был виден)
        self.panel_width = (self.screen_width * 0.7).min(
            INVENTORY_COLS as f32 * (INV_SLOT_SIZE + INV_SLOT_GAP) + INV_PADDING * 2.0 + SCROLLBAR_WIDTH + 20.0
        );
        self.panel_height = (self.screen_height * 0.6).min(self.screen_height - 150.0); // Оставляем место для хотбара
        
        // Центрируем панель, но немного выше чтобы не перекрывать хотбар
        self.panel_x = (self.screen_width - self.panel_width) / 2.0;
        self.panel_y = (self.screen_height - self.panel_height - 120.0) / 2.0; // Смещаем вверх
        
        // Высота контента (без заголовка)
        self.content_height = self.panel_height - HEADER_HEIGHT - INV_PADDING * 2.0;
        
        // Количество видимых рядов
        self.visible_rows = ((self.content_height) / (INV_SLOT_SIZE + INV_SLOT_GAP)) as usize;
    }
    
    /// Получить индекс слота под курсором
    pub fn get_slot_at(&self, mx: f32, my: f32, inventory: &Inventory) -> Option<usize> {
        if !inventory.is_visible() {
            return None;
        }
        
        let content_x = self.panel_x + INV_PADDING;
        let content_y = self.panel_y + HEADER_HEIGHT + INV_PADDING;
        
        // Проверяем что курсор в области контента
        if mx < content_x || mx > content_x + INVENTORY_COLS as f32 * (INV_SLOT_SIZE + INV_SLOT_GAP) {
            return None;
        }
        if my < content_y || my > content_y + self.content_height {
            return None;
        }
        
        let rel_x = mx - content_x;
        let rel_y = my - content_y + inventory.scroll() * (INV_SLOT_SIZE + INV_SLOT_GAP);
        
        let col = (rel_x / (INV_SLOT_SIZE + INV_SLOT_GAP)) as usize;
        let row = (rel_y / (INV_SLOT_SIZE + INV_SLOT_GAP)) as usize;
        
        if col >= INVENTORY_COLS {
            return None;
        }
        
        let index = row * INVENTORY_COLS + col;
        let items = inventory.filtered_items();
        
        if index < items.len() {
            Some(index)
        } else {
            None
        }
    }
    
    /// Проверить клик по скроллбару
    pub fn is_scrollbar_click(&self, mx: f32, my: f32) -> bool {
        let sb_x = self.panel_x + self.panel_width - SCROLLBAR_WIDTH - INV_PADDING;
        let sb_y = self.panel_y + HEADER_HEIGHT + INV_PADDING;
        let sb_height = self.content_height;
        
        mx >= sb_x && mx <= sb_x + SCROLLBAR_WIDTH &&
        my >= sb_y && my <= sb_y + sb_height
    }
    
    /// Получить scroll из позиции мыши на скроллбаре
    pub fn get_scroll_from_mouse(&self, my: f32, inventory: &Inventory) -> f32 {
        self.get_scroll_from_mouse_raw(my, inventory.max_scroll())
    }
    
    /// Получить scroll из позиции мыши (без ссылки на инвентарь)
    pub fn get_scroll_from_mouse_raw(&self, my: f32, max_scroll: f32) -> f32 {
        let sb_y = self.panel_y + HEADER_HEIGHT + INV_PADDING;
        let sb_height = self.content_height;
        
        let rel_y = (my - sb_y).clamp(0.0, sb_height);
        let ratio = rel_y / sb_height;
        
        ratio * max_scroll
    }
    
    /// Обновить max_scroll в инвентаре
    pub fn update_inventory_scroll(&self, inventory: &mut Inventory) {
        let items = inventory.filtered_items();
        let total_rows = (items.len() + INVENTORY_COLS - 1) / INVENTORY_COLS;
        inventory.update_max_scroll(self.visible_rows, total_rows);
    }
    
    pub fn render<'a>(
        &'a self,
        render_pass: &mut wgpu::RenderPass<'a>,
        queue: &wgpu::Queue,
        inventory: &Inventory,
    ) {
        if !inventory.is_visible() {
            return;
        }
        
        let time = self.start_time.elapsed().as_secs_f32();
        
        let uniforms = InventoryUniforms {
            screen_size: [self.screen_width, self.screen_height],
            time,
            scroll: inventory.scroll(),
            panel_pos: [self.panel_x, self.panel_y],
            panel_size: [self.panel_width, self.panel_height],
        };
        queue.write_buffer(&self.uniform_buffer, 0, bytemuck::cast_slice(&[uniforms]));
        
        let mut instances: Vec<InventorySlot> = Vec::with_capacity(100);
        
        // 1. Overlay (затемнение)
        instances.push(InventorySlot {
            pos: [0.0, 0.0],
            size: [self.screen_width, self.screen_height],
            slot_type: 0, // overlay
            is_hovered: 0,
            has_item: 0,
            _padding: 0,
            top_color: [0.0, 0.0, 0.0, 0.0],
            side_color: [0.0, 0.0, 0.0, 0.0],
        });
        
        // 2. Панель
        instances.push(InventorySlot {
            pos: [self.panel_x, self.panel_y],
            size: [self.panel_width, self.panel_height],
            slot_type: 1, // panel
            is_hovered: 0,
            has_item: 0,
            _padding: 0,
            top_color: [0.0, 0.0, 0.0, 0.0],
            side_color: [0.0, 0.0, 0.0, 0.0],
        });
        
        // 3. Header
        instances.push(InventorySlot {
            pos: [self.panel_x, self.panel_y],
            size: [self.panel_width, HEADER_HEIGHT],
            slot_type: 5, // header
            is_hovered: 0,
            has_item: 0,
            _padding: 0,
            top_color: [0.0, 0.0, 0.0, 0.0],
            side_color: [0.0, 0.0, 0.0, 0.0],
        });
        
        // 4. Слоты с блоками
        let items = inventory.filtered_items();
        let total_rows = (items.len() + INVENTORY_COLS - 1) / INVENTORY_COLS;
        let scroll_offset = inventory.scroll();
        let start_row = scroll_offset as usize;
        
        let content_x = self.panel_x + INV_PADDING;
        let content_y = self.panel_y + HEADER_HEIGHT + INV_PADDING;
        
        for row in start_row..(start_row + self.visible_rows + 1).min(total_rows) {
            for col in 0..INVENTORY_COLS {
                let index = row * INVENTORY_COLS + col;
                if index >= items.len() {
                    break;
                }
                
                let item = items[index];
                let slot_x = content_x + col as f32 * (INV_SLOT_SIZE + INV_SLOT_GAP);
                let slot_y = content_y + (row as f32 - scroll_offset) * (INV_SLOT_SIZE + INV_SLOT_GAP);
                
                // Пропускаем слоты за пределами видимой области
                if slot_y + INV_SLOT_SIZE < content_y || slot_y > content_y + self.content_height {
                    continue;
                }
                
                let is_hovered = inventory.hovered() == Some(index);
                
                instances.push(InventorySlot {
                    pos: [slot_x, slot_y],
                    size: [INV_SLOT_SIZE, INV_SLOT_SIZE],
                    slot_type: 2, // slot
                    is_hovered: if is_hovered { 1 } else { 0 },
                    has_item: 1,
                    _padding: 0,
                    top_color: [item.top_color[0], item.top_color[1], item.top_color[2], 1.0],
                    side_color: [item.side_color[0], item.side_color[1], item.side_color[2], 1.0],
                });
            }
        }
        
        // 5. Scrollbar track
        let sb_x = self.panel_x + self.panel_width - SCROLLBAR_WIDTH - INV_PADDING;
        let sb_y = self.panel_y + HEADER_HEIGHT + INV_PADDING;
        let sb_height = self.content_height;
        
        instances.push(InventorySlot {
            pos: [sb_x, sb_y],
            size: [SCROLLBAR_WIDTH, sb_height],
            slot_type: 3, // scrollbar track
            is_hovered: 0,
            has_item: 0,
            _padding: 0,
            top_color: [0.0, 0.0, 0.0, 0.0],
            side_color: [0.0, 0.0, 0.0, 0.0],
        });
        
        // 6. Scrollbar thumb
        let max_scroll = inventory.max_scroll();
        if max_scroll > 0.0 {
            let thumb_height = (self.visible_rows as f32 / total_rows as f32 * sb_height).max(30.0);
            let thumb_y = sb_y + (scroll_offset / max_scroll) * (sb_height - thumb_height);
            
            instances.push(InventorySlot {
                pos: [sb_x, thumb_y],
                size: [SCROLLBAR_WIDTH, thumb_height],
                slot_type: 4, // scrollbar thumb
                is_hovered: 0,
                has_item: 0,
                _padding: 0,
                top_color: [0.0, 0.0, 0.0, 0.0],
                side_color: [0.0, 0.0, 0.0, 0.0],
            });
        }
        
        queue.write_buffer(&self.instance_buffer, 0, bytemuck::cast_slice(&instances));
        
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_bind_group(0, &self.bind_group, &[]);
        render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        render_pass.set_vertex_buffer(1, self.instance_buffer.slice(..));
        render_pass.draw(0..6, 0..instances.len() as u32);
    }
    
    /// Рендер перетаскиваемого блока (вызывается отдельно с позицией мыши)
    pub fn render_dragging<'a>(
        &'a self,
        render_pass: &mut wgpu::RenderPass<'a>,
        queue: &wgpu::Queue,
        inventory: &Inventory,
        mouse_x: f32,
        mouse_y: f32,
    ) {
        if let Some(block_type) = inventory.dragging() {
            let (top, side) = get_face_colors(block_type);
            
            let drag_size = 56.0; // Немного меньше слота
            
            let instances = vec![InventorySlot {
                pos: [mouse_x - drag_size / 2.0, mouse_y - drag_size / 2.0],
                size: [drag_size, drag_size],
                slot_type: 6, // dragging item
                is_hovered: 1,
                has_item: 1,
                _padding: 0,
                top_color: [top[0], top[1], top[2], 1.0],
                side_color: [side[0], side[1], side[2], 1.0],
            }];
            
            queue.write_buffer(&self.instance_buffer, 0, bytemuck::cast_slice(&instances));
            
            render_pass.set_pipeline(&self.pipeline);
            render_pass.set_bind_group(0, &self.bind_group, &[]);
            render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
            render_pass.set_vertex_buffer(1, self.instance_buffer.slice(..));
            render_pass.draw(0..6, 0..1);
        }
    }
    
    /// Получить позицию панели для текста
    pub fn panel_pos(&self) -> (f32, f32) {
        (self.panel_x, self.panel_y)
    }
    
    /// Получить размер панели
    pub fn panel_size(&self) -> (f32, f32) {
        (self.panel_width, self.panel_height)
    }
}


============================================================
FILE: lighting\cascade.rs
============================================================

// ============================================
// Cascade Configuration - Настройки каскадов CSM
// ============================================

use ultraviolet::{Vec3, Vec4, Mat4};

/// Конфигурация каскадов теней
#[derive(Clone, Debug)]
pub struct CascadeConfig {
    /// Количество каскадов (обычно 3-4)
    pub num_cascades: usize,
    /// Разрешение shadow map для каждого каскада
    pub resolution: u32,
    /// Дальности каскадов (в блоках)
    pub cascade_distances: Vec<f32>,
    /// Коэффициент перекрытия между каскадами
    pub overlap_factor: f32,
    /// Стабилизация (снижает мерцание теней)
    pub stabilize: bool,
}

impl CascadeConfig {
    /// Конфигурация для больших миров (горы, дальние тени)
    pub fn large_world() -> Self {
        Self {
            num_cascades: 2,
            resolution: 2048,
            cascade_distances: vec![64.0, 256.0, 512.0, 1024.0],
            overlap_factor: 0.1,
            stabilize: true,
        }
    }
    
    /// Конфигурация для средних миров
    pub fn medium_world() -> Self {
        Self {
            num_cascades: 3,
            resolution: 1024,
            cascade_distances: vec![32.0, 128.0, 512.0],
            overlap_factor: 0.1,
            stabilize: true,
        }
    }
    
    /// Быстрая конфигурация (меньше качество, выше FPS)
    pub fn fast() -> Self {
        Self {
            num_cascades: 2,
            resolution: 512,
            cascade_distances: vec![64.0, 256.0],
            overlap_factor: 0.05,
            stabilize: false,
        }
    }
}

impl Default for CascadeConfig {
    fn default() -> Self {
        Self::large_world()
    }
}

/// Один каскад shadow map
#[derive(Clone, Debug)]
pub struct Cascade {
    /// Индекс каскада
    pub index: usize,
    /// Ближняя плоскость
    pub near: f32,
    /// Дальняя плоскость
    pub far: f32,
    /// Матрица вида-проекции для рендеринга теней
    pub light_view_proj: Mat4,
    /// Размер текселя в мировых координатах (для стабилизации)
    pub texel_size: f32,
}

impl Cascade {
    pub fn new(index: usize, near: f32, far: f32) -> Self {
        Self {
            index,
            near,
            far,
            light_view_proj: Mat4::identity(),
            texel_size: 0.0,
        }
    }
    
    /// Вычислить frustum corners камеры для этого каскада
    pub fn compute_frustum_corners(
        &self,
        camera_inv_view_proj: &Mat4,
    ) -> [Vec3; 8] {
        let mut corners = [Vec3::zero(); 8];
        
        // NDC координаты углов frustum
        let ndc_corners = [
            Vec4::new(-1.0, -1.0, 0.0, 1.0), // near bottom-left
            Vec4::new( 1.0, -1.0, 0.0, 1.0), // near bottom-right
            Vec4::new( 1.0,  1.0, 0.0, 1.0), // near top-right
            Vec4::new(-1.0,  1.0, 0.0, 1.0), // near top-left
            Vec4::new(-1.0, -1.0, 1.0, 1.0), // far bottom-left
            Vec4::new( 1.0, -1.0, 1.0, 1.0), // far bottom-right
            Vec4::new( 1.0,  1.0, 1.0, 1.0), // far top-right
            Vec4::new(-1.0,  1.0, 1.0, 1.0), // far top-left
        ];
        
        for (i, ndc) in ndc_corners.iter().enumerate() {
            let world = *camera_inv_view_proj * *ndc;
            corners[i] = Vec3::new(world.x / world.w, world.y / world.w, world.z / world.w);
        }
        
        corners
    }
    
    /// Обновить матрицу света для этого каскада
    pub fn update_light_matrix(
        &mut self,
        light_dir: Vec3,
        frustum_corners: &[Vec3; 8],
        resolution: u32,
        stabilize: bool,
    ) {
        // Центр frustum
        let center = frustum_corners.iter().fold(Vec3::zero(), |acc, c| acc + *c) / 8.0;
        
        // Матрица вида света
        let up = if light_dir.y.abs() > 0.99 {
            Vec3::new(0.0, 0.0, 1.0)
        } else {
            Vec3::new(0.0, 1.0, 0.0)
        };
        
        let light_view = Mat4::look_at(
            center - light_dir * 100.0,
            center,
            up,
        );
        
        // Трансформируем углы в пространство света
        let mut min_x = f32::MAX;
        let mut max_x = f32::MIN;
        let mut min_y = f32::MAX;
        let mut max_y = f32::MIN;
        let mut min_z = f32::MAX;
        let mut max_z = f32::MIN;
        
        for corner in frustum_corners {
            let light_space = light_view * Vec4::new(corner.x, corner.y, corner.z, 1.0);
            min_x = min_x.min(light_space.x);
            max_x = max_x.max(light_space.x);
            min_y = min_y.min(light_space.y);
            max_y = max_y.max(light_space.y);
            min_z = min_z.min(light_space.z);
            max_z = max_z.max(light_space.z);
        }
        
        // Расширяем Z для захвата объектов за frustum
        let z_mult = 2.0;
        let z_range = max_z - min_z;
        min_z -= z_range * (z_mult - 1.0);
        
        // Стабилизация - привязка к текселям
        if stabilize {
            let world_units_per_texel = (max_x - min_x) / resolution as f32;
            self.texel_size = world_units_per_texel;
            
            min_x = (min_x / world_units_per_texel).floor() * world_units_per_texel;
            max_x = (max_x / world_units_per_texel).ceil() * world_units_per_texel;
            min_y = (min_y / world_units_per_texel).floor() * world_units_per_texel;
            max_y = (max_y / world_units_per_texel).ceil() * world_units_per_texel;
        }
        
        // Ортографическая проекция
        let light_proj = Mat4::new(
            Vec4::new(2.0 / (max_x - min_x), 0.0, 0.0, 0.0),
            Vec4::new(0.0, 2.0 / (max_y - min_y), 0.0, 0.0),
            Vec4::new(0.0, 0.0, 1.0 / (max_z - min_z), 0.0),
            Vec4::new(
                -(max_x + min_x) / (max_x - min_x),
                -(max_y + min_y) / (max_y - min_y),
                -min_z / (max_z - min_z),
                1.0,
            ),
        );
        
        self.light_view_proj = light_proj * light_view;
    }
}


============================================================
FILE: lighting\celestial.rs
============================================================

// ============================================
// Celestial Bodies - Солнце и Луна
// ============================================
// Система смены дня и ночи

use ultraviolet::Vec3;
use std::f32::consts::{PI, TAU};

/// Время суток (0.0 - 1.0, где 0.0 = полночь, 0.5 = полдень)
#[derive(Clone, Copy, Debug)]
pub struct TimeOfDay {
    /// Нормализованное время (0.0 - 1.0)
    pub time: f32,
    /// Скорость течения времени (1.0 = реальное время, 72.0 = 20 минут на сутки)
    pub speed: f32,
}

impl TimeOfDay {
    pub fn new(time: f32, speed: f32) -> Self {
        Self {
            time: time.rem_euclid(1.0),
            speed,
        }
    }

    /// Обновить время
    pub fn update(&mut self, dt: f32) {
        // 1 игровой день = 24 минуты при speed = 1.0
        self.time += dt * self.speed / (24.0 * 60.0);
        self.time = self.time.rem_euclid(1.0);
    }

    /// Угол солнца в радианах (0 = восход, PI/2 = полдень, PI = закат)
    pub fn sun_angle(&self) -> f32 {
        (self.time - 0.25) * TAU
    }

    /// Угол луны (противоположен солнцу)
    pub fn moon_angle(&self) -> f32 {
        self.sun_angle() + PI
    }

    /// Это день? (солнце над горизонтом)
    pub fn is_day(&self) -> bool {
        self.time > 0.25 && self.time < 0.75
    }

    /// Высота солнца над горизонтом (-1 до 1)
    pub fn sun_height(&self) -> f32 {
        self.sun_angle().sin()
    }
}

impl Default for TimeOfDay {
    fn default() -> Self {
        Self::new(0.35, 1.0) // Утро, нормальная скорость
    }
}

/// Небесное тело (солнце или луна)
#[derive(Clone, Copy, Debug)]
pub struct CelestialBody {
    /// Направление к телу (нормализованное)
    pub direction: Vec3,
    /// Цвет света
    pub color: Vec3,
    /// Интенсивность (0.0 - 1.0)
    pub intensity: f32,
    /// Видимость (0.0 - 1.0, для плавных переходов)
    pub visibility: f32,
}

impl CelestialBody {
    pub fn new() -> Self {
        Self {
            direction: Vec3::new(0.0, 1.0, 0.0),
            color: Vec3::one(),
            intensity: 1.0,
            visibility: 1.0,
        }
    }

    /// Направление света (от тела к поверхности)
    pub fn light_direction(&self) -> Vec3 {
        -self.direction
    }
}

/// Солнце
pub struct Sun {
    pub body: CelestialBody,
}

impl Sun {
    pub fn new() -> Self {
        Self {
            body: CelestialBody::new(),
        }
    }

    /// Обновить позицию и цвет солнца
    pub fn update(&mut self, time: &TimeOfDay) {
        let angle = time.sun_angle();
        
        // Позиция солнца на небосводе
        let height = angle.sin();
        let horizontal = angle.cos();
        
        self.body.direction = Vec3::new(
            horizontal * 0.3,
            height,
            horizontal * 0.95,
        ).normalized();

        // Видимость (плавный переход на горизонте)
        self.body.visibility = smoothstep(-0.1, 0.1, height);

        // Интенсивность зависит от высоты
        self.body.intensity = smoothstep(-0.05, 0.3, height);

        // Цвет солнца
        if height > 0.2 {
            // День - тёплый белый
            self.body.color = Vec3::new(1.0, 0.98, 0.95);
        } else if height > 0.0 {
            // Закат/рассвет - оранжевый/красный
            let t = height / 0.2;
            self.body.color = Vec3::new(
                1.0,
                0.5 + 0.48 * t,
                0.3 + 0.65 * t,
            );
        } else {
            // Под горизонтом
            self.body.color = Vec3::new(1.0, 0.4, 0.2);
        }
    }
}

/// Луна
pub struct Moon {
    pub body: CelestialBody,
    /// Фаза луны (0.0 - 1.0)
    pub phase: f32,
}

impl Moon {
    pub fn new() -> Self {
        Self {
            body: CelestialBody {
                color: Vec3::new(0.6, 0.7, 0.9), // Холодный голубоватый
                intensity: 0.15,
                ..CelestialBody::new()
            },
            phase: 0.5, // Полнолуние
        }
    }

    /// Обновить позицию луны
    pub fn update(&mut self, time: &TimeOfDay) {
        let angle = time.moon_angle();
        
        let height = angle.sin();
        let horizontal = angle.cos();
        
        self.body.direction = Vec3::new(
            horizontal * 0.3,
            height,
            horizontal * 0.95,
        ).normalized();

        // Видимость
        self.body.visibility = smoothstep(-0.1, 0.1, height);

        // Интенсивность зависит от фазы и высоты
        let phase_intensity = 0.5 + 0.5 * (self.phase * TAU).cos().abs();
        self.body.intensity = 0.15 * phase_intensity * smoothstep(-0.05, 0.2, height);
    }

    /// Обновить фазу луны (медленный цикл ~29.5 дней)
    pub fn update_phase(&mut self, dt: f32) {
        self.phase += dt / (29.5 * 24.0 * 60.0 * 60.0);
        self.phase = self.phase.rem_euclid(1.0);
    }
}

/// Система дня и ночи
pub struct DayNightCycle {
    pub time: TimeOfDay,
    pub sun: Sun,
    pub moon: Moon,
    /// Ambient освещение
    pub ambient_color: Vec3,
    pub ambient_intensity: f32,
    /// Цвет неба
    pub sky_color: Vec3,
    /// Цвет тумана
    pub fog_color: Vec3,
}

impl DayNightCycle {
    pub fn new() -> Self {
        let mut cycle = Self {
            time: TimeOfDay::default(),
            sun: Sun::new(),
            moon: Moon::new(),
            ambient_color: Vec3::one(),
            ambient_intensity: 0.3,
            sky_color: Vec3::new(0.5, 0.7, 1.0),
            fog_color: Vec3::new(0.7, 0.8, 0.9),
        };
        cycle.update(0.0);
        cycle
    }

    /// Установить время суток
    pub fn set_time(&mut self, time: f32) {
        self.time.time = time.rem_euclid(1.0);
        self.update(0.0);
    }

    /// Установить скорость времени
    pub fn set_speed(&mut self, speed: f32) {
        self.time.speed = speed;
    }

    /// Обновить всю систему
    pub fn update(&mut self, dt: f32) {
        self.time.update(dt);
        self.sun.update(&self.time);
        self.moon.update(&self.time);
        self.moon.update_phase(dt);
        
        self.update_ambient();
        self.update_sky();
    }

    fn update_ambient(&mut self) {
        let sun_h = self.time.sun_height();
        
        if sun_h > 0.1 {
            // День
            self.ambient_color = Vec3::new(0.9, 0.95, 1.0);
            self.ambient_intensity = 0.3 + 0.1 * sun_h;
        } else if sun_h > -0.1 {
            // Сумерки
            let t = (sun_h + 0.1) / 0.2;
            self.ambient_color = Vec3::new(
                0.4 + 0.5 * t,
                0.4 + 0.55 * t,
                0.6 + 0.4 * t,
            );
            self.ambient_intensity = 0.15 + 0.15 * t;
        } else {
            // Ночь
            self.ambient_color = Vec3::new(0.3, 0.35, 0.5);
            self.ambient_intensity = 0.1 + 0.05 * self.moon.body.intensity;
        }
    }

    fn update_sky(&mut self) {
        let sun_h = self.time.sun_height();
        
        if sun_h > 0.2 {
            // День - голубое небо
            self.sky_color = Vec3::new(0.5, 0.7, 1.0);
            self.fog_color = Vec3::new(0.7, 0.8, 0.95);
        } else if sun_h > 0.0 {
            // Закат/рассвет
            let t = sun_h / 0.2;
            self.sky_color = Vec3::new(
                0.9 - 0.4 * t,
                0.4 + 0.3 * t,
                0.3 + 0.7 * t,
            );
            self.fog_color = Vec3::new(
                0.9 - 0.2 * t,
                0.6 + 0.2 * t,
                0.5 + 0.45 * t,
            );
        } else if sun_h > -0.2 {
            // Сумерки
            let t = (sun_h + 0.2) / 0.2;
            self.sky_color = Vec3::new(
                0.1 + 0.8 * t,
                0.1 + 0.3 * t,
                0.2 + 0.1 * t,
            );
            self.fog_color = Vec3::new(
                0.15 + 0.75 * t,
                0.15 + 0.45 * t,
                0.25 + 0.25 * t,
            );
        } else {
            // Ночь - тёмно-синее небо
            self.sky_color = Vec3::new(0.05, 0.07, 0.15);
            self.fog_color = Vec3::new(0.1, 0.12, 0.2);
        }
    }

    /// Получить основной источник света (солнце днём, луна ночью)
    pub fn primary_light(&self) -> &CelestialBody {
        if self.time.is_day() {
            &self.sun.body
        } else {
            &self.moon.body
        }
    }

    /// Получить направление света для теней
    pub fn shadow_light_direction(&self) -> Vec3 {
        // Используем солнце для теней днём, луну ночью
        // Но ночью тени слабее
        if self.sun.body.visibility > 0.1 {
            self.sun.body.light_direction()
        } else {
            self.moon.body.light_direction()
        }
    }

    /// Получить интенсивность теней
    pub fn shadow_intensity(&self) -> f32 {
        if self.time.is_day() {
            self.sun.body.intensity
        } else {
            self.moon.body.intensity * 0.5
        }
    }
}

impl Default for DayNightCycle {
    fn default() -> Self {
        Self::new()
    }
}

/// Плавная интерполяция
fn smoothstep(edge0: f32, edge1: f32, x: f32) -> f32 {
    let t = ((x - edge0) / (edge1 - edge0)).clamp(0.0, 1.0);
    t * t * (3.0 - 2.0 * t)
}


============================================================
FILE: lighting\celestial_render.rs
============================================================

// ============================================
// Celestial Bodies Renderer - Солнце и Луна
// ============================================

use bytemuck::{Pod, Zeroable};
use wgpu::util::DeviceExt;
use ultraviolet::{Vec3, Mat4};

use crate::gpu::lighting::DayNightCycle;

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct CelestialVertex {
    pub position: [f32; 3],
    pub uv: [f32; 2],
}

impl CelestialVertex {
    pub fn desc() -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<CelestialVertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                wgpu::VertexAttribute {
                    offset: 0,
                    shader_location: 0,
                    format: wgpu::VertexFormat::Float32x3,
                },
                wgpu::VertexAttribute {
                    offset: 12,
                    shader_location: 1,
                    format: wgpu::VertexFormat::Float32x2,
                },
            ],
        }
    }
}


/// Uniform данные - все vec3 заменены на vec4 для WGSL alignment
#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct CelestialUniforms {
    pub view_proj: [[f32; 4]; 4],    // 64 bytes
    pub camera_pos: [f32; 4],         // 16 bytes (xyz + pad)
    pub sun_direction: [f32; 4],      // 16 bytes (xyz + visibility)
    pub sun_color: [f32; 4],          // 16 bytes (rgb + size)
    pub moon_direction: [f32; 4],     // 16 bytes (xyz + visibility)
    pub moon_color: [f32; 4],         // 16 bytes (rgb + phase)
    pub time_of_day: [f32; 4],        // 16 bytes (time + pad)
}

impl Default for CelestialUniforms {
    fn default() -> Self {
        Self {
            view_proj: Mat4::identity().into(),
            camera_pos: [0.0, 0.0, 0.0, 0.0],
            sun_direction: [0.0, 1.0, 0.0, 1.0],
            sun_color: [1.0, 0.95, 0.8, 0.15],
            moon_direction: [0.0, -1.0, 0.0, 0.0],
            moon_color: [0.8, 0.85, 1.0, 0.5],
            time_of_day: [0.5, 0.0, 0.0, 0.0],
        }
    }
}

pub struct CelestialRenderer {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    uniform_buffer: wgpu::Buffer,
    bind_group: wgpu::BindGroup,
    pipeline: wgpu::RenderPipeline,
}


impl CelestialRenderer {
    pub fn new(device: &wgpu::Device, surface_format: wgpu::TextureFormat) -> Self {
        let vertices = vec![
            CelestialVertex { position: [-1.0, -1.0, 0.0], uv: [0.0, 1.0] },
            CelestialVertex { position: [ 1.0, -1.0, 0.0], uv: [1.0, 1.0] },
            CelestialVertex { position: [ 1.0,  1.0, 0.0], uv: [1.0, 0.0] },
            CelestialVertex { position: [-1.0,  1.0, 0.0], uv: [0.0, 0.0] },
        ];
        let indices: Vec<u32> = vec![0, 1, 2, 0, 2, 3];

        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Celestial VB"),
            contents: bytemuck::cast_slice(&vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });
        let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Celestial IB"),
            contents: bytemuck::cast_slice(&indices),
            usage: wgpu::BufferUsages::INDEX,
        });
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Celestial UB"),
            contents: bytemuck::cast_slice(&[CelestialUniforms::default()]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Celestial BGL"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });
        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Celestial BG"),
            layout: &bind_group_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: uniform_buffer.as_entire_binding(),
            }],
        });

        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Celestial Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("../shaders/celestial.wgsl").into()),
        });
        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Celestial PL"),
            bind_group_layouts: &[&bind_group_layout],
            push_constant_ranges: &[],
        });

        let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Celestial Pipeline"),
            layout: Some(&pipeline_layout),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: Some("vs_main"),
                buffers: &[CelestialVertex::desc()],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format: surface_format,
                    blend: Some(wgpu::BlendState {
                        color: wgpu::BlendComponent {
                            src_factor: wgpu::BlendFactor::SrcAlpha,
                            dst_factor: wgpu::BlendFactor::One,
                            operation: wgpu::BlendOperation::Add,
                        },
                        alpha: wgpu::BlendComponent {
                            src_factor: wgpu::BlendFactor::One,
                            dst_factor: wgpu::BlendFactor::One,
                            operation: wgpu::BlendOperation::Max,
                        },
                    }),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleList,
                front_face: wgpu::FrontFace::Ccw,
                cull_mode: None,
                ..Default::default()
            },
            depth_stencil: Some(wgpu::DepthStencilState {
                format: wgpu::TextureFormat::Depth32Float,
                depth_write_enabled: false,
                depth_compare: wgpu::CompareFunction::GreaterEqual, // Reversed-Z
                stencil: Default::default(),
                bias: Default::default(),
            }),
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
            cache: None,
        });

        Self { vertex_buffer, index_buffer, uniform_buffer, bind_group, pipeline }
    }


    pub fn update(&self, queue: &wgpu::Queue, view_proj: [[f32; 4]; 4], camera_pos: Vec3, day_night: &DayNightCycle) {
        let sun_dir = day_night.sun.body.direction;
        let moon_dir = day_night.moon.body.direction;
        let sun_col = day_night.sun.body.color;
        let moon_col = day_night.moon.body.color;

        let uniforms = CelestialUniforms {
            view_proj,
            camera_pos: [camera_pos.x, camera_pos.y, camera_pos.z, 0.0],
            sun_direction: [sun_dir.x, sun_dir.y, sun_dir.z, day_night.sun.body.visibility],
            sun_color: [sun_col.x, sun_col.y, sun_col.z, 0.12],
            moon_direction: [moon_dir.x, moon_dir.y, moon_dir.z, day_night.moon.body.visibility],
            moon_color: [moon_col.x, moon_col.y, moon_col.z, day_night.moon.phase],
            time_of_day: [day_night.time.time, 0.0, 0.0, 0.0],
        };
        queue.write_buffer(&self.uniform_buffer, 0, bytemuck::cast_slice(&[uniforms]));
    }

    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_bind_group(0, &self.bind_group, &[]);
        render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        render_pass.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
        render_pass.draw_indexed(0..6, 0, 0..2);
    }
}


============================================================
FILE: lighting\csm.rs
============================================================

// ============================================
// Cascaded Shadow Maps (CSM) - Главный класс
// ============================================
// Оптимизированная система теней для больших миров
// - 4 каскада для разных дистанций
// - PCF фильтрация для мягких теней
// - Стабилизация для устранения мерцания

use wgpu::util::DeviceExt;
use ultraviolet::{Vec3, Mat4};

use super::cascade::{Cascade, CascadeConfig};
use super::shadow_map::{ShadowMapArray, ShadowUniform};
use super::light::DirectionalLight;

/// Главная система Cascaded Shadow Maps
pub struct CascadedShadowMaps {
    /// Конфигурация
    config: CascadeConfig,
    /// Каскады
    cascades: Vec<Cascade>,
    /// GPU текстуры теней
    shadow_maps: ShadowMapArray,
    /// Uniform буфер для шейдера
    uniform_buffer: wgpu::Buffer,
    /// Bind group для сэмплирования теней
    bind_group: wgpu::BindGroup,
    /// Bind group layout
    bind_group_layout: wgpu::BindGroupLayout,
    /// Pipeline для рендеринга теней
    shadow_pipeline: wgpu::RenderPipeline,
    /// Текущие данные uniform
    uniform_data: ShadowUniform,
}

impl CascadedShadowMaps {
    pub fn new(
        device: &wgpu::Device,
        config: CascadeConfig,
        terrain_vertex_layout: &wgpu::VertexBufferLayout,
    ) -> Self {
        let num_cascades = config.num_cascades;
        let resolution = config.resolution;
        
        // Создаём каскады
        let mut cascades = Vec::with_capacity(num_cascades);
        let mut prev_dist = 0.0;
        
        for (i, &dist) in config.cascade_distances.iter().enumerate() {
            cascades.push(Cascade::new(i, prev_dist, dist));
            prev_dist = dist * (1.0 - config.overlap_factor);
        }
        
        // Создаём shadow map array
        let shadow_maps = ShadowMapArray::new(device, resolution, num_cascades as u32);
        
        // Uniform буфер
        let uniform_data = ShadowUniform::new();
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("CSM Uniform Buffer"),
            contents: bytemuck::cast_slice(&[uniform_data]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });
        
        // Bind group layout для сэмплирования теней
        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("CSM Bind Group Layout"),
            entries: &[
                // Shadow map array
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        sample_type: wgpu::TextureSampleType::Depth,
                        view_dimension: wgpu::TextureViewDimension::D2Array,
                        multisampled: false,
                    },
                    count: None,
                },
                // Comparison sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Comparison),
                    count: None,
                },
                // Shadow uniforms
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        });
        
        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("CSM Bind Group"),
            layout: &bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&shadow_maps.array_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&shadow_maps.sampler),
                },
                wgpu::BindGroupEntry {
                    binding: 2,
                    resource: uniform_buffer.as_entire_binding(),
                },
            ],
        });
        
        // Shadow pipeline (только depth, без fragment shader)
        let shadow_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Shadow Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("shadow.wgsl").into()),
        });
        
        // Layout для shadow pass (только light matrix uniform)
        let shadow_uniform_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Shadow Pass Uniform Layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });
        
        let shadow_pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Shadow Pipeline Layout"),
            bind_group_layouts: &[&shadow_uniform_layout],
            push_constant_ranges: &[],
        });
        
        let shadow_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Shadow Pipeline"),
            layout: Some(&shadow_pipeline_layout),
            vertex: wgpu::VertexState {
                module: &shadow_shader,
                entry_point: Some("vs_main"),
                buffers: &[terrain_vertex_layout.clone()],
                compilation_options: Default::default(),
            },
            fragment: None, // Только depth
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleList,
                strip_index_format: None,
                front_face: wgpu::FrontFace::Ccw,
                // Depth bias для борьбы с shadow acne
                cull_mode: Some(wgpu::Face::Front), // Front-face culling для теней
                polygon_mode: wgpu::PolygonMode::Fill,
                unclipped_depth: false,
                conservative: false,
            },
            depth_stencil: Some(wgpu::DepthStencilState {
                format: wgpu::TextureFormat::Depth32Float,
                depth_write_enabled: true,
                depth_compare: wgpu::CompareFunction::Less,
                stencil: wgpu::StencilState::default(),
                bias: wgpu::DepthBiasState {
                    constant: 2,
                    slope_scale: 2.0,
                    clamp: 0.0,
                },
            }),
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
            cache: None,
        });
        
        Self {
            config,
            cascades,
            shadow_maps,
            uniform_buffer,
            bind_group,
            bind_group_layout,
            shadow_pipeline,
            uniform_data,
        }
    }
    
    /// Обновить каскады на основе камеры и света
    pub fn update(
        &mut self,
        queue: &wgpu::Queue,
        camera_view: &Mat4,
        camera_proj: &Mat4,
        _camera_pos: Vec3,
        light: &DirectionalLight,
    ) {
        let camera_inv_view_proj = (*camera_proj * *camera_view).inversed();
        
        // Обновляем каждый каскад
        for cascade in &mut self.cascades {
            // Вычисляем frustum для этого каскада
            let near_ratio = cascade.near / self.config.cascade_distances.last().unwrap_or(&1000.0);
            let far_ratio = cascade.far / self.config.cascade_distances.last().unwrap_or(&1000.0);
            
            // Интерполируем frustum corners
            let full_corners = cascade.compute_frustum_corners(&camera_inv_view_proj);
            
            let mut cascade_corners = [Vec3::zero(); 8];
            for i in 0..4 {
                // Near plane
                cascade_corners[i] = full_corners[i] + (full_corners[i + 4] - full_corners[i]) * near_ratio;
                // Far plane
                cascade_corners[i + 4] = full_corners[i] + (full_corners[i + 4] - full_corners[i]) * far_ratio;
            }
            
            cascade.update_light_matrix(
                light.direction,
                &cascade_corners,
                self.config.resolution,
                self.config.stabilize,
            );
            
            // Обновляем uniform
            self.uniform_data.set_cascade(
                cascade.index,
                &cascade.light_view_proj,
                cascade.far,
            );
        }
        
        self.uniform_data.num_cascades = self.cascades.len() as u32;
        
        // Загружаем на GPU
        queue.write_buffer(
            &self.uniform_buffer,
            0,
            bytemuck::cast_slice(&[self.uniform_data]),
        );
    }
    
    /// Получить bind group layout для интеграции в основной pipeline
    pub fn bind_group_layout(&self) -> &wgpu::BindGroupLayout {
        &self.bind_group_layout
    }
    
    /// Получить bind group для сэмплирования теней
    pub fn bind_group(&self) -> &wgpu::BindGroup {
        &self.bind_group
    }
    
    /// Получить shadow pipeline
    pub fn shadow_pipeline(&self) -> &wgpu::RenderPipeline {
        &self.shadow_pipeline
    }
    
    /// Получить view для рендеринга в конкретный каскад
    pub fn cascade_view(&self, index: usize) -> Option<&wgpu::TextureView> {
        self.shadow_maps.layer_views.get(index)
    }
    
    /// Получить матрицу света для каскада
    pub fn cascade_matrix(&self, index: usize) -> Option<Mat4> {
        self.cascades.get(index).map(|c| c.light_view_proj)
    }
    
    /// Количество каскадов
    pub fn num_cascades(&self) -> usize {
        self.cascades.len()
    }
    
    /// Разрешение shadow map
    pub fn resolution(&self) -> u32 {
        self.config.resolution
    }
}

/// Uniform для shadow pass (одна матрица)
#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
pub struct ShadowPassUniform {
    pub light_view_proj: [[f32; 4]; 4],
}

impl ShadowPassUniform {
    pub fn new(matrix: &Mat4) -> Self {
        Self {
            light_view_proj: (*matrix).into(),
        }
    }
}


============================================================
FILE: lighting\light.rs
============================================================

// ============================================
// Light Sources - Направленный свет (солнце)
// ============================================

use bytemuck::{Pod, Zeroable};
use ultraviolet::{Vec3, Mat4};

/// Направленный свет (солнце/луна)
#[derive(Clone, Copy, Debug)]
pub struct DirectionalLight {
    /// Направление света (нормализованное, от источника)
    pub direction: Vec3,
    /// Цвет света
    pub color: Vec3,
    /// Интенсивность
    pub intensity: f32,
}

impl DirectionalLight {
    pub fn new(direction: Vec3, color: Vec3, intensity: f32) -> Self {
        Self {
            direction: direction.normalized(),
            color,
            intensity,
        }
    }
    
    /// Создать матрицу вида для shadow map
    pub fn view_matrix(&self, center: Vec3) -> Mat4 {
        let up = if self.direction.y.abs() > 0.99 {
            Vec3::new(0.0, 0.0, 1.0)
        } else {
            Vec3::new(0.0, 1.0, 0.0)
        };
        
        Mat4::look_at(
            center - self.direction * 100.0,
            center,
            up,
        )
    }
}

impl Default for DirectionalLight {
    fn default() -> Self {
        Self {
            direction: Vec3::new(0.4, -0.8, 0.3).normalized(),
            color: Vec3::new(1.0, 0.98, 0.9),
            intensity: 1.0,
        }
    }
}

/// Солнце с циклом дня/ночи
pub struct SunLight {
    /// Базовый угол (0 = полдень)
    pub angle: f32,
    /// Скорость вращения (радиан/сек)
    pub rotation_speed: f32,
    /// Текущий направленный свет
    pub light: DirectionalLight,
}

impl SunLight {
    pub fn new() -> Self {
        Self {
            angle: 0.0,
            rotation_speed: 0.0, // Статичное солнце по умолчанию
            light: DirectionalLight::default(),
        }
    }
    
    /// Обновить позицию солнца
    pub fn update(&mut self, dt: f32) {
        self.angle += self.rotation_speed * dt;
        self.angle %= std::f32::consts::TAU;
        
        // Вычисляем направление солнца
        let cos_a = self.angle.cos();
        let sin_a = self.angle.sin();
        
        self.light.direction = Vec3::new(
            0.3 * cos_a,
            -sin_a.abs().max(0.1), // Солнце всегда сверху
            0.3 * sin_a,
        ).normalized();
        
        // Цвет зависит от высоты солнца
        let height = (-self.light.direction.y).max(0.0);
        
        if height > 0.5 {
            // День - белый свет
            self.light.color = Vec3::new(1.0, 0.98, 0.95);
            self.light.intensity = 1.0;
        } else if height > 0.1 {
            // Закат/рассвет - оранжевый
            let t = (height - 0.1) / 0.4;
            self.light.color = Vec3::new(1.0, 0.6 + 0.38 * t, 0.4 + 0.55 * t);
            self.light.intensity = 0.6 + 0.4 * t;
        } else {
            // Ночь - синеватый лунный свет
            self.light.color = Vec3::new(0.4, 0.5, 0.7);
            self.light.intensity = 0.2;
        }
    }
    
    /// Установить время суток (0.0 = полночь, 0.5 = полдень)
    pub fn set_time_of_day(&mut self, time: f32) {
        self.angle = (time - 0.25) * std::f32::consts::TAU;
        self.update(0.0);
    }
}

impl Default for SunLight {
    fn default() -> Self {
        let mut sun = Self::new();
        sun.set_time_of_day(0.4); // Утро
        sun
    }
}

/// GPU uniform для света
#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct LightUniform {
    pub direction: [f32; 3],
    pub intensity: f32,
    pub color: [f32; 3],
    pub _padding: f32,
}

impl From<&DirectionalLight> for LightUniform {
    fn from(light: &DirectionalLight) -> Self {
        Self {
            direction: light.direction.into(),
            intensity: light.intensity,
            color: light.color.into(),
            _padding: 0.0,
        }
    }
}


============================================================
FILE: lighting\mod.rs
============================================================

// ============================================
// Lighting Module - Cascaded Shadow Maps (CSM)
// ============================================
// Оптимизированная система теней для больших миров
// Поддержка теней от гор, построек и других объектов

mod csm;
mod shadow_map;
mod light;
mod cascade;
mod celestial;
mod celestial_render;

pub use csm::CascadedShadowMaps;
pub use shadow_map::ShadowMap;
pub use light::{DirectionalLight, SunLight};
pub use cascade::{Cascade, CascadeConfig};
pub use celestial::{DayNightCycle, TimeOfDay, Sun, Moon, CelestialBody};
pub use celestial_render::CelestialRenderer;


============================================================
FILE: lighting\shadow.wgsl
============================================================

// ============================================
// Shadow Pass Shader - Рендеринг в shadow map
// ============================================
// Минимальный шейдер только для записи глубины

struct ShadowUniforms {
    light_view_proj: mat4x4<f32>,
}

@group(0) @binding(0)
var<uniform> shadow: ShadowUniforms;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) color: vec3<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
}

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    out.clip_position = shadow.light_view_proj * vec4<f32>(in.position, 1.0);
    return out;
}

// Fragment shader не нужен - только depth write


============================================================
FILE: lighting\shadow_map.rs
============================================================

// ============================================
// Shadow Map - GPU текстура глубины для теней
// ============================================

use bytemuck::{Pod, Zeroable};
use ultraviolet::Mat4;

/// GPU ресурсы для одного shadow map
pub struct ShadowMap {
    /// Текстура глубины
    pub texture: wgpu::Texture,
    /// View для рендеринга в текстуру
    pub depth_view: wgpu::TextureView,
    /// View для сэмплирования в шейдере
    pub sample_view: wgpu::TextureView,
    /// Sampler для PCF фильтрации
    pub sampler: wgpu::Sampler,
    /// Разрешение
    pub resolution: u32,
}

impl ShadowMap {
    pub fn new(device: &wgpu::Device, resolution: u32) -> Self {
        let texture = device.create_texture(&wgpu::TextureDescriptor {
            label: Some("Shadow Map Texture"),
            size: wgpu::Extent3d {
                width: resolution,
                height: resolution,
                depth_or_array_layers: 1,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Depth32Float,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT 
                 | wgpu::TextureUsages::TEXTURE_BINDING,
            view_formats: &[],
        });
        
        let depth_view = texture.create_view(&wgpu::TextureViewDescriptor {
            label: Some("Shadow Map Depth View"),
            format: Some(wgpu::TextureFormat::Depth32Float),
            dimension: Some(wgpu::TextureViewDimension::D2),
            aspect: wgpu::TextureAspect::DepthOnly,
            ..Default::default()
        });
        
        let sample_view = texture.create_view(&wgpu::TextureViewDescriptor {
            label: Some("Shadow Map Sample View"),
            format: Some(wgpu::TextureFormat::Depth32Float),
            dimension: Some(wgpu::TextureViewDimension::D2),
            aspect: wgpu::TextureAspect::DepthOnly,
            ..Default::default()
        });
        
        // Sampler с comparison для PCF
        let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
            label: Some("Shadow Map Sampler"),
            address_mode_u: wgpu::AddressMode::ClampToEdge,
            address_mode_v: wgpu::AddressMode::ClampToEdge,
            address_mode_w: wgpu::AddressMode::ClampToEdge,
            mag_filter: wgpu::FilterMode::Linear,
            min_filter: wgpu::FilterMode::Linear,
            mipmap_filter: wgpu::FilterMode::Nearest,
            compare: Some(wgpu::CompareFunction::LessEqual),
            ..Default::default()
        });
        
        Self {
            texture,
            depth_view,
            sample_view,
            sampler,
            resolution,
        }
    }
}

/// Shadow map array для CSM (все каскады в одной текстуре)
pub struct ShadowMapArray {
    /// Текстура-массив глубины
    pub texture: wgpu::Texture,
    /// Views для рендеринга каждого слоя
    pub layer_views: Vec<wgpu::TextureView>,
    /// View для сэмплирования всего массива
    pub array_view: wgpu::TextureView,
    /// Sampler с comparison
    pub sampler: wgpu::Sampler,
    /// Разрешение каждого слоя
    pub resolution: u32,
    /// Количество каскадов
    pub num_cascades: u32,
}

impl ShadowMapArray {
    pub fn new(device: &wgpu::Device, resolution: u32, num_cascades: u32) -> Self {
        let texture = device.create_texture(&wgpu::TextureDescriptor {
            label: Some("CSM Shadow Map Array"),
            size: wgpu::Extent3d {
                width: resolution,
                height: resolution,
                depth_or_array_layers: num_cascades,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Depth32Float,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT 
                 | wgpu::TextureUsages::TEXTURE_BINDING,
            view_formats: &[],
        });
        
        // View для каждого слоя (для рендеринга)
        let layer_views: Vec<_> = (0..num_cascades)
            .map(|i| {
                texture.create_view(&wgpu::TextureViewDescriptor {
                    label: Some(&format!("Shadow Map Layer {} View", i)),
                    format: Some(wgpu::TextureFormat::Depth32Float),
                    dimension: Some(wgpu::TextureViewDimension::D2),
                    aspect: wgpu::TextureAspect::DepthOnly,
                    base_array_layer: i,
                    array_layer_count: Some(1),
                    ..Default::default()
                })
            })
            .collect();
        
        // View для всего массива (для сэмплирования)
        let array_view = texture.create_view(&wgpu::TextureViewDescriptor {
            label: Some("CSM Shadow Map Array View"),
            format: Some(wgpu::TextureFormat::Depth32Float),
            dimension: Some(wgpu::TextureViewDimension::D2Array),
            aspect: wgpu::TextureAspect::DepthOnly,
            base_array_layer: 0,
            array_layer_count: Some(num_cascades),
            ..Default::default()
        });
        
        let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
            label: Some("CSM Shadow Sampler"),
            address_mode_u: wgpu::AddressMode::ClampToEdge,
            address_mode_v: wgpu::AddressMode::ClampToEdge,
            address_mode_w: wgpu::AddressMode::ClampToEdge,
            mag_filter: wgpu::FilterMode::Linear,
            min_filter: wgpu::FilterMode::Linear,
            mipmap_filter: wgpu::FilterMode::Nearest,
            compare: Some(wgpu::CompareFunction::LessEqual),
            ..Default::default()
        });
        
        Self {
            texture,
            layer_views,
            array_view,
            sampler,
            resolution,
            num_cascades,
        }
    }
}

/// Uniform буфер для shadow матриц
#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct ShadowUniform {
    /// Матрицы view-projection для каждого каскада (макс 4)
    pub light_view_proj: [[f32; 16]; 4],
    /// Дальности каскадов
    pub cascade_distances: [f32; 4],
    /// Количество активных каскадов
    pub num_cascades: u32,
    /// Размер текселя для bias
    pub texel_size: f32,
    /// Shadow bias
    pub bias: f32,
    /// Normal offset bias
    pub normal_bias: f32,
}

impl ShadowUniform {
    pub fn new() -> Self {
        Self {
            light_view_proj: [[0.0; 16]; 4],
            cascade_distances: [16.0, 64.0, 256.0, 1024.0],
            num_cascades: 4,
            texel_size: 0.001,
            bias: 0.005,
            normal_bias: 0.02,
        }
    }
    
    pub fn set_cascade(&mut self, index: usize, matrix: &Mat4, distance: f32) {
        if index < 4 {
            let arr: [[f32; 4]; 4] = (*matrix).into();
            for (i, row) in arr.iter().enumerate() {
                for (j, val) in row.iter().enumerate() {
                    self.light_view_proj[index][i * 4 + j] = *val;
                }
            }
            self.cascade_distances[index] = distance;
        }
    }
}

impl Default for ShadowUniform {
    fn default() -> Self {
        Self::new()
    }
}


============================================================
FILE: lighting\shadow_sampling.wgsl
============================================================

// ============================================
// Shadow Sampling Functions - PCF фильтрация
// ============================================
// Функции для сэмплирования CSM теней
// Включается в основной terrain shader

// Структура для shadow uniforms
struct ShadowData {
    light_view_proj_0: mat4x4<f32>,
    light_view_proj_1: mat4x4<f32>,
    light_view_proj_2: mat4x4<f32>,
    light_view_proj_3: mat4x4<f32>,
    cascade_distances: vec4<f32>,
    num_cascades: u32,
    texel_size: f32,
    bias: f32,
    normal_bias: f32,
}

// Выбор каскада по расстоянию от камеры
fn select_cascade(view_depth: f32, cascade_distances: vec4<f32>, num_cascades: u32) -> u32 {
    for (var i: u32 = 0u; i < num_cascades; i = i + 1u) {
        if (view_depth < cascade_distances[i]) {
            return i;
        }
    }
    return num_cascades - 1u;
}

// Получить матрицу света для каскада
fn get_light_matrix(cascade: u32, shadow_data: ShadowData) -> mat4x4<f32> {
    switch (cascade) {
        case 0u: { return shadow_data.light_view_proj_0; }
        case 1u: { return shadow_data.light_view_proj_1; }
        case 2u: { return shadow_data.light_view_proj_2; }
        default: { return shadow_data.light_view_proj_3; }
    }
}

// PCF 3x3 фильтрация для мягких теней
fn sample_shadow_pcf(
    shadow_map: texture_depth_2d_array,
    shadow_sampler: sampler_comparison,
    world_pos: vec3<f32>,
    normal: vec3<f32>,
    light_matrix: mat4x4<f32>,
    cascade: u32,
    bias: f32,
    texel_size: f32,
) -> f32 {
    // Трансформируем в пространство света
    let light_space = light_matrix * vec4<f32>(world_pos, 1.0);
    var proj_coords = light_space.xyz / light_space.w;
    
    // Преобразуем из [-1,1] в [0,1]
    proj_coords.x = proj_coords.x * 0.5 + 0.5;
    proj_coords.y = proj_coords.y * -0.5 + 0.5; // Y инвертирован
    
    // Проверка границ
    if (proj_coords.x < 0.0 || proj_coords.x > 1.0 ||
        proj_coords.y < 0.0 || proj_coords.y > 1.0 ||
        proj_coords.z < 0.0 || proj_coords.z > 1.0) {
        return 1.0; // Вне shadow map - нет тени
    }
    
    let current_depth = proj_coords.z - bias;
    
    // PCF 3x3
    var shadow = 0.0;
    let offsets = array<vec2<f32>, 9>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>( 0.0, -1.0),
        vec2<f32>( 1.0, -1.0),
        vec2<f32>(-1.0,  0.0),
        vec2<f32>( 0.0,  0.0),
        vec2<f32>( 1.0,  0.0),
        vec2<f32>(-1.0,  1.0),
        vec2<f32>( 0.0,  1.0),
        vec2<f32>( 1.0,  1.0),
    );
    
    for (var i = 0; i < 9; i = i + 1) {
        let offset = offsets[i] * texel_size;
        let sample_pos = vec2<f32>(proj_coords.x + offset.x, proj_coords.y + offset.y);
        shadow += textureSampleCompareLevel(
            shadow_map,
            shadow_sampler,
            sample_pos,
            i32(cascade),
            current_depth,
        );
    }
    
    return shadow / 9.0;
}

// Быстрое сэмплирование без PCF (для дальних каскадов)
fn sample_shadow_simple(
    shadow_map: texture_depth_2d_array,
    shadow_sampler: sampler_comparison,
    world_pos: vec3<f32>,
    light_matrix: mat4x4<f32>,
    cascade: u32,
    bias: f32,
) -> f32 {
    let light_space = light_matrix * vec4<f32>(world_pos, 1.0);
    var proj_coords = light_space.xyz / light_space.w;
    
    proj_coords.x = proj_coords.x * 0.5 + 0.5;
    proj_coords.y = proj_coords.y * -0.5 + 0.5;
    
    if (proj_coords.x < 0.0 || proj_coords.x > 1.0 ||
        proj_coords.y < 0.0 || proj_coords.y > 1.0 ||
        proj_coords.z < 0.0 || proj_coords.z > 1.0) {
        return 1.0;
    }
    
    return textureSampleCompareLevel(
        shadow_map,
        shadow_sampler,
        vec2<f32>(proj_coords.x, proj_coords.y),
        i32(cascade),
        proj_coords.z - bias,
    );
}

// Главная функция расчёта тени с выбором каскада
fn calculate_shadow(
    shadow_map: texture_depth_2d_array,
    shadow_sampler: sampler_comparison,
    world_pos: vec3<f32>,
    normal: vec3<f32>,
    view_depth: f32,
    shadow_data: ShadowData,
) -> f32 {
    let cascade = select_cascade(view_depth, shadow_data.cascade_distances, shadow_data.num_cascades);
    let light_matrix = get_light_matrix(cascade, shadow_data);
    
    // PCF для ближних каскадов, простое сэмплирование для дальних
    if (cascade < 2u) {
        return sample_shadow_pcf(
            shadow_map,
            shadow_sampler,
            world_pos,
            normal,
            light_matrix,
            cascade,
            shadow_data.bias,
            shadow_data.texel_size,
        );
    } else {
        return sample_shadow_simple(
            shadow_map,
            shadow_sampler,
            world_pos,
            light_matrix,
            cascade,
            shadow_data.bias,
        );
    }
}

// Визуализация каскадов для отладки
fn debug_cascade_color(cascade: u32) -> vec3<f32> {
    switch (cascade) {
        case 0u: { return vec3<f32>(1.0, 0.0, 0.0); } // Красный
        case 1u: { return vec3<f32>(0.0, 1.0, 0.0); } // Зелёный
        case 2u: { return vec3<f32>(0.0, 0.0, 1.0); } // Синий
        default: { return vec3<f32>(1.0, 1.0, 0.0); } // Жёлтый
    }
}


============================================================
FILE: player\camera.rs
============================================================

// ============================================
// Camera - Система камеры с режимами
// ============================================
// Камера следует за игроком и поддерживает:
// - Первое лицо (FirstPerson)
// - Третье лицо сзади (ThirdPersonBack)
// - Третье лицо спереди (ThirdPersonFront)

use ultraviolet::{Mat4, Vec3};
use super::player::Player;

/// Режим камеры
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CameraMode {
    /// Камера в глазах игрока
    FirstPerson,
    /// Камера сзади игрока
    ThirdPersonBack,
    /// Камера спереди (смотрит в лицо)
    ThirdPersonFront,
}

impl CameraMode {
    /// Переключить на следующий режим
    pub fn next(self) -> Self {
        match self {
            CameraMode::FirstPerson => CameraMode::ThirdPersonBack,
            CameraMode::ThirdPersonBack => CameraMode::ThirdPersonFront,
            CameraMode::ThirdPersonFront => CameraMode::FirstPerson,
        }
    }
}

/// Камера — "глупый" объект, следующий за игроком
pub struct Camera {
    /// Текущая позиция камеры (вычисляется)
    pub position: Vec3,
    
    /// Направление взгляда (вычисляется)
    forward: Vec3,
    
    /// Режим камеры
    pub mode: CameraMode,
    
    /// Дистанция от игрока в режиме 3-го лица
    pub third_person_distance: f32,
    
    /// Минимальная дистанция (при коллизии со стеной)
    pub min_distance: f32,
    
    /// Текущая реальная дистанция (после raycast)
    current_distance: f32,
    
    /// Параметры проекции
    pub aspect: f32,
    pub fov: f32,
    pub near: f32,
    pub far: f32,
}

impl Camera {
    pub fn new(aspect: f32) -> Self {
        Self {
            position: Vec3::new(0.0, 50.0, 0.0),
            forward: Vec3::new(0.0, 0.0, 1.0),
            mode: CameraMode::FirstPerson,
            third_person_distance: 5.0,
            min_distance: 1.0,
            current_distance: 5.0,
            aspect,
            fov: 70.0_f32.to_radians(),
            near: 0.1,
            far: 2000.0,
        }
    }
    
    /// Направление взгляда камеры
    pub fn forward(&self) -> Vec3 {
        self.forward
    }
    
    /// Вектор вправо
    pub fn right(&self) -> Vec3 {
        self.forward.cross(Vec3::unit_y()).normalized()
    }
    
    /// Обновить камеру на основе позиции игрока
    pub fn update_from_player(&mut self, player: &Player) {
        let eye_pos = player.eye_position();
        let player_forward = player.forward();
        
        match self.mode {
            CameraMode::FirstPerson => {
                // Камера точно в глазах
                self.position = eye_pos;
                self.forward = player_forward;
            }
            
            CameraMode::ThirdPersonBack => {
                // Камера сзади игрока
                // CameraPos = EyePos - Forward * Distance
                let target_pos = eye_pos - player_forward * self.third_person_distance;
                
                // Raycast для коллизии со стенами
                self.current_distance = self.raycast_distance(
                    eye_pos,
                    -player_forward,
                    self.third_person_distance,
                );
                
                self.position = eye_pos - player_forward * self.current_distance;
                self.forward = player_forward;
            }
            
            CameraMode::ThirdPersonFront => {
                // Камера спереди, смотрит на игрока
                let target_pos = eye_pos + player_forward * self.third_person_distance;
                
                // Raycast для коллизии
                self.current_distance = self.raycast_distance(
                    eye_pos,
                    player_forward,
                    self.third_person_distance,
                );
                
                self.position = eye_pos + player_forward * self.current_distance;
                // Смотрим на игрока (инвертированный forward)
                self.forward = -player_forward;
            }
        }
    }
    
    /// Raycast от головы игрока к желаемой позиции камеры
    /// Возвращает безопасную дистанцию (не проходящую сквозь стены)
    fn raycast_distance(&self, origin: Vec3, direction: Vec3, max_distance: f32) -> f32 {
        // Простой raycast через сэмплирование
        // В реальном проекте здесь был бы полноценный raycast по воксельной сетке
        
        let step_size = 0.25;
        let steps = (max_distance / step_size) as i32;
        
        for i in 1..=steps {
            let dist = i as f32 * step_size;
            let check_pos = origin + direction * dist;
            
            // Проверяем коллизию с террейном
            // Используем простую проверку: если точка ниже поверхности — коллизия
            let terrain_height = self.sample_terrain_height(check_pos.x, check_pos.z);
            
            if check_pos.y < terrain_height + 0.5 {
                // Нашли коллизию — возвращаем предыдущую безопасную дистанцию
                return ((i - 1) as f32 * step_size).max(self.min_distance);
            }
        }
        
        // Нет коллизий — полная дистанция
        max_distance
    }
    
    /// Сэмплирование высоты террейна (упрощённое)
    /// В реальном проекте это должно использовать ту же функцию что и генератор
    fn sample_terrain_height(&self, x: f32, z: f32) -> f32 {
        // Используем ту же функцию высоты что и террейн
        use crate::gpu::terrain::get_height;
        get_height(x, z)
    }
    
    /// Матрица вида (View Matrix)
    pub fn view_matrix(&self) -> Mat4 {
        let target = self.position + self.forward;
        Mat4::look_at(self.position, target, Vec3::unit_y())
    }
    
    /// Матрица проекции (Perspective с Reversed-Z для лучшей точности вдали)
    pub fn projection_matrix(&self) -> Mat4 {
        // Reversed-Z: меняем near и far местами
        let mut proj = ultraviolet::projection::perspective_wgpu_dx(
            self.fov,
            self.aspect,
            self.far,  // far вместо near
            self.near, // near вместо far
        );
        proj
    }
    
    /// Комбинированная матрица View-Projection
    pub fn view_projection_matrix(&self) -> Mat4 {
        self.projection_matrix() * self.view_matrix()
    }
    
    pub fn resize(&mut self, width: u32, height: u32) {
        self.aspect = width as f32 / height as f32;
    }
    
    /// Переключить режим камеры
    pub fn toggle_mode(&mut self) {
        self.mode = self.mode.next();
    }
    
    /// Нужно ли рендерить модель игрока
    pub fn should_render_player(&self) -> bool {
        match self.mode {
            CameraMode::FirstPerson => false,
            CameraMode::ThirdPersonBack | CameraMode::ThirdPersonFront => true,
        }
    }
    
    /// Текущая дистанция до игрока (для отладки)
    pub fn current_distance(&self) -> f32 {
        self.current_distance
    }
}

// ============================================
// Старый CameraController (для совместимости)
// ============================================

/// Контроллер камеры (WASD + мышь) — DEPRECATED
/// Используйте PlayerController вместо этого
pub struct CameraController {
    pub speed: f32,
    pub sensitivity: f32,
    
    // Состояние клавиш
    forward: bool,
    backward: bool,
    left: bool,
    right: bool,
    up: bool,
    down: bool,
    
    // Дельта мыши
    mouse_dx: f32,
    mouse_dy: f32,
}

impl CameraController {
    pub fn new(speed: f32, sensitivity: f32) -> Self {
        Self {
            speed,
            sensitivity,
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false,
            mouse_dx: 0.0,
            mouse_dy: 0.0,
        }
    }

    pub fn process_keyboard(&mut self, key: winit::keyboard::KeyCode, pressed: bool) {
        use winit::keyboard::KeyCode;
        match key {
            KeyCode::KeyW => self.forward = pressed,
            KeyCode::KeyS => self.backward = pressed,
            KeyCode::KeyA => self.left = pressed,
            KeyCode::KeyD => self.right = pressed,
            KeyCode::Space => self.up = pressed,
            KeyCode::ShiftLeft => self.down = pressed,
            _ => {}
        }
    }

    pub fn process_mouse(&mut self, dx: f64, dy: f64) {
        self.mouse_dx = dx as f32;
        self.mouse_dy = dy as f32;
    }

    pub fn update_camera(&mut self, camera: &mut Camera, dt: f32) {
        // Этот метод больше не используется напрямую
        // Оставлен для совместимости
        self.mouse_dx = 0.0;
        self.mouse_dy = 0.0;
    }
}


============================================================
FILE: player\flight.rs
============================================================

// ============================================
// Flight Mode - Режим полёта
// ============================================
// F - включить/выключить полёт
// Space - вверх, Shift/Ctrl - вниз
// Нет гравитации, свободное перемещение

use ultraviolet::Vec3;

/// Режим передвижения игрока
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MovementMode {
    /// Обычная ходьба с гравитацией
    Walking,
    /// Полёт (креатив)
    Flying,
}

/// Контроллер полёта
pub struct FlightController {
    /// Текущий режим
    pub mode: MovementMode,
    
    /// Скорость полёта
    pub fly_speed: f32,
    
    /// Скорость быстрого полёта (с Ctrl)
    pub fast_fly_speed: f32,
    
    /// Вертикальная скорость полёта
    pub vertical_speed: f32,
    
    /// Клавиша вверх (Space)
    pub up: bool,
    
    /// Клавиша вниз (Shift/Ctrl в полёте)
    pub down: bool,
}

impl FlightController {
    pub fn new() -> Self {
        Self {
            mode: MovementMode::Walking,
            fly_speed: 12.0,
            fast_fly_speed: 480.0, // x40 от базовой скорости полёта
            vertical_speed: 10.0,
            up: false,
            down: false,
        }
    }
    
    /// Переключить режим полёта
    pub fn toggle_flight(&mut self) {
        self.mode = match self.mode {
            MovementMode::Walking => {
                MovementMode::Flying
            }
            MovementMode::Flying => {
                MovementMode::Walking
            }
        };
    }
    
    /// Проверка режима полёта
    pub fn is_flying(&self) -> bool {
        self.mode == MovementMode::Flying
    }
    
    /// Обработка клавиш для полёта
    pub fn process_keyboard(&mut self, key: winit::keyboard::KeyCode, pressed: bool) -> bool {
        use winit::keyboard::KeyCode;
        
        match key {
            KeyCode::KeyF if pressed => {
                self.toggle_flight();
                true // Обработано
            }
            KeyCode::Space => {
                self.up = pressed;
                false // Пусть основной контроллер тоже обработает (для прыжка)
            }
            KeyCode::ShiftLeft | KeyCode::ControlLeft => {
                self.down = pressed;
                false // Пусть основной контроллер тоже обработает (для спринта)
            }
            _ => false,
        }
    }
    
    /// Вычислить вертикальную скорость в режиме полёта
    pub fn get_vertical_velocity(&self) -> f32 {
        if !self.is_flying() {
            return 0.0;
        }
        
        let mut vy = 0.0;
        if self.up {
            vy += self.vertical_speed;
        }
        if self.down {
            vy -= self.vertical_speed;
        }
        vy
    }
    
    /// Получить скорость передвижения (с учётом быстрого полёта)
    pub fn get_fly_speed(&self, is_fast: bool) -> f32 {
        if is_fast {
            self.fast_fly_speed
        } else {
            self.fly_speed
        }
    }
}

impl Default for FlightController {
    fn default() -> Self {
        Self::new()
    }
}


============================================================
FILE: player\mod.rs
============================================================

// ============================================
// Player Module - Игрок и камера
// ============================================

mod player;
mod player_model;
mod camera;
mod flight;

pub use player::*;
pub use player_model::*;
pub use camera::*;
pub use flight::*;


============================================================
FILE: player\player.rs
============================================================


// ============================================
// Player Entity - Физическая сущность игрока
// ============================================
// Хранит позицию ног, обрабатывает физику и ввод.
// Является центром мира для генерации чанков.

use ultraviolet::Vec3;
use super::flight::FlightController;

/// Константы игрока
pub const PLAYER_HEIGHT: f32 = 1.8;      // Полная высота игрока
pub const EYE_HEIGHT: f32 = 1.62;        // Высота глаз от ног
pub const PLAYER_RADIUS: f32 = 0.3;      // Радиус хитбокса (половина ширины)
pub const GRAVITY: f32 = 28.0;           // Ускорение свободного падения
pub const JUMP_VELOCITY: f32 = 9.0;      // Начальная скорость прыжка
pub const TERMINAL_VELOCITY: f32 = 50.0; // Максимальная скорость падения

/// Игрок — физическая сущность в мире
pub struct Player {
    /// Позиция ног (нижняя точка хитбокса)
    pub position: Vec3,
    
    /// Скорость (для физики)
    pub velocity: Vec3,
    
    /// Горизонтальный угол поворота тела (yaw)
    pub yaw: f32,
    
    /// Вертикальный угол головы (pitch)
    pub pitch: f32,
    
    /// На земле ли игрок
    pub on_ground: bool,
    
    /// Скорость передвижения
    pub move_speed: f32,
    
    /// Скорость бега (shift)
    pub sprint_speed: f32,
    
    /// Сейчас бежит
    pub is_sprinting: bool,
}

impl Player {
    pub fn new(x: f32, y: f32, z: f32) -> Self {
        Self {
            position: Vec3::new(x, y, z),
            velocity: Vec3::zero(),
            yaw: 0.0,
            pitch: 0.0,
            on_ground: false,
            move_speed: 5.0,
            sprint_speed: 8.0,
            is_sprinting: false,
        }
    }
    
    /// Позиция глаз (для камеры от первого лица)
    pub fn eye_position(&self) -> Vec3 {
        Vec3::new(
            self.position.x,
            self.position.y + EYE_HEIGHT,
            self.position.z,
        )
    }
    
    /// Центр тела (для рендеринга модели)
    pub fn body_center(&self) -> Vec3 {
        Vec3::new(
            self.position.x,
            self.position.y + PLAYER_HEIGHT * 0.5,
            self.position.z,
        )
    }
    
    /// Направление взгляда (forward vector)
    pub fn forward(&self) -> Vec3 {
        Vec3::new(
            self.yaw.cos() * self.pitch.cos(),
            self.pitch.sin(),
            self.yaw.sin() * self.pitch.cos(),
        ).normalized()
    }
    
    /// Горизонтальное направление движения (без pitch)
    pub fn forward_horizontal(&self) -> Vec3 {
        Vec3::new(
            self.yaw.cos(),
            0.0,
            self.yaw.sin(),
        ).normalized()
    }
    
    /// Вектор вправо
    pub fn right(&self) -> Vec3 {
        self.forward().cross(Vec3::unit_y()).normalized()
    }
    
    /// Горизонтальный вектор вправо
    pub fn right_horizontal(&self) -> Vec3 {
        self.forward_horizontal().cross(Vec3::unit_y()).normalized()
    }
}

/// Тип функции проверки твёрдости блока
/// Принимает (x, y, z) и возвращает true если блок твёрдый
pub type BlockSolidChecker = Box<dyn Fn(i32, i32, i32, &std::collections::HashMap<crate::gpu::terrain::BlockPos, crate::gpu::blocks::BlockType>) -> bool + Send + Sync>;

/// Тип функции проверки коллизии с суб-вокселями
/// Принимает AABB игрока (min_x, min_y, min_z, max_x, max_y, max_z) и возвращает true если есть коллизия
pub type SubVoxelCollisionChecker = Box<dyn Fn(f32, f32, f32, f32, f32, f32) -> bool + Send + Sync>;

/// Контроллер игрока — обрабатывает ввод и физику
pub struct PlayerController {
    // Состояние клавиш движения
    pub forward: bool,
    pub backward: bool,
    pub left: bool,
    pub right: bool,
    pub jump: bool,
    pub sprint: bool,
    
    // Дельта мыши
    mouse_dx: f32,
    mouse_dy: f32,
    
    // Чувствительность мыши
    pub sensitivity: f32,
    
    // Контроллер полёта
    pub flight: FlightController,
    
    // Функция проверки твёрдости блока
    block_solid_checker: Option<BlockSolidChecker>,
    
    // Функция проверки коллизии с суб-вокселями
    subvoxel_collision_checker: Option<SubVoxelCollisionChecker>,
}

impl PlayerController {
    pub fn new(sensitivity: f32) -> Self {
        Self {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            sprint: false,
            mouse_dx: 0.0,
            mouse_dy: 0.0,
            sensitivity,
            flight: FlightController::new(),
            block_solid_checker: None,
            subvoxel_collision_checker: None,
        }
    }
    
    /// Установить функцию проверки твёрдости блока
    pub fn set_block_solid_checker<F>(&mut self, f: F)
    where
        F: Fn(i32, i32, i32, &std::collections::HashMap<crate::gpu::terrain::BlockPos, crate::gpu::blocks::BlockType>) -> bool + Send + Sync + 'static,
    {
        self.block_solid_checker = Some(Box::new(f));
    }
    
    /// Установить функцию проверки коллизии с суб-вокселями
    pub fn set_subvoxel_collision_checker<F>(&mut self, f: F)
    where
        F: Fn(f32, f32, f32, f32, f32, f32) -> bool + Send + Sync + 'static,
    {
        self.subvoxel_collision_checker = Some(Box::new(f));
    }
    
    /// Проверить твёрдость блока
    fn is_block_solid(&self, x: i32, y: i32, z: i32, world_changes: &std::collections::HashMap<crate::gpu::terrain::BlockPos, crate::gpu::blocks::BlockType>) -> bool {
        if let Some(ref checker) = self.block_solid_checker {
            checker(x, y, z, world_changes)
        } else {
            false
        }
    }
    
    /// Проверить коллизию с суб-вокселями
    fn check_subvoxel_collision(&self, min_x: f32, min_y: f32, min_z: f32, max_x: f32, max_y: f32, max_z: f32) -> bool {
        if let Some(ref checker) = self.subvoxel_collision_checker {
            checker(min_x, min_y, min_z, max_x, max_y, max_z)
        } else {
            false
        }
    }
    
    /// Проверить коллизию хитбокса игрока с миром
    fn check_collision(&self, pos: Vec3, world_changes: &std::collections::HashMap<crate::gpu::terrain::BlockPos, crate::gpu::blocks::BlockType>) -> bool {
        // AABB игрока
        let p_min_x = pos.x - PLAYER_RADIUS;
        let p_max_x = pos.x + PLAYER_RADIUS;
        let p_min_y = pos.y;
        let p_max_y = pos.y + PLAYER_HEIGHT - 0.01;
        let p_min_z = pos.z - PLAYER_RADIUS;
        let p_max_z = pos.z + PLAYER_RADIUS;
        
        // Проверяем коллизию с суб-вокселями
        if self.check_subvoxel_collision(p_min_x, p_min_y, p_min_z, p_max_x, p_max_y, p_max_z) {
            return true;
        }
        
        // Проверяем все блоки, которые пересекает хитбокс игрока
        let min_x = p_min_x.floor() as i32;
        let max_x = p_max_x.floor() as i32;
        let min_y = p_min_y.floor() as i32;
        let max_y = p_max_y.floor() as i32;
        let min_z = p_min_z.floor() as i32;
        let max_z = p_max_z.floor() as i32;
        
        for bx in min_x..=max_x {
            for by in min_y..=max_y {
                for bz in min_z..=max_z {
                    if self.is_block_solid(bx, by, bz, world_changes) {
                        return true;
                    }
                }
            }
        }
        false
    }
    
    /// Обработка клавиатуры
    pub fn process_keyboard(&mut self, key: winit::keyboard::KeyCode, pressed: bool) {
        use winit::keyboard::KeyCode;
        
        // Сначала проверяем контроллер полёта
        self.flight.process_keyboard(key, pressed);
        
        match key {
            KeyCode::KeyW => self.forward = pressed,
            KeyCode::KeyS => self.backward = pressed,
            KeyCode::KeyA => self.left = pressed,
            KeyCode::KeyD => self.right = pressed,
            KeyCode::Space => self.jump = pressed,
            KeyCode::ControlLeft => self.sprint = pressed,
            KeyCode::ShiftLeft => self.sprint = pressed, // Shift тоже для спринта
            _ => {}
        }
    }
    
    /// Обработка мыши
    pub fn process_mouse(&mut self, dx: f64, dy: f64) {
        self.mouse_dx = dx as f32;
        self.mouse_dy = dy as f32;
    }
    
    /// Обновление игрока
    pub fn update(&mut self, player: &mut Player, dt: f32, world_changes: &std::collections::HashMap<crate::gpu::terrain::BlockPos, crate::gpu::blocks::BlockType>) {
        // === Вращение от мыши ===
        player.yaw += self.mouse_dx * self.sensitivity * dt;
        player.pitch -= self.mouse_dy * self.sensitivity * dt;
        
        // Ограничение pitch (не даём перевернуться)
        player.pitch = player.pitch.clamp(-1.5, 1.5);
        
        // Сброс дельты мыши
        self.mouse_dx = 0.0;
        self.mouse_dy = 0.0;
        
        // === Движение ===
        let forward = player.forward_horizontal();
        let right = player.right_horizontal();
        
        let mut move_dir = Vec3::zero();
        
        if self.forward { move_dir += forward; }
        if self.backward { move_dir -= forward; }
        if self.right { move_dir += right; }
        if self.left { move_dir -= right; }
        
        // Нормализуем если есть движение
        if move_dir.mag_sq() > 0.0 {
            move_dir = move_dir.normalized();
        }
        
        // === Режим полёта ===
        if self.flight.is_flying() {
            // Скорость полёта
            let speed = self.flight.get_fly_speed(self.sprint);
            
            // Горизонтальная скорость
            player.velocity.x = move_dir.x * speed;
            player.velocity.z = move_dir.z * speed;
            
            // Вертикальная скорость (Space вверх, Shift/Ctrl вниз)
            player.velocity.y = self.flight.get_vertical_velocity();
            
            // Применяем скорость
            player.position += player.velocity * dt;
            
            // В полёте всегда "на земле" для анимаций
            player.on_ground = false;
        } else {
            // === Обычная ходьба с гравитацией ===
            
            // Скорость (бег или ходьба)
            player.is_sprinting = self.sprint && self.forward;
            let speed = if player.is_sprinting {
                player.sprint_speed
            } else {
                player.move_speed
            };
            
            // Горизонтальная скорость
            player.velocity.x = move_dir.x * speed;
            player.velocity.z = move_dir.z * speed;
            
            // === Гравитация и прыжок ===
            if player.on_ground {
                if self.jump {
                    player.velocity.y = JUMP_VELOCITY;
                    player.on_ground = false;
                } else {
                    player.velocity.y = 0.0;
                }
            } else {
                // Применяем гравитацию
                player.velocity.y -= GRAVITY * dt;
                player.velocity.y = player.velocity.y.max(-TERMINAL_VELOCITY);
            }
            
            // === Применяем движение с коллизиями ===
            self.move_with_collision(player, dt, world_changes);
        }
    }
    
    /// Движение с проверкой коллизий (раздельно по осям)
    fn move_with_collision(&self, player: &mut Player, dt: f32, world_changes: &std::collections::HashMap<crate::gpu::terrain::BlockPos, crate::gpu::blocks::BlockType>) {
        let old_pos = player.position;
        
        // === Движение по X ===
        let new_x = old_pos.x + player.velocity.x * dt;
        let test_pos_x = Vec3::new(new_x, old_pos.y, old_pos.z);
        
        if !self.check_collision(test_pos_x, world_changes) {
            player.position.x = new_x;
        } else {
            player.velocity.x = 0.0;
        }
        
        // === Движение по Z ===
        let new_z = old_pos.z + player.velocity.z * dt;
        let test_pos_z = Vec3::new(player.position.x, old_pos.y, new_z);
        
        if !self.check_collision(test_pos_z, world_changes) {
            player.position.z = new_z;
        } else {
            player.velocity.z = 0.0;
        }
        
        // === Движение по Y ===
        let new_y = old_pos.y + player.velocity.y * dt;
        let test_pos_y = Vec3::new(player.position.x, new_y, player.position.z);
        
        if !self.check_collision(test_pos_y, world_changes) {
            player.position.y = new_y;
            player.on_ground = false;
        } else {
            // Столкнулись с чем-то
            if player.velocity.y < 0.0 {
                // Падали вниз - приземлились
                player.on_ground = true;
                // Выравниваем на верх блока
                player.position.y = (old_pos.y.floor() as i32) as f32;
                // Проверяем, не застряли ли
                if self.check_collision(player.position, world_changes) {
                    player.position.y = old_pos.y;
                }
            }
            player.velocity.y = 0.0;
        }
        
        // Дополнительная проверка on_ground (стоим ли на блоке)
        if !player.on_ground {
            let below = Vec3::new(player.position.x, player.position.y - 0.05, player.position.z);
            player.on_ground = self.check_collision(below, world_changes);
        }
    }
}


============================================================
FILE: player\player.wgsl
============================================================

// ============================================
// Player Model Shader
// ============================================
// Шейдер для рендеринга модели игрока в режиме 3-го лица

struct Uniforms {
    view_proj: mat4x4<f32>,
    camera_pos: vec3<f32>,
    time: f32,
}

struct ModelMatrix {
    model: mat4x4<f32>,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(1) @binding(0)
var<uniform> model: ModelMatrix;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) color: vec3<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) world_pos: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) color: vec3<f32>,
}

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    
    // Применяем матрицу модели (позиция + поворот игрока)
    let world_pos = model.model * vec4<f32>(in.position, 1.0);
    
    out.clip_position = uniforms.view_proj * world_pos;
    out.world_pos = world_pos.xyz;
    
    // Трансформируем нормаль (только поворот, без масштаба)
    let normal_matrix = mat3x3<f32>(
        model.model[0].xyz,
        model.model[1].xyz,
        model.model[2].xyz
    );
    out.normal = normalize(normal_matrix * in.normal);
    out.color = in.color;
    
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    // Направление света (солнце)
    let light_dir = normalize(vec3<f32>(0.4, 0.8, 0.3));
    let ndotl = max(dot(in.normal, light_dir), 0.0);
    
    // Освещение граней (как у блоков)
    var face_light = 1.0;
    if (in.normal.y > 0.5) { 
        face_light = 1.0; 
    } else if (abs(in.normal.x) > 0.5) { 
        face_light = 0.8; 
    } else { 
        face_light = 0.7; 
    }
    
    // Ambient + diffuse
    let ambient = 0.4;
    let diffuse = ndotl * 0.6;
    let lighting = (ambient + diffuse) * face_light;
    
    var color = in.color * lighting;
    
    // Лёгкий rim light для выделения силуэта
    let view_dir = normalize(uniforms.camera_pos - in.world_pos);
    let rim = 1.0 - max(dot(view_dir, in.normal), 0.0);
    let rim_intensity = pow(rim, 3.0) * 0.15;
    color += vec3<f32>(rim_intensity);
    
    // Туман (как у террейна)
    let dist = length(in.world_pos.xz - uniforms.camera_pos.xz);
    let fog_color = vec3<f32>(0.7, 0.8, 0.9);
    let fog_factor = smoothstep(800.0, 1000.0, dist);
    
    color = mix(color, fog_color, fog_factor);
    
    return vec4<f32>(color, 1.0);
}


============================================================
FILE: player\player_model.rs
============================================================

// ============================================
// Player Model - Меш и рендеринг модели игрока
// ============================================
// Простая модель игрока (куб/капсула) для режима 3-го лица

use bytemuck::{Pod, Zeroable};
use std::sync::Arc;
use wgpu::util::DeviceExt;
use ultraviolet::{Mat4, Vec3};

use super::player::{Player, PLAYER_HEIGHT, PLAYER_RADIUS};

/// Вершина модели игрока (такая же как TerrainVertex для совместимости)
#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct PlayerVertex {
    pub position: [f32; 3],
    pub normal: [f32; 3],
    pub color: [f32; 3],
}

impl PlayerVertex {
    pub fn desc() -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<PlayerVertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                wgpu::VertexAttribute {
                    offset: 0,
                    shader_location: 0,
                    format: wgpu::VertexFormat::Float32x3,
                },
                wgpu::VertexAttribute {
                    offset: 12,
                    shader_location: 1,
                    format: wgpu::VertexFormat::Float32x3,
                },
                wgpu::VertexAttribute {
                    offset: 24,
                    shader_location: 2,
                    format: wgpu::VertexFormat::Float32x3,
                },
            ],
        }
    }
}

/// Генератор меша игрока
pub struct PlayerMeshGenerator;

impl PlayerMeshGenerator {
    /// Создать меш куба (простейшая модель)
    pub fn create_cube_mesh() -> (Vec<PlayerVertex>, Vec<u32>) {
        let half_w = PLAYER_RADIUS; // Радиус = половина ширины
        let height = PLAYER_HEIGHT;
        
        // Цвета частей тела
        let body_color = [0.2, 0.4, 0.8];   // Синий (тело)
        let head_color = [0.9, 0.75, 0.6];  // Телесный (голова)
        let leg_color = [0.3, 0.3, 0.5];    // Тёмно-синий (ноги)
        
        let mut vertices = Vec::new();
        let mut indices = Vec::new();
        
        // === Тело (центральный куб) ===
        let body_bottom = 0.4;
        let body_top = 1.4;
        Self::add_box(
            &mut vertices, &mut indices,
            -half_w, body_bottom, -half_w * 0.6,
            half_w, body_top, half_w * 0.6,
            body_color,
        );
        
        // === Голова ===
        let head_size = 0.35;
        let head_bottom = body_top;
        let head_top = head_bottom + head_size * 2.0;
        Self::add_box(
            &mut vertices, &mut indices,
            -head_size, head_bottom, -head_size,
            head_size, head_top, head_size,
            head_color,
        );
        
        // === Ноги ===
        let leg_width = half_w * 0.4;
        let leg_gap = 0.02;
        
        // Левая нога
        Self::add_box(
            &mut vertices, &mut indices,
            -half_w, 0.0, -leg_width,
            -leg_gap, body_bottom, leg_width,
            leg_color,
        );
        
        // Правая нога
        Self::add_box(
            &mut vertices, &mut indices,
            leg_gap, 0.0, -leg_width,
            half_w, body_bottom, leg_width,
            leg_color,
        );
        
        // === Руки ===
        let arm_width = 0.12;
        let arm_length = 0.6;
        let arm_top = body_top - 0.1;
        let arm_bottom = arm_top - arm_length;
        
        // Левая рука
        Self::add_box(
            &mut vertices, &mut indices,
            -half_w - arm_width, arm_bottom, -arm_width,
            -half_w, arm_top, arm_width,
            body_color,
        );
        
        // Правая рука
        Self::add_box(
            &mut vertices, &mut indices,
            half_w, arm_bottom, -arm_width,
            half_w + arm_width, arm_top, arm_width,
            body_color,
        );
        
        (vertices, indices)
    }
    
    /// Добавить куб (box) в меш
    fn add_box(
        vertices: &mut Vec<PlayerVertex>,
        indices: &mut Vec<u32>,
        x0: f32, y0: f32, z0: f32,
        x1: f32, y1: f32, z1: f32,
        color: [f32; 3],
    ) {
        let base_idx = vertices.len() as u32;
        
        // 8 вершин куба
        let corners = [
            [x0, y0, z0], // 0: left-bottom-back
            [x1, y0, z0], // 1: right-bottom-back
            [x1, y1, z0], // 2: right-top-back
            [x0, y1, z0], // 3: left-top-back
            [x0, y0, z1], // 4: left-bottom-front
            [x1, y0, z1], // 5: right-bottom-front
            [x1, y1, z1], // 6: right-top-front
            [x0, y1, z1], // 7: left-top-front
        ];
        
        // 6 граней с нормалями
        let faces = [
            // Back face (Z-)
            ([0, 1, 2, 3], [0.0, 0.0, -1.0]),
            // Front face (Z+)
            ([5, 4, 7, 6], [0.0, 0.0, 1.0]),
            // Left face (X-)
            ([4, 0, 3, 7], [-1.0, 0.0, 0.0]),
            // Right face (X+)
            ([1, 5, 6, 2], [1.0, 0.0, 0.0]),
            // Bottom face (Y-)
            ([4, 5, 1, 0], [0.0, -1.0, 0.0]),
            // Top face (Y+)
            ([3, 2, 6, 7], [0.0, 1.0, 0.0]),
        ];
        
        for (face_indices, normal) in faces {
            let face_base = vertices.len() as u32;
            
            for &corner_idx in &face_indices {
                vertices.push(PlayerVertex {
                    position: corners[corner_idx],
                    normal,
                    color,
                });
            }
            
            // Два треугольника на грань
            indices.push(face_base);
            indices.push(face_base + 1);
            indices.push(face_base + 2);
            
            indices.push(face_base);
            indices.push(face_base + 2);
            indices.push(face_base + 3);
        }
    }
}

/// GPU буферы модели игрока
pub struct PlayerModel {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    index_count: u32,
    
    // Uniform буфер для матрицы модели
    model_buffer: wgpu::Buffer,
    model_bind_group: wgpu::BindGroup,
}

impl PlayerModel {
    pub fn new(
        device: &wgpu::Device,
        bind_group_layout: &wgpu::BindGroupLayout,
    ) -> Self {
        let (vertices, indices) = PlayerMeshGenerator::create_cube_mesh();
        
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Player Vertex Buffer"),
            contents: bytemuck::cast_slice(&vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });
        
        let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Player Index Buffer"),
            contents: bytemuck::cast_slice(&indices),
            usage: wgpu::BufferUsages::INDEX,
        });
        
        // Матрица модели (identity изначально)
        let model_matrix: [[f32; 4]; 4] = Mat4::identity().into();
        let model_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Player Model Buffer"),
            contents: bytemuck::cast_slice(&model_matrix),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });
        
        let model_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Player Model Bind Group"),
            layout: bind_group_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: model_buffer.as_entire_binding(),
            }],
        });
        
        Self {
            vertex_buffer,
            index_buffer,
            index_count: indices.len() as u32,
            model_buffer,
            model_bind_group,
        }
    }
    
    /// Обновить матрицу модели на основе позиции игрока
    pub fn update(&self, queue: &wgpu::Queue, player: &Player) {
        // Матрица трансформации: перемещение + поворот по yaw
        let translation = Mat4::from_translation(player.position);
        let rotation = Mat4::from_rotation_y(player.yaw);
        let model_matrix = translation * rotation;
        
        let matrix_data: [[f32; 4]; 4] = model_matrix.into();
        queue.write_buffer(&self.model_buffer, 0, bytemuck::cast_slice(&matrix_data));
    }
    
    /// Рендеринг модели
    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
        render_pass.set_bind_group(1, &self.model_bind_group, &[]);
        render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        render_pass.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
        render_pass.draw_indexed(0..self.index_count, 0, 0..1);
    }
    
    /// Создать bind group layout для матрицы модели
    pub fn create_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
        device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Player Model Bind Group Layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        })
    }
}


============================================================
FILE: render\bind_groups.rs
============================================================

use wgpu::util::DeviceExt;

pub struct BindGroupLayouts {
    pub uniform: wgpu::BindGroupLayout,
    pub light: wgpu::BindGroupLayout,
    pub shadow: wgpu::BindGroupLayout,
    pub shadow_pass: wgpu::BindGroupLayout,
    pub atlas: wgpu::BindGroupLayout,
}

impl BindGroupLayouts {
    pub fn new(device: &wgpu::Device) -> Self {
        let uniform = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Uniform Layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });

        let light = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Light Layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });

        let shadow = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Shadow Layout"),
            entries: &[
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        sample_type: wgpu::TextureSampleType::Depth,
                        view_dimension: wgpu::TextureViewDimension::D2Array,
                        multisampled: false,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Comparison),
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                },
            ],
        });

        let shadow_pass = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Shadow Pass Layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            }],
        });

        // Текстурный атлас для кастомных блоков
        let atlas = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("Atlas Layout"),
            entries: &[
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                        view_dimension: wgpu::TextureViewDimension::D2,
                        multisampled: false,
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
            ],
        });

        Self {
            uniform,
            light,
            shadow,
            shadow_pass,
            atlas,
        }
    }
}

pub struct CoreBindGroups {
    pub uniform_buffer: wgpu::Buffer,
    pub uniform_bind_group: wgpu::BindGroup,
    pub light_buffer: wgpu::Buffer,
    pub light_bind_group: wgpu::BindGroup,
}

impl CoreBindGroups {
    pub fn new(device: &wgpu::Device, layouts: &BindGroupLayouts) -> Self {
        use super::uniforms::{Uniforms, LightUniform};

        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Uniform Buffer"),
            contents: bytemuck::cast_slice(&[Uniforms::new()]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        let light_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Light Buffer"),
            contents: bytemuck::cast_slice(&[LightUniform::default()]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        let uniform_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Uniform BG"),
            layout: &layouts.uniform,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: uniform_buffer.as_entire_binding(),
            }],
        });

        let light_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Light BG"),
            layout: &layouts.light,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: light_buffer.as_entire_binding(),
            }],
        });

        Self {
            uniform_buffer,
            uniform_bind_group,
            light_buffer,
            light_bind_group,
        }
    }
}

/// Ресурсы текстурного атласа для кастомных блоков
pub struct AtlasResources {
    pub texture: wgpu::Texture,
    pub view: wgpu::TextureView,
    pub sampler: wgpu::Sampler,
    pub bind_group: wgpu::BindGroup,
}

impl AtlasResources {
    pub fn new(device: &wgpu::Device, queue: &wgpu::Queue, layout: &wgpu::BindGroupLayout) -> Self {
        use crate::gpu::blocks::texture_atlas::{BlockTextureAtlas, ATLAS_PIXELS};
        
        // Генерируем атлас из реестра блоков
        let atlas = BlockTextureAtlas::from_registry();
        
        // Создаём GPU текстуру
        let texture = device.create_texture(&wgpu::TextureDescriptor {
            label: Some("Block Atlas Texture"),
            size: wgpu::Extent3d {
                width: ATLAS_PIXELS,
                height: ATLAS_PIXELS,
                depth_or_array_layers: 1,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Rgba8UnormSrgb,
            usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
            view_formats: &[],
        });
        
        // Загружаем данные атласа в текстуру
        queue.write_texture(
            wgpu::TexelCopyTextureInfo {
                texture: &texture,
                mip_level: 0,
                origin: wgpu::Origin3d::ZERO,
                aspect: wgpu::TextureAspect::All,
            },
            &atlas.data,
            wgpu::TexelCopyBufferLayout {
                offset: 0,
                bytes_per_row: Some(ATLAS_PIXELS * 4),
                rows_per_image: Some(ATLAS_PIXELS),
            },
            wgpu::Extent3d {
                width: ATLAS_PIXELS,
                height: ATLAS_PIXELS,
                depth_or_array_layers: 1,
            },
        );
        
        let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
        
        // Nearest-neighbor сэмплер для пиксельного стиля
        let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
            label: Some("Atlas Sampler"),
            address_mode_u: wgpu::AddressMode::ClampToEdge,
            address_mode_v: wgpu::AddressMode::ClampToEdge,
            address_mode_w: wgpu::AddressMode::ClampToEdge,
            mag_filter: wgpu::FilterMode::Nearest,
            min_filter: wgpu::FilterMode::Nearest,
            mipmap_filter: wgpu::FilterMode::Nearest,
            ..Default::default()
        });
        
        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Atlas Bind Group"),
            layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&sampler),
                },
            ],
        });
        
        Self {
            texture,
            view,
            sampler,
            bind_group,
        }
    }
}


============================================================
FILE: render\depth.rs
============================================================

pub fn create_depth_texture(
    device: &wgpu::Device,
    config: &wgpu::SurfaceConfiguration,
) -> wgpu::TextureView {
    device
        .create_texture(&wgpu::TextureDescriptor {
            label: Some("Depth"),
            size: wgpu::Extent3d {
                width: config.width,
                height: config.height,
                depth_or_array_layers: 1,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Depth32Float,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
            view_formats: &[],
        })
        .create_view(&wgpu::TextureViewDescriptor::default())
}


============================================================
FILE: render\mod.rs
============================================================

// ============================================
// GPU Render Module - Modular rendering system
// ============================================

mod uniforms;
mod shadow;
mod pipelines;
mod bind_groups;
mod depth;
mod renderer;

pub use renderer::Renderer;


============================================================
FILE: render\pipelines.rs
============================================================

use crate::gpu::terrain::TerrainVertex;
use crate::gpu::player::PlayerVertex;

use super::bind_groups::BindGroupLayouts;

pub struct Pipelines {
    pub terrain: wgpu::RenderPipeline,
    pub shadow: wgpu::RenderPipeline,
    pub player: wgpu::RenderPipeline,
}

impl Pipelines {
    pub fn new(
        device: &wgpu::Device,
        surface_format: wgpu::TextureFormat,
        layouts: &BindGroupLayouts,
        model_layout: &wgpu::BindGroupLayout,
    ) -> Self {
        let terrain_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Terrain Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("../shaders/terrain_shadows.wgsl").into()),
        });

        let shadow_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Shadow Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("../lighting/shadow.wgsl").into()),
        });

        let player_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("Player Shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("../player/player.wgsl").into()),
        });

        let terrain_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Terrain Layout"),
            bind_group_layouts: &[&layouts.uniform, &layouts.light, &layouts.shadow, &layouts.atlas],
            push_constant_ranges: &[],
        });

        let shadow_pl_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Shadow PL Layout"),
            bind_group_layouts: &[&layouts.shadow_pass],
            push_constant_ranges: &[],
        });

        let player_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Player Layout"),
            bind_group_layouts: &[&layouts.uniform, model_layout],
            push_constant_ranges: &[],
        });

        let terrain = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Terrain Pipeline"),
            layout: Some(&terrain_layout),
            vertex: wgpu::VertexState {
                module: &terrain_shader,
                entry_point: Some("vs_main"),
                buffers: &[TerrainVertex::desc()],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &terrain_shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format: surface_format,
                    blend: Some(wgpu::BlendState::REPLACE),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleList,
                front_face: wgpu::FrontFace::Ccw,
                cull_mode: Some(wgpu::Face::Back),
                ..Default::default()
            },
            depth_stencil: Some(wgpu::DepthStencilState {
                format: wgpu::TextureFormat::Depth32Float,
                depth_write_enabled: true,
                depth_compare: wgpu::CompareFunction::Greater, // Reversed-Z
                stencil: Default::default(),
                bias: Default::default(),
            }),
            multisample: wgpu::MultisampleState {
                count: 1,
                mask: !0,
                alpha_to_coverage_enabled: false,
            },
            multiview: None,
            cache: None,
        });

        let shadow = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Shadow Pipeline"),
            layout: Some(&shadow_pl_layout),
            vertex: wgpu::VertexState {
                module: &shadow_shader,
                entry_point: Some("vs_main"),
                buffers: &[TerrainVertex::desc()],
                compilation_options: Default::default(),
            },
            fragment: None,
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleList,
                front_face: wgpu::FrontFace::Ccw,
                cull_mode: Some(wgpu::Face::Back),
                ..Default::default()
            },
            depth_stencil: Some(wgpu::DepthStencilState {
                format: wgpu::TextureFormat::Depth32Float,
                depth_write_enabled: true,
                depth_compare: wgpu::CompareFunction::Less, // Shadow pass остаётся Less
                stencil: Default::default(),
                bias: wgpu::DepthBiasState {
                    constant: 4,
                    slope_scale: 2.0,
                    clamp: 0.0,
                },
            }),
            multisample: Default::default(),
            multiview: None,
            cache: None,
        });

        let player = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Player Pipeline"),
            layout: Some(&player_layout),
            vertex: wgpu::VertexState {
                module: &player_shader,
                entry_point: Some("vs_main"),
                buffers: &[PlayerVertex::desc()],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &player_shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format: surface_format,
                    blend: Some(wgpu::BlendState::REPLACE),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleList,
                front_face: wgpu::FrontFace::Ccw,
                cull_mode: Some(wgpu::Face::Back),
                ..Default::default()
            },
            depth_stencil: Some(wgpu::DepthStencilState {
                format: wgpu::TextureFormat::Depth32Float,
                depth_write_enabled: true,
                depth_compare: wgpu::CompareFunction::Greater, // Reversed-Z
                stencil: Default::default(),
                bias: Default::default(),
            }),
            multisample: wgpu::MultisampleState {
                count: 1,
                mask: !0,
                alpha_to_coverage_enabled: false,
            },
            multiview: None,
            cache: None,
        });

        Self {
            terrain,
            shadow,
            player,
        }
    }
}


============================================================
FILE: render\shadow.rs
============================================================

use wgpu::util::DeviceExt;
use ultraviolet::{Vec3, Mat4};

use super::uniforms::ShadowUniform;
use crate::gpu::lighting::{CascadeConfig, DayNightCycle};

pub struct ShadowResources {
    pub texture: wgpu::Texture,
    pub views: Vec<wgpu::TextureView>,
    pub array_view: wgpu::TextureView,
    pub sampler: wgpu::Sampler,
    pub uniform_buffer: wgpu::Buffer,
    pub bind_group: wgpu::BindGroup,
    pub pass_buffers: Vec<wgpu::Buffer>,
    pub pass_bind_groups: Vec<wgpu::BindGroup>,
    pub config: CascadeConfig,
    pub uniform: ShadowUniform,
}

impl ShadowResources {
    pub fn new(
        device: &wgpu::Device,
        shadow_layout: &wgpu::BindGroupLayout,
        shadow_pass_layout: &wgpu::BindGroupLayout,
    ) -> Self {
        let config = CascadeConfig::large_world();
        let num_cascades = config.num_cascades as u32;
        let shadow_res = config.resolution;

        let texture = device.create_texture(&wgpu::TextureDescriptor {
            label: Some("Shadow Map Array"),
            size: wgpu::Extent3d {
                width: shadow_res,
                height: shadow_res,
                depth_or_array_layers: num_cascades,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Depth32Float,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
            view_formats: &[],
        });

        let views: Vec<_> = (0..num_cascades)
            .map(|i| {
                texture.create_view(&wgpu::TextureViewDescriptor {
                    label: Some(&format!("Shadow Layer {}", i)),
                    format: Some(wgpu::TextureFormat::Depth32Float),
                    dimension: Some(wgpu::TextureViewDimension::D2),
                    aspect: wgpu::TextureAspect::DepthOnly,
                    base_array_layer: i,
                    array_layer_count: Some(1),
                    ..Default::default()
                })
            })
            .collect();

        let array_view = texture.create_view(&wgpu::TextureViewDescriptor {
            label: Some("Shadow Array View"),
            format: Some(wgpu::TextureFormat::Depth32Float),
            dimension: Some(wgpu::TextureViewDimension::D2Array),
            aspect: wgpu::TextureAspect::DepthOnly,
            base_array_layer: 0,
            array_layer_count: Some(num_cascades),
            ..Default::default()
        });

        let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
            label: Some("Shadow Sampler"),
            address_mode_u: wgpu::AddressMode::ClampToEdge,
            address_mode_v: wgpu::AddressMode::ClampToEdge,
            address_mode_w: wgpu::AddressMode::ClampToEdge,
            mag_filter: wgpu::FilterMode::Linear,
            min_filter: wgpu::FilterMode::Linear,
            compare: Some(wgpu::CompareFunction::LessEqual),
            ..Default::default()
        });

        let uniform = ShadowUniform::default();
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Shadow Uniform"),
            contents: bytemuck::cast_slice(&[uniform]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("Shadow BG"),
            layout: shadow_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&array_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&sampler),
                },
                wgpu::BindGroupEntry {
                    binding: 2,
                    resource: uniform_buffer.as_entire_binding(),
                },
            ],
        });

        let pass_buffers: Vec<_> = (0..num_cascades)
            .map(|i| {
                device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
                    label: Some(&format!("Shadow Pass {}", i)),
                    contents: bytemuck::cast_slice(&[[[0.0f32; 4]; 4]]),
                    usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
                })
            })
            .collect();

        let pass_bind_groups: Vec<_> = pass_buffers
            .iter()
            .enumerate()
            .map(|(i, buf)| {
                device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(&format!("Shadow Pass BG {}", i)),
                    layout: shadow_pass_layout,
                    entries: &[wgpu::BindGroupEntry {
                        binding: 0,
                        resource: buf.as_entire_binding(),
                    }],
                })
            })
            .collect();

        println!("CSM Shadows: {} cascades @ {}x{}", num_cascades, shadow_res, shadow_res);

        Self {
            texture,
            views,
            array_view,
            sampler,
            uniform_buffer,
            bind_group,
            pass_buffers,
            pass_bind_groups,
            config,
            uniform,
        }
    }

    pub fn compute_cascade_matrix(&self, cascade_idx: usize, camera_pos: Vec3, day_night: &DayNightCycle) -> Mat4 {
        let dist = self.config.cascade_distances[cascade_idx];
        let light_dir = day_night.shadow_light_direction();
        let resolution = self.config.resolution as f32;

        let size = dist * 1.5;

        let up = if light_dir.y.abs() > 0.99 {
            Vec3::new(0.0, 0.0, 1.0)
        } else {
            Vec3::new(0.0, 1.0, 0.0)
        };

        // Создаём матрицу вида света
        let light_pos = camera_pos - light_dir * dist * 2.0;
        let light_view = Mat4::look_at(light_pos, camera_pos, up);

        let near = 1.0;
        let far = dist * 4.0;
        let light_proj = ultraviolet::projection::orthographic_wgpu_dx(-size, size, -size, size, near, far);

        let mut light_vp = light_proj * light_view;

        // === СТАБИЛИЗАЦИЯ ===
        // Размер одного текселя в NDC пространстве
        let texel_size_ndc = 2.0 / resolution;
        
        // Трансформируем точку (0,0,0) в light space чтобы найти смещение
        let shadow_origin = light_vp * ultraviolet::Vec4::new(0.0, 0.0, 0.0, 1.0);
        
        // Округляем до границы текселя
        let offset_x = (shadow_origin.x % texel_size_ndc);
        let offset_y = (shadow_origin.y % texel_size_ndc);
        
        // Применяем коррекцию напрямую к матрице (последний столбец - translation)
        light_vp.cols[3].x -= offset_x;
        light_vp.cols[3].y -= offset_y;

        light_vp
    }

    pub fn update(&mut self, queue: &wgpu::Queue, camera_pos: Vec3, day_night: &DayNightCycle) {
        for i in 0..self.config.num_cascades {
            let matrix = self.compute_cascade_matrix(i, camera_pos, day_night);
            let arr: [[f32; 4]; 4] = matrix.into();
            self.uniform.light_vp[i] = arr;
            queue.write_buffer(&self.pass_buffers[i], 0, bytemuck::cast_slice(&[arr]));
        }
        self.uniform.cascade_splits = [
            self.config.cascade_distances[0],
            self.config.cascade_distances[1],
            self.config.cascade_distances[2],
            self.config.cascade_distances[3],
        ];
        queue.write_buffer(&self.uniform_buffer, 0, bytemuck::cast_slice(&[self.uniform]));
    }
}


============================================================
FILE: render\uniforms.rs
============================================================

use bytemuck::{Pod, Zeroable};
use ultraviolet::Mat4;

use crate::gpu::player::Camera;
use crate::gpu::lighting::DayNightCycle;

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct Uniforms {
    pub view_proj: [[f32; 4]; 4],
    pub camera_pos: [f32; 3],
    pub time: f32,
    pub sky_color: [f32; 3],
    pub time_of_day: f32,
    pub fog_color: [f32; 3],
    pub _pad: f32,
}

impl Uniforms {
    pub fn new() -> Self {
        Self {
            view_proj: Mat4::identity().into(),
            camera_pos: [0.0, 0.0, 0.0],
            time: 0.0,
            sky_color: [0.5, 0.7, 1.0],
            time_of_day: 0.5,
            fog_color: [0.7, 0.8, 0.9],
            _pad: 0.0,
        }
    }

    pub fn update(&mut self, camera: &Camera, time: f32) {
        self.view_proj = camera.view_projection_matrix().into();
        self.camera_pos = camera.position.into();
        self.time = time;
    }

    pub fn update_day_night(&mut self, cycle: &DayNightCycle) {
        self.sky_color = cycle.sky_color.into();
        self.fog_color = cycle.fog_color.into();
        self.time_of_day = cycle.time.time;
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct LightUniform {
    pub direction: [f32; 3],
    pub intensity: f32,
    pub color: [f32; 3],
    pub _pad: f32,
}

impl Default for LightUniform {
    fn default() -> Self {
        Self {
            direction: [0.4, -0.8, 0.3],
            intensity: 1.0,
            color: [1.0, 0.98, 0.95],
            _pad: 0.0,
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Pod, Zeroable)]
pub struct ShadowUniform {
    pub light_vp: [[[f32; 4]; 4]; 4],
    pub cascade_splits: [f32; 4],
    pub num_cascades: u32,
    pub texel_size: f32,
    pub bias: f32,
    pub _pad: f32,
}

impl Default for ShadowUniform {
    fn default() -> Self {
        Self {
            light_vp: [[[0.0; 4]; 4]; 4],
            cascade_splits: [64.0, 256.0, 512.0, 1024.0],
            num_cascades: 2,
            texel_size: 0.002,
            bias: 0.003, // Увеличен для уменьшения shadow acne
            _pad: 0.0,
        }
    }
}


============================================================
FILE: render\renderer\mod.rs
============================================================

pub mod core;
mod culling;
mod passes;
mod systems;

use std::sync::Arc;

use crate::gpu::render::depth::create_depth_texture;
use crate::gpu::player::Camera;
use crate::gpu::player::Player;
use crate::gpu::terrain::WorldChanges;

use core::{RendererState, RenderComponents, LightingResources, TerrainResources, CachedCamera};

pub struct Renderer {
    state: RendererState,
    components: RenderComponents,
    lighting: LightingResources,
    terrain: TerrainResources,
    cached: CachedCamera,
}

impl Renderer {
    pub async fn new(window: Arc<winit::window::Window>) -> Self {
        let (surface, device, queue, config, size) = core::init_gpu(window).await;
        let (components, lighting, terrain) = core::init_components(&device, &queue, &config);

        Self {
            state: RendererState { surface, device, queue, config, size },
            components,
            lighting,
            terrain,
            cached: CachedCamera::default(),
        }
    }

    pub fn resize(&mut self, new_size: winit::dpi::PhysicalSize<u32>) {
        if new_size.width > 0 && new_size.height > 0 {
            self.state.size = new_size;
            self.state.config.width = new_size.width;
            self.state.config.height = new_size.height;
            self.state.surface.configure(&self.state.device, &self.state.config);
            self.terrain.depth_texture = create_depth_texture(&self.state.device, &self.state.config);
        }
    }

    pub fn update(&mut self, camera: &Camera, player: &Player, time: f32, dt: f32, world_changes: &WorldChanges) {
        systems::frame::update(
            &self.state.queue,
            camera,
            player,
            time,
            dt,
            world_changes,
            &mut self.components,
            &mut self.lighting,
            &mut self.terrain,
            &mut self.cached,
        );
    }

    pub fn instant_chunk_update(&mut self, block_x: i32, block_y: i32, block_z: i32, world_changes: &WorldChanges) {
        systems::terrain::instant_chunk_update(
            &mut self.components.gpu_chunks,
            block_x,
            block_y,
            block_z,
            world_changes,
        );
    }

    pub fn update_block_highlight(&self, block_pos: Option<[i32; 3]>) {
        systems::terrain::update_block_highlight(
            &self.state.queue,
            &self.components.block_highlight,
            self.cached.view_proj,
            block_pos,
        );
    }
    
    /// Обновить выделение с произвольной позицией и размером (для суб-вокселей)
    pub fn update_block_highlight_sized(&self, pos: [f32; 3], size: f32) {
        self.components.block_highlight.update_with_size(
            &self.state.queue,
            self.cached.view_proj,
            pos,
            size,
        );
    }

    pub fn render(&mut self, render_player: bool, highlight_block: Option<[i32; 3]>) -> Result<(), wgpu::SurfaceError> {
        self.components.fps_counter.update();

        let output = self.state.surface.get_current_texture()?;
        let view = output.texture.create_view(&wgpu::TextureViewDescriptor::default());
        let mut encoder = self.state.device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
            label: Some("Render Encoder"),
        });

        // Shadow pass
        passes::shadow::render(
            &mut encoder,
            &self.lighting.shadow,
            &self.components.pipelines,
            &self.components.gpu_chunks,
            None, // No subvoxels in basic render
        );

        // Main 3D pass
        passes::main_pass::render(
            &mut encoder,
            &view,
            &self.terrain.depth_texture,
            self.lighting.day_night.sky_color,
            &self.cached.view_proj,
            &self.components.pipelines,
            &self.lighting.core_bind_groups,
            &self.lighting.shadow,
            &self.lighting.atlas,
            &self.components,
            render_player,
            highlight_block,
        );

        // UI pass
        passes::ui::render(&mut encoder, &view, &self.components);

        self.state.queue.submit(std::iter::once(encoder.finish()));
        output.present();
        Ok(())
    }
    
    /// Рендерит с GUI поверх
    pub fn render_with_gui<F>(&mut self, render_player: bool, highlight_block: Option<[i32; 3]>, gui_render: F) -> Result<(), wgpu::SurfaceError>
    where
        F: FnOnce(&wgpu::Device, &mut wgpu::CommandEncoder, &wgpu::TextureView, &wgpu::Queue),
    {
        self.components.fps_counter.update();

        let output = self.state.surface.get_current_texture()?;
        let view = output.texture.create_view(&wgpu::TextureViewDescriptor::default());
        let mut encoder = self.state.device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
            label: Some("Render Encoder"),
        });

        // Shadow pass
        passes::shadow::render(
            &mut encoder,
            &self.lighting.shadow,
            &self.components.pipelines,
            &self.components.gpu_chunks,
            None, // No subvoxels in basic render_with_gui
        );

        // Main 3D pass
        passes::main_pass::render(
            &mut encoder,
            &view,
            &self.terrain.depth_texture,
            self.lighting.day_night.sky_color,
            &self.cached.view_proj,
            &self.components.pipelines,
            &self.lighting.core_bind_groups,
            &self.lighting.shadow,
            &self.lighting.atlas,
            &self.components,
            render_player,
            highlight_block,
        );

        // UI pass
        passes::ui::render(&mut encoder, &view, &self.components);
        
        // GUI pass (меню и т.п.)
        gui_render(&self.state.device, &mut encoder, &view, &self.state.queue);

        self.state.queue.submit(std::iter::once(encoder.finish()));
        output.present();
        Ok(())
    }
    
    /// Рендерит с GUI и суб-вокселями
    pub fn render_with_subvoxels<F>(
        &mut self, 
        render_player: bool, 
        highlight_block: Option<[i32; 3]>,
        subvoxel_renderer: Option<&crate::gpu::subvoxel::SubVoxelRenderer>,
        gui_render: F
    ) -> Result<(), wgpu::SurfaceError>
    where
        F: FnOnce(&wgpu::Device, &mut wgpu::CommandEncoder, &wgpu::TextureView, &wgpu::Queue),
    {
        self.components.fps_counter.update();

        let output = self.state.surface.get_current_texture()?;
        let view = output.texture.create_view(&wgpu::TextureViewDescriptor::default());
        let mut encoder = self.state.device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
            label: Some("Render Encoder"),
        });

        // Shadow pass
        passes::shadow::render(
            &mut encoder,
            &self.lighting.shadow,
            &self.components.pipelines,
            &self.components.gpu_chunks,
            subvoxel_renderer,
        );

        // Main 3D pass
        passes::main_pass::render(
            &mut encoder,
            &view,
            &self.terrain.depth_texture,
            self.lighting.day_night.sky_color,
            &self.cached.view_proj,
            &self.components.pipelines,
            &self.lighting.core_bind_groups,
            &self.lighting.shadow,
            &self.lighting.atlas,
            &self.components,
            render_player,
            highlight_block,
        );
        
        // SubVoxel pass
        if let Some(sv_renderer) = subvoxel_renderer {
            if sv_renderer.has_content() {
                passes::subvoxel::render(
                    &mut encoder,
                    &view,
                    &self.terrain.depth_texture,
                    &self.components.pipelines,
                    &self.lighting.core_bind_groups,
                    &self.lighting.shadow,
                    &self.lighting.atlas,
                    sv_renderer,
                );
            }
        }

        // UI pass
        passes::ui::render(&mut encoder, &view, &self.components);
        
        // GUI pass
        gui_render(&self.state.device, &mut encoder, &view, &self.state.queue);

        self.state.queue.submit(std::iter::once(encoder.finish()));
        output.present();
        Ok(())
    }

    pub fn set_time_of_day(&mut self, time: f32) {
        self.lighting.day_night.set_time(time);
    }

    pub fn set_time_speed(&mut self, speed: f32) {
        self.lighting.day_night.set_speed(speed);
    }

    pub fn time_of_day(&self) -> f32 {
        self.lighting.day_night.time.time
    }

    pub fn size(&self) -> winit::dpi::PhysicalSize<u32> {
        self.state.size
    }
    
    pub fn device(&self) -> &wgpu::Device {
        &self.state.device
    }
    
    pub fn queue(&self) -> &wgpu::Queue {
        &self.state.queue
    }
    
    pub fn surface_format(&self) -> wgpu::TextureFormat {
        self.state.config.format
    }
    
    /// Возвращает uniform bind group layout для GUI
    pub fn uniform_bind_group_layout(&self) -> &wgpu::BindGroupLayout {
        &self.lighting.layouts.uniform
    }
    
    /// Возвращает uniform bind group для GUI рендеринга
    pub fn uniform_bind_group(&self) -> &wgpu::BindGroup {
        &self.lighting.core_bind_groups.uniform_bind_group
    }
    
    /// Установить дистанции LOD (в чанках)
    /// distances: [LOD0, LOD1, LOD2, LOD3] - максимальные дистанции для каждого уровня
    pub fn set_lod_distances(&mut self, distances: [i32; 4]) {
        self.terrain.terrain_manager.set_lod_distances(distances);
    }
    
    /// Получить текущие дистанции LOD
    pub fn get_lod_distances(&self) -> [i32; 4] {
        self.terrain.terrain_manager.get_lod_distances()
    }
}


============================================================
FILE: render\renderer\core\init.rs
============================================================

use std::sync::Arc;

use crate::gpu::render::depth::create_depth_texture;
use crate::gpu::render::bind_groups::{BindGroupLayouts, CoreBindGroups, AtlasResources};
use crate::gpu::render::shadow::ShadowResources;
use crate::gpu::render::pipelines::Pipelines;

use crate::gpu::player::PlayerModel;
use crate::gpu::gui::{Crosshair, BlockHighlight};
use crate::gpu::terrain::{HybridTerrainManager, GpuChunkManager, SectionTerrainManager};
use crate::gpu::gui::FpsCounter;
use crate::gpu::lighting::DayNightCycle;
use crate::gpu::lighting::CelestialRenderer;

use super::state::{RenderComponents, LightingResources, TerrainResources};

/// Инициализация GPU устройства и surface
pub async fn init_gpu(window: Arc<winit::window::Window>) -> (
    wgpu::Surface<'static>,
    Arc<wgpu::Device>,
    Arc<wgpu::Queue>,
    wgpu::SurfaceConfiguration,
    winit::dpi::PhysicalSize<u32>,
) {
    let size = window.inner_size();
    let instance = wgpu::Instance::new(&wgpu::InstanceDescriptor {
        backends: wgpu::Backends::all(),
        ..Default::default()
    });

    let surface = instance.create_surface(window).unwrap();
    let adapter = instance
        .request_adapter(&wgpu::RequestAdapterOptions {
            power_preference: wgpu::PowerPreference::HighPerformance,
            compatible_surface: Some(&surface),
            force_fallback_adapter: false,
        })
        .await
        .unwrap();

    let (device, queue) = adapter
        .request_device(
            &wgpu::DeviceDescriptor {
                label: Some("GPU Device"),
                required_features: wgpu::Features::empty(),
                required_limits: wgpu::Limits::default(),
                memory_hints: Default::default(),
                trace: wgpu::Trace::Off,
            },
        )
        .await
        .unwrap();

    let device = Arc::new(device);
    let queue = Arc::new(queue);

    let surface_caps = surface.get_capabilities(&adapter);
    let surface_format = surface_caps
        .formats
        .iter()
        .find(|f| f.is_srgb())
        .copied()
        .unwrap_or(surface_caps.formats[0]);

    let config = wgpu::SurfaceConfiguration {
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        format: surface_format,
        width: size.width,
        height: size.height,
        present_mode: wgpu::PresentMode::AutoVsync,
        alpha_mode: surface_caps.alpha_modes[0],
        view_formats: vec![],
        desired_maximum_frame_latency: 2,
    };
    surface.configure(&device, &config);

    (surface, device, queue, config, size)
}

/// Инициализация всех компонентов рендеринга
pub fn init_components(
    device: &Arc<wgpu::Device>,
    queue: &Arc<wgpu::Queue>,
    config: &wgpu::SurfaceConfiguration,
) -> (RenderComponents, LightingResources, TerrainResources) {
    let depth_texture = create_depth_texture(device, config);

    // Bind group layouts
    let layouts = BindGroupLayouts::new(device);
    let model_layout = PlayerModel::create_bind_group_layout(device);

    // Core bind groups
    let core_bind_groups = CoreBindGroups::new(device, &layouts);

    // Atlas resources (текстурный атлас для кастомных блоков)
    let atlas = AtlasResources::new(device, queue, &layouts.atlas);

    // Shadow resources
    let shadow = ShadowResources::new(device, &layouts.shadow, &layouts.shadow_pass);

    // Pipelines
    let pipelines = Pipelines::new(device, config.format, &layouts, &model_layout);

    // Terrain
    let mut gpu_chunks = GpuChunkManager::new(Arc::clone(device));
    let mut terrain_manager = HybridTerrainManager::new();
    let initial_mesh = terrain_manager.generate_initial(0.0, 0.0);
    let section_manager = SectionTerrainManager::new();

    for chunk_data in &initial_mesh.new_chunks {
        gpu_chunks.upload(chunk_data.key, &chunk_data.vertices, &chunk_data.indices);
    }

    // Other components
    let player_model = PlayerModel::new(device, &model_layout);
    let crosshair = Crosshair::new(device, config.format);
    let block_highlight = BlockHighlight::new(device, config.format);
    let fps_counter = FpsCounter::new(device, Arc::clone(queue), config.format);
    let celestial = CelestialRenderer::new(device, config.format);

    let mut day_night = DayNightCycle::new();
    day_night.set_time(0.35);
    day_night.set_speed(3.0);

    let components = RenderComponents {
        pipelines,
        gpu_chunks,
        player_model,
        crosshair,
        block_highlight,
        fps_counter,
        celestial,
    };

    let lighting = LightingResources {
        core_bind_groups,
        shadow,
        day_night,
        layouts,
        atlas,
    };

    let terrain = TerrainResources {
        depth_texture,
        terrain_manager,
        section_manager,
    };

    (components, lighting, terrain)
}


============================================================
FILE: render\renderer\core\mod.rs
============================================================

mod state;
mod init;

pub use state::{RendererState, RenderComponents, LightingResources, TerrainResources, CachedCamera};
pub use init::{init_gpu, init_components};


============================================================
FILE: render\renderer\core\state.rs
============================================================

use std::sync::Arc;
use ultraviolet::{Mat4, Vec3};

use crate::gpu::render::uniforms::Uniforms;
use crate::gpu::render::shadow::ShadowResources;
use crate::gpu::render::pipelines::Pipelines;
use crate::gpu::render::bind_groups::{CoreBindGroups, AtlasResources};

use crate::gpu::player::PlayerModel;
use crate::gpu::gui::{Crosshair, BlockHighlight};
use crate::gpu::terrain::{HybridTerrainManager, GpuChunkManager, SectionTerrainManager};
use crate::gpu::gui::FpsCounter;
use crate::gpu::lighting::DayNightCycle;
use crate::gpu::lighting::CelestialRenderer;

/// Основное состояние рендерера (GPU ресурсы)
pub struct RendererState {
    pub surface: wgpu::Surface<'static>,
    pub device: Arc<wgpu::Device>,
    pub queue: Arc<wgpu::Queue>,
    pub config: wgpu::SurfaceConfiguration,
    pub size: winit::dpi::PhysicalSize<u32>,
}

/// Компоненты рендеринга
pub struct RenderComponents {
    pub pipelines: Pipelines,
    pub gpu_chunks: GpuChunkManager,
    pub player_model: PlayerModel,
    pub crosshair: Crosshair,
    pub block_highlight: BlockHighlight,
    pub fps_counter: FpsCounter,
    pub celestial: CelestialRenderer,
}

/// Ресурсы освещения и теней
pub struct LightingResources {
    pub core_bind_groups: CoreBindGroups,
    pub shadow: ShadowResources,
    pub day_night: DayNightCycle,
    pub layouts: crate::gpu::render::bind_groups::BindGroupLayouts,
    pub atlas: AtlasResources,
}

/// Ресурсы террейна
pub struct TerrainResources {
    pub depth_texture: wgpu::TextureView,
    pub terrain_manager: HybridTerrainManager,
    #[allow(dead_code)]
    pub section_manager: SectionTerrainManager,
}

/// Кэшированные данные камеры
pub struct CachedCamera {
    pub view_proj: [[f32; 4]; 4],
    pub view: Mat4,
    pub proj: Mat4,
    pub position: Vec3,
}

impl Default for CachedCamera {
    fn default() -> Self {
        Self {
            view_proj: Mat4::identity().into(),
            view: Mat4::identity(),
            proj: Mat4::identity(),
            position: Vec3::zero(),
        }
    }
}

impl CachedCamera {
    pub fn update(&mut self, uniforms: &Uniforms, view: Mat4, proj: Mat4, position: Vec3) {
        self.view_proj = uniforms.view_proj;
        self.view = view;
        self.proj = proj;
        self.position = position;
    }
}


============================================================
FILE: render\renderer\culling\frustum.rs
============================================================

use ultraviolet::Vec3;

const CHUNK_SIZE: i32 = 16;
const MIN_Y: f32 = -64.0;
const MAX_Y: f32 = 320.0;

/// Извлекает 6 плоскостей frustum из view-projection матрицы
/// Каждая плоскость: (nx, ny, nz, d) где nx*x + ny*y + nz*z + d >= 0 означает "внутри"
pub fn extract_frustum_planes(vp: &[[f32; 4]; 4]) -> [[f32; 4]; 6] {
    let m = vp;
    [
        // Left:   row3 + row0
        [m[0][3] + m[0][0], m[1][3] + m[1][0], m[2][3] + m[2][0], m[3][3] + m[3][0]],
        // Right:  row3 - row0
        [m[0][3] - m[0][0], m[1][3] - m[1][0], m[2][3] - m[2][0], m[3][3] - m[3][0]],
        // Bottom: row3 + row1
        [m[0][3] + m[0][1], m[1][3] + m[1][1], m[2][3] + m[2][1], m[3][3] + m[3][1]],
        // Top:    row3 - row1
        [m[0][3] - m[0][1], m[1][3] - m[1][1], m[2][3] - m[2][1], m[3][3] - m[3][1]],
        // Near:   row3 + row2
        [m[0][3] + m[0][2], m[1][3] + m[1][2], m[2][3] + m[2][2], m[3][3] + m[3][2]],
        // Far:    row3 - row2
        [m[0][3] - m[0][2], m[1][3] - m[1][2], m[2][3] - m[2][2], m[3][3] - m[3][2]],
    ]
}

/// Проверяет, находится ли AABB полностью снаружи плоскости frustum
fn is_aabb_outside_plane(plane: &[f32; 4], min: Vec3, max: Vec3) -> bool {
    let px = if plane[0] >= 0.0 { max.x } else { min.x };
    let py = if plane[1] >= 0.0 { max.y } else { min.y };
    let pz = if plane[2] >= 0.0 { max.z } else { min.z };
    
    plane[0] * px + plane[1] * py + plane[2] * pz + plane[3] < 0.0
}

/// Frustum culling: проверяет видимость AABB чанка
pub fn is_chunk_visible(view_proj: &[[f32; 4]; 4], chunk_x: i32, chunk_z: i32, scale: i32) -> bool {
    let size = (CHUNK_SIZE * scale.max(1)) as f32;
    let min_x = (chunk_x * CHUNK_SIZE) as f32;
    let min_z = (chunk_z * CHUNK_SIZE) as f32;
    
    let min = Vec3::new(min_x, MIN_Y, min_z);
    let max = Vec3::new(min_x + size, MAX_Y, min_z + size);
    
    let planes = extract_frustum_planes(view_proj);
    
    for plane in &planes {
        if is_aabb_outside_plane(plane, min, max) {
            return false;
        }
    }
    true
}


============================================================
FILE: render\renderer\culling\mod.rs
============================================================

mod frustum;

pub use frustum::is_chunk_visible;


============================================================
FILE: render\renderer\passes\main_pass.rs
============================================================

use crate::gpu::render::pipelines::Pipelines;
use crate::gpu::render::bind_groups::{CoreBindGroups, AtlasResources};
use crate::gpu::render::shadow::ShadowResources;

use crate::gpu::render::renderer::core::{RenderComponents, LightingResources};
use crate::gpu::render::renderer::culling::is_chunk_visible;

/// Main 3D pass — основной рендеринг сцены
pub fn render<'a>(
    encoder: &'a mut wgpu::CommandEncoder,
    view: &'a wgpu::TextureView,
    depth_texture: &'a wgpu::TextureView,
    sky_color: ultraviolet::Vec3,
    cached_view_proj: &[[f32; 4]; 4],
    pipelines: &'a Pipelines,
    core_bind_groups: &'a CoreBindGroups,
    shadow: &'a ShadowResources,
    atlas: &'a AtlasResources,
    components: &'a RenderComponents,
    render_player: bool,
    highlight_block: Option<[i32; 3]>,
) {
    let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
        label: Some("Main Pass"),
        color_attachments: &[Some(wgpu::RenderPassColorAttachment {
            view,
            resolve_target: None,
            ops: wgpu::Operations {
                load: wgpu::LoadOp::Clear(wgpu::Color {
                    r: sky_color.x as f64,
                    g: sky_color.y as f64,
                    b: sky_color.z as f64,
                    a: 1.0,
                }),
                store: wgpu::StoreOp::Store,
            },
        })],
        depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
            view: depth_texture,
            depth_ops: Some(wgpu::Operations {
                load: wgpu::LoadOp::Clear(0.0), // Reversed-Z: clear to 0 instead of 1
                store: wgpu::StoreOp::Store,
            }),
            stencil_ops: None,
        }),
        timestamp_writes: None,
        occlusion_query_set: None,
    });

    // Celestial (sun/moon) — на заднем плане
    components.celestial.render(&mut render_pass);

    // Terrain
    render_pass.set_pipeline(&pipelines.terrain);
    render_pass.set_bind_group(0, &core_bind_groups.uniform_bind_group, &[]);
    render_pass.set_bind_group(1, &core_bind_groups.light_bind_group, &[]);
    render_pass.set_bind_group(2, &shadow.bind_group, &[]);
    render_pass.set_bind_group(3, &atlas.bind_group, &[]);

    for gpu_chunk in components.gpu_chunks.iter() {
        if is_chunk_visible(cached_view_proj, gpu_chunk.key.x, gpu_chunk.key.z, gpu_chunk.key.scale) {
            render_pass.set_vertex_buffer(0, gpu_chunk.vertex_buffer.slice(..));
            render_pass.set_index_buffer(gpu_chunk.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
            render_pass.draw_indexed(0..gpu_chunk.index_count, 0, 0..1);
        }
    }

    // Player
    if render_player {
        render_pass.set_pipeline(&pipelines.player);
        render_pass.set_bind_group(0, &core_bind_groups.uniform_bind_group, &[]);
        components.player_model.render(&mut render_pass);
    }

    // Block highlight
    if highlight_block.is_some() {
        components.block_highlight.render(&mut render_pass);
    }
}


============================================================
FILE: render\renderer\passes\mod.rs
============================================================

pub mod shadow;
pub mod main_pass;
pub mod ui;
pub mod subvoxel;


============================================================
FILE: render\renderer\passes\shadow.rs
============================================================

use crate::gpu::terrain::GpuChunkManager;
use crate::gpu::render::pipelines::Pipelines;
use crate::gpu::render::shadow::ShadowResources;
use crate::gpu::subvoxel::SubVoxelRenderer;

use crate::gpu::render::renderer::culling::is_chunk_visible;

/// Shadow pass — рендеринг теней для всех каскадов
pub fn render(
    encoder: &mut wgpu::CommandEncoder,
    shadow: &ShadowResources,
    pipelines: &Pipelines,
    gpu_chunks: &GpuChunkManager,
    subvoxel_renderer: Option<&SubVoxelRenderer>,
) {
    for i in 0..shadow.config.num_cascades {
        let cascade_matrix = shadow.uniform.light_vp[i];
        
        let mut shadow_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
            label: Some(&format!("Shadow Pass {}", i)),
            color_attachments: &[],
            depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
                view: &shadow.views[i],
                depth_ops: Some(wgpu::Operations {
                    load: wgpu::LoadOp::Clear(1.0),
                    store: wgpu::StoreOp::Store,
                }),
                stencil_ops: None,
            }),
            timestamp_writes: None,
            occlusion_query_set: None,
        });

        shadow_pass.set_pipeline(&pipelines.shadow);
        shadow_pass.set_bind_group(0, &shadow.pass_bind_groups[i], &[]);

        // Рендерим terrain chunks
        for gpu_chunk in gpu_chunks.iter() {
            if is_chunk_visible(&cascade_matrix, gpu_chunk.key.x, gpu_chunk.key.z, gpu_chunk.key.scale) {
                shadow_pass.set_vertex_buffer(0, gpu_chunk.vertex_buffer.slice(..));
                shadow_pass.set_index_buffer(gpu_chunk.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
                shadow_pass.draw_indexed(0..gpu_chunk.index_count, 0, 0..1);
            }
        }
        
        // Рендерим субвоксели в shadow map
        if let Some(sv_renderer) = subvoxel_renderer {
            if sv_renderer.has_content() {
                shadow_pass.set_vertex_buffer(0, sv_renderer.vertex_buffer().slice(..));
                shadow_pass.set_index_buffer(sv_renderer.index_buffer().slice(..), wgpu::IndexFormat::Uint32);
                shadow_pass.draw_indexed(0..sv_renderer.num_indices(), 0, 0..1);
            }
        }
    }
}


============================================================
FILE: render\renderer\passes\subvoxel.rs
============================================================

use crate::gpu::render::pipelines::Pipelines;
use crate::gpu::render::bind_groups::{CoreBindGroups, AtlasResources};
use crate::gpu::render::shadow::ShadowResources;
use crate::gpu::subvoxel::SubVoxelRenderer;

/// SubVoxel pass — рендеринг ку-вокселей
pub fn render<'a>(
    encoder: &'a mut wgpu::CommandEncoder,
    view: &'a wgpu::TextureView,
    depth_texture: &'a wgpu::TextureView,
    pipelines: &'a Pipelines,
    core_bind_groups: &'a CoreBindGroups,
    shadow: &'a ShadowResources,
    atlas: &'a AtlasResources,
    subvoxel_renderer: &'a SubVoxelRenderer,
) {
    let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
        label: Some("SubVoxel Pass"),
        color_attachments: &[Some(wgpu::RenderPassColorAttachment {
            view,
            resolve_target: None,
            ops: wgpu::Operations {
                load: wgpu::LoadOp::Load, // Не очищаем, рисуем поверх
                store: wgpu::StoreOp::Store,
            },
        })],
        depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
            view: depth_texture,
            depth_ops: Some(wgpu::Operations {
                load: wgpu::LoadOp::Load, // Используем существующий depth
                store: wgpu::StoreOp::Store,
            }),
            stencil_ops: None,
        }),
        timestamp_writes: None,
        occlusion_query_set: None,
    });

    // Используем terrain pipeline для суб-вокселей (тот же формат вершин)
    render_pass.set_pipeline(&pipelines.terrain);
    render_pass.set_bind_group(0, &core_bind_groups.uniform_bind_group, &[]);
    render_pass.set_bind_group(1, &core_bind_groups.light_bind_group, &[]);
    render_pass.set_bind_group(2, &shadow.bind_group, &[]);
    render_pass.set_bind_group(3, &atlas.bind_group, &[]);
    
    render_pass.set_vertex_buffer(0, subvoxel_renderer.vertex_buffer().slice(..));
    render_pass.set_index_buffer(subvoxel_renderer.index_buffer().slice(..), wgpu::IndexFormat::Uint32);
    render_pass.draw_indexed(0..subvoxel_renderer.num_indices(), 0, 0..1);
}


============================================================
FILE: render\renderer\passes\ui.rs
============================================================

use crate::gpu::render::renderer::core::RenderComponents;

/// UI pass — рендеринг интерфейса (crosshair, FPS)
pub fn render<'a>(
    encoder: &'a mut wgpu::CommandEncoder,
    view: &'a wgpu::TextureView,
    components: &'a RenderComponents,
) {
    let mut ui_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
        label: Some("UI Pass"),
        color_attachments: &[Some(wgpu::RenderPassColorAttachment {
            view,
            resolve_target: None,
            ops: wgpu::Operations {
                load: wgpu::LoadOp::Load,
                store: wgpu::StoreOp::Store,
            },
        })],
        depth_stencil_attachment: None,
        timestamp_writes: None,
        occlusion_query_set: None,
    });
    
    components.crosshair.render(&mut ui_pass);
    components.fps_counter.render(&mut ui_pass);
}


============================================================
FILE: render\renderer\systems\frame.rs
============================================================

use crate::gpu::render::uniforms::{Uniforms, LightUniform};
use crate::gpu::player::Camera;
use crate::gpu::player::Player;
use crate::gpu::terrain::WorldChanges;

use crate::gpu::render::renderer::core::{RenderComponents, LightingResources, TerrainResources, CachedCamera};

/// Обновление состояния рендерера каждый кадр
pub fn update(
    queue: &wgpu::Queue,
    camera: &Camera,
    player: &Player,
    time: f32,
    dt: f32,
    world_changes: &WorldChanges,
    components: &mut RenderComponents,
    lighting: &mut LightingResources,
    terrain: &mut TerrainResources,
    cached: &mut CachedCamera,
) {
    // День/ночь
    lighting.day_night.update(dt);

    // Uniforms
    let mut uniforms = Uniforms::new();
    uniforms.update(camera, time);
    uniforms.update_day_night(&lighting.day_night);
    cached.update(&uniforms, camera.view_matrix(), camera.projection_matrix(), camera.position);
    
    queue.write_buffer(
        &lighting.core_bind_groups.uniform_buffer,
        0,
        bytemuck::cast_slice(&[uniforms]),
    );

    // Light
    let primary = lighting.day_night.primary_light();
    let light = LightUniform {
        direction: primary.light_direction().into(),
        intensity: primary.intensity,
        color: (primary.color * lighting.day_night.ambient_intensity * 3.0).into(),
        _pad: 0.0,
    };
    queue.write_buffer(
        &lighting.core_bind_groups.light_buffer,
        0,
        bytemuck::cast_slice(&[light]),
    );

    // Shadows
    lighting.shadow.update(queue, camera.position, &lighting.day_night);

    // Celestial
    components.celestial.update(queue, cached.view_proj, camera.position, &lighting.day_night);

    // Player model
    components.player_model.update(queue, player);

    // Terrain
    terrain.terrain_manager.update(
        player.position.x,
        player.position.z,
        &world_changes.get_all_changes_copy(),
        world_changes.version(),
    );

    if let Some(mesh) = terrain.terrain_manager.try_get_mesh() {
        components.gpu_chunks.retain_only(&mesh.required_keys);
        for chunk_data in mesh.new_chunks {
            components.gpu_chunks.upload(chunk_data.key, &chunk_data.vertices, &chunk_data.indices);
        }
    }
}


============================================================
FILE: render\renderer\systems\mod.rs
============================================================

pub mod frame;
pub mod terrain;


============================================================
FILE: render\renderer\systems\terrain.rs
============================================================

use crate::gpu::terrain::voxel::{VoxelChunk, ChunkNeighbors, CHUNK_SIZE, MIN_HEIGHT};
use crate::gpu::terrain::{GpuChunkManager, ChunkKey};
use crate::gpu::terrain::WorldChanges;

/// Мгновенное обновление чанка при изменении блока
pub fn instant_chunk_update(
    gpu_chunks: &mut GpuChunkManager,
    block_x: i32,
    block_y: i32,
    block_z: i32,
    world_changes: &WorldChanges,
) {
    let chunk_x = block_x.div_euclid(CHUNK_SIZE);
    let chunk_z = block_z.div_euclid(CHUNK_SIZE);
    let section_y = (block_y - MIN_HEIGHT).div_euclid(16);
    let section_min_y = MIN_HEIGHT + section_y * 16;
    let section_max_y = section_min_y + 15;

    let changes = world_changes.get_all_changes_copy();
    let chunk = VoxelChunk::new(chunk_x, chunk_z, &changes);
    let neighbors = ChunkNeighbors {
        pos_x: None,
        neg_x: None,
        pos_z: None,
        neg_z: None,
    };
    let (vertices, indices) = chunk.generate_mesh_section(&neighbors, section_min_y, section_max_y);

    if !vertices.is_empty() {
        let key = ChunkKey::new_section(chunk_x, chunk_z, section_y);
        gpu_chunks.upload(key, &vertices, &indices);
    }
}

/// Обновление подсветки блока
pub fn update_block_highlight(
    queue: &wgpu::Queue,
    block_highlight: &crate::gpu::gui::BlockHighlight,
    view_proj: [[f32; 4]; 4],
    block_pos: Option<[i32; 3]>,
) {
    if let Some(pos) = block_pos {
        block_highlight.update(queue, view_proj, pos);
    }
}


============================================================
FILE: save\chunk.rs
============================================================

// ============================================
// Compressed Chunk - Сжатый чанк для сохранения
// ============================================
// Использует палитру для минимизации размера

use serde::{Serialize, Deserialize};
use crate::gpu::blocks::{BlockType, AIR};
use super::palette::BlockPalette;

/// Размер секции чанка (16x16x16)
pub const SECTION_SIZE: usize = 16;
pub const SECTION_VOLUME: usize = SECTION_SIZE * SECTION_SIZE * SECTION_SIZE;

/// Сжатый чанк с палитрой
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompressedChunk {
    /// Координаты чанка (X, Z)
    pub chunk_x: i32,
    pub chunk_z: i32,
    /// Секции чанка по высоте (каждая 16x16x16)
    pub sections: Vec<CompressedSection>,
}

/// Сжатая секция 16x16x16
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompressedSection {
    /// Y-координата секции (в блоках, кратно 16)
    pub section_y: i32,
    /// Палитра блоков для этой секции
    pub palette: BlockPalette,
    /// Индексы блоков (ссылки на палитру)
    pub indices: Vec<u16>,
}

impl CompressedChunk {
    pub fn new(chunk_x: i32, chunk_z: i32) -> Self {
        Self {
            chunk_x,
            chunk_z,
            sections: Vec::new(),
        }
    }

    /// Добавить секцию
    pub fn add_section(&mut self, section: CompressedSection) {
        self.sections.push(section);
    }

    /// Получить секцию по Y
    pub fn get_section(&self, section_y: i32) -> Option<&CompressedSection> {
        self.sections.iter().find(|s| s.section_y == section_y)
    }

    /// Проверить пустой ли чанк
    pub fn is_empty(&self) -> bool {
        self.sections.is_empty()
    }
}

impl CompressedSection {
    /// Создать секцию из массива блоков 16x16x16
    pub fn from_blocks(section_y: i32, blocks: &[BlockType; SECTION_VOLUME]) -> Self {
        let mut palette = BlockPalette::new();
        let mut indices = Vec::with_capacity(SECTION_VOLUME);

        // Первый проход: строим палитру и индексы
        for &block in blocks {
            let idx = palette.get_or_insert(block);
            indices.push(idx);
        }

        Self {
            section_y,
            palette,
            indices,
        }
    }

    /// Распаковать секцию в массив блоков
    pub fn decompress(&self) -> [BlockType; SECTION_VOLUME] {
        let mut blocks = [AIR; SECTION_VOLUME];
        
        for (i, &idx) in self.indices.iter().enumerate() {
            if let Some(block) = self.palette.get(idx) {
                blocks[i] = block;
            }
        }
        
        blocks
    }

    /// Проверить содержит ли секция только воздух
    pub fn is_air_only(&self) -> bool {
        self.palette.len() == 1 && self.palette.get(0) == Some(AIR)
    }

    /// Восстановить палитру после десериализации
    pub fn rebuild_palette(&mut self) {
        self.palette.rebuild_reverse_map();
    }
}

/// Индекс блока внутри секции
#[inline]
pub fn section_index(x: usize, y: usize, z: usize) -> usize {
    y * SECTION_SIZE * SECTION_SIZE + z * SECTION_SIZE + x
}

/// Координаты из индекса секции
#[inline]
pub fn index_to_coords(index: usize) -> (usize, usize, usize) {
    let y = index / (SECTION_SIZE * SECTION_SIZE);
    let rem = index % (SECTION_SIZE * SECTION_SIZE);
    let z = rem / SECTION_SIZE;
    let x = rem % SECTION_SIZE;
    (x, y, z)
}


============================================================
FILE: save\header.rs
============================================================

// ============================================
// Save Header - Заголовок файла сохранения
// ============================================

use serde::{Serialize, Deserialize};

/// Магическое число "RUST" в ASCII
pub const MAGIC_NUMBER: [u8; 4] = [0x52, 0x55, 0x53, 0x54];

/// Версия формата сохранения
pub const SAVE_VERSION: u32 = 1;

/// Заголовок файла сохранения (28 байт)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SaveHeader {
    /// Магическое число для валидации
    pub magic: [u8; 4],
    /// Версия формата
    pub version: u32,
    /// Сид мира
    pub seed: u64,
    /// Позиция игрока
    pub player_pos: [f32; 3],
}

impl SaveHeader {
    pub fn new(seed: u64, player_pos: [f32; 3]) -> Self {
        Self {
            magic: MAGIC_NUMBER,
            version: SAVE_VERSION,
            seed,
            player_pos,
        }
    }

    /// Проверка валидности заголовка
    pub fn is_valid(&self) -> bool {
        self.magic == MAGIC_NUMBER && self.version == SAVE_VERSION
    }
}

impl Default for SaveHeader {
    fn default() -> Self {
        Self::new(0, [0.0, 64.0, 0.0])
    }
}


============================================================
FILE: save\mod.rs
============================================================

// ============================================
// Save System - Система сохранения мира
// ============================================
// Формат world.dat с палитрой и ZSTD сжатием

mod header;
mod chunk;
mod palette;
mod world_file;

pub use header::{SaveHeader, MAGIC_NUMBER, SAVE_VERSION};
pub use chunk::CompressedChunk;
pub use palette::BlockPalette;
pub use world_file::WorldFile;


============================================================
FILE: save\palette.rs
============================================================

// ============================================
// Block Palette - Палитра блоков для сжатия
// ============================================
// Превращает BlockType в компактные индексы 0..N

use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use crate::gpu::blocks::BlockType;

/// Палитра блоков для чанка
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockPalette {
    /// Список уникальных типов блоков (индекс = ID в палитре)
    blocks: Vec<u8>,
    /// Обратный маппинг: BlockType -> индекс палитры
    #[serde(skip)]
    reverse_map: HashMap<u8, u16>,
}

impl BlockPalette {
    pub fn new() -> Self {
        Self {
            blocks: Vec::new(),
            reverse_map: HashMap::new(),
        }
    }

    /// Создать палитру из массива блоков
    pub fn from_blocks(blocks: &[BlockType]) -> Self {
        let mut palette = Self::new();
        for &block in blocks {
            palette.get_or_insert(block);
        }
        palette
    }

    /// Получить индекс блока или добавить новый
    pub fn get_or_insert(&mut self, block: BlockType) -> u16 {
        let block_id = block as u8;
        
        if let Some(&idx) = self.reverse_map.get(&block_id) {
            return idx;
        }
        
        let idx = self.blocks.len() as u16;
        self.blocks.push(block_id);
        self.reverse_map.insert(block_id, idx);
        idx
    }

    /// Получить BlockType по индексу палитры
    pub fn get(&self, index: u16) -> Option<BlockType> {
        self.blocks.get(index as usize).map(|&id| unsafe {
            std::mem::transmute::<u8, BlockType>(id)
        })
    }

    /// Количество уникальных блоков
    pub fn len(&self) -> usize {
        self.blocks.len()
    }

    /// Пустая ли палитра
    pub fn is_empty(&self) -> bool {
        self.blocks.is_empty()
    }

    /// Восстановить reverse_map после десериализации
    pub fn rebuild_reverse_map(&mut self) {
        self.reverse_map.clear();
        for (idx, &block_id) in self.blocks.iter().enumerate() {
            self.reverse_map.insert(block_id, idx as u16);
        }
    }

    /// Количество бит на индекс (для оптимального хранения)
    pub fn bits_per_index(&self) -> u8 {
        let len = self.blocks.len();
        if len <= 2 { 1 }
        else if len <= 4 { 2 }
        else if len <= 16 { 4 }
        else if len <= 256 { 8 }
        else { 16 }
    }
}

impl Default for BlockPalette {
    fn default() -> Self {
        Self::new()
    }
}


============================================================
FILE: save\world_file.rs
============================================================

// ============================================
// World File - Чтение/запись файла мира
// ============================================
// Оптимизированный формат с палитрой и чанками
// 
// Математика:
// - Наивный формат: 13 байт/блок (x,y,z,type) = 13GB на 1 млрд блоков
// - Чанковый формат с палитрой: ~0.5-2 байта/блок = 0.5-2GB на 1 млрд блоков
// - После ZSTD сжатия: ещё в 3-10 раз меньше
//
// Секрет: храним только изменённые секции 16x16x16, используем палитру

use std::collections::HashMap;
use std::fs::File;
use std::io::{Read, Write, BufReader, BufWriter};
use std::path::Path;

use serde::{Serialize, Deserialize};

use crate::gpu::blocks::BlockType;
use crate::gpu::terrain::{BlockPos, WorldChanges};
use crate::gpu::subvoxel::{SubVoxel, SubVoxelStorage};

use super::header::{SaveHeader, MAGIC_NUMBER, SAVE_VERSION};

const SECTION_SIZE: i32 = 16;
const SECTION_VOLUME: usize = 16 * 16 * 16; // 4096

/// Сжатая секция с палитрой
#[derive(Debug, Serialize, Deserialize)]
struct SavedSection {
    /// Координаты секции (chunk_x, section_y, chunk_z)
    cx: i32,
    sy: i32,
    cz: i32,
    /// Палитра: индекс -> (block_type, is_change_marker)
    /// is_change_marker=true означает что это реальное изменение
    palette: Vec<(u8, bool)>,
    /// Индексы в палитру (4096 значений, упакованы)
    /// Используем битовую упаковку в зависимости от размера палитры
    data: Vec<u8>,
    /// Бит на индекс (1, 2, 4, 8)
    bits_per_block: u8,
}

/// Тело файла (сжимается ZSTD)
#[derive(Debug, Serialize, Deserialize)]
struct SaveBody {
    sections: Vec<SavedSection>,
    /// Суб-воксели (ку-воксели)
    #[serde(default)]
    subvoxels: Vec<SubVoxel>,
}

/// Результат загрузки мира
#[derive(Debug)]
pub struct LoadedWorld {
    pub seed: u64,
    pub player_pos: [f32; 3],
    pub changes: HashMap<BlockPos, BlockType>,
    pub subvoxels: Vec<SubVoxel>,
}

/// Ошибки сохранения/загрузки
#[derive(Debug)]
pub enum SaveError {
    Io(std::io::Error),
    Serialize(String),
    Deserialize(String),
    InvalidMagic,
    UnsupportedVersion(u32),
    Compression(String),
}

impl From<std::io::Error> for SaveError {
    fn from(e: std::io::Error) -> Self {
        SaveError::Io(e)
    }
}

/// Основной интерфейс для работы с файлом мира
pub struct WorldFile;

impl WorldFile {
    /// Сохранить мир в файл
    pub fn save(
        path: impl AsRef<Path>,
        seed: u64,
        player_pos: [f32; 3],
        world_changes: &WorldChanges,
        subvoxel_storage: &SubVoxelStorage,
    ) -> Result<(), SaveError> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);

        // 1. Записываем заголовок
        let header = SaveHeader::new(seed, player_pos);
        let header_bytes = bincode::serialize(&header)
            .map_err(|e| SaveError::Serialize(e.to_string()))?;
        writer.write_all(&header_bytes)?;

        // 2. Группируем изменения по секциям
        let sections = Self::build_sections(world_changes);
        
        // 3. Получаем суб-воксели
        let subvoxels = subvoxel_storage.get_all();

        // 4. Сериализуем и сжимаем
        let body = SaveBody { sections, subvoxels };
        let body_bytes = bincode::serialize(&body)
            .map_err(|e| SaveError::Serialize(e.to_string()))?;

        let compressed = zstd::encode_all(&body_bytes[..], 3)
            .map_err(|e| SaveError::Compression(e.to_string()))?;
        writer.write_all(&compressed)?;

        writer.flush()?;
        Ok(())
    }

    /// Загрузить мир из файла
    pub fn load(path: impl AsRef<Path>) -> Result<LoadedWorld, SaveError> {
        let file = File::open(path)?;
        let mut reader = BufReader::new(file);

        // 1. Читаем заголовок
        let header_size = bincode::serialized_size(&SaveHeader::default()).unwrap_or(32) as usize;
        let mut header_bytes = vec![0u8; header_size];
        reader.read_exact(&mut header_bytes)?;

        let header: SaveHeader = bincode::deserialize(&header_bytes)
            .map_err(|e| SaveError::Deserialize(e.to_string()))?;

        if header.magic != MAGIC_NUMBER {
            return Err(SaveError::InvalidMagic);
        }
        if header.version != SAVE_VERSION {
            return Err(SaveError::UnsupportedVersion(header.version));
        }

        // 2. Читаем и распаковываем тело
        let mut compressed = Vec::new();
        reader.read_to_end(&mut compressed)?;

        let body_bytes = zstd::decode_all(&compressed[..])
            .map_err(|e| SaveError::Compression(e.to_string()))?;

        let body: SaveBody = bincode::deserialize(&body_bytes)
            .map_err(|e| SaveError::Deserialize(e.to_string()))?;

        // 3. Восстанавливаем изменения
        let changes = Self::extract_changes(&body.sections);

        Ok(LoadedWorld {
            seed: header.seed,
            player_pos: header.player_pos,
            changes,
            subvoxels: body.subvoxels,
        })
    }

    /// Группируем изменения по секциям 16x16x16
    fn build_sections(world_changes: &WorldChanges) -> Vec<SavedSection> {
        let all_changes = world_changes.get_all_changes_copy();
        if all_changes.is_empty() {
            return Vec::new();
        }

        // Группируем по секциям
        type SectionKey = (i32, i32, i32); // (chunk_x, section_y, chunk_z)
        let mut section_map: HashMap<SectionKey, Vec<(BlockPos, BlockType)>> = HashMap::new();

        for (pos, block) in all_changes {
            let cx = pos.x.div_euclid(SECTION_SIZE);
            let sy = pos.y.div_euclid(SECTION_SIZE);
            let cz = pos.z.div_euclid(SECTION_SIZE);
            
            section_map
                .entry((cx, sy, cz))
                .or_default()
                .push((pos, block));
        }

        // Конвертируем каждую секцию
        let mut sections = Vec::new();
        
        for ((cx, sy, cz), changes) in section_map {
            // Строим палитру: (block_type, is_real_change)
            // Индекс 0 = "нет изменения" (placeholder)
            let mut palette: Vec<(u8, bool)> = vec![(0, false)]; // placeholder
            let mut palette_map: HashMap<u8, usize> = HashMap::new();
            
            // Массив индексов (4096 элементов)
            let mut indices = vec![0u16; SECTION_VOLUME];
            
            for (pos, block) in changes {
                let lx = pos.x.rem_euclid(SECTION_SIZE) as usize;
                let ly = pos.y.rem_euclid(SECTION_SIZE) as usize;
                let lz = pos.z.rem_euclid(SECTION_SIZE) as usize;
                let idx = ly * 256 + lz * 16 + lx;
                
                let block_id = block as u8;
                
                // Получаем или создаём индекс в палитре
                let palette_idx = if let Some(&existing) = palette_map.get(&block_id) {
                    existing
                } else {
                    let new_idx = palette.len();
                    palette.push((block_id, true)); // true = реальное изменение
                    palette_map.insert(block_id, new_idx);
                    new_idx
                };
                
                indices[idx] = palette_idx as u16;
            }
            
            // Определяем bits_per_block
            let bits = if palette.len() <= 2 { 1 }
                else if palette.len() <= 4 { 2 }
                else if palette.len() <= 16 { 4 }
                else { 8 };
            
            // Упаковываем данные
            let data = Self::pack_indices(&indices, bits);
            
            sections.push(SavedSection {
                cx, sy, cz,
                palette,
                data,
                bits_per_block: bits,
            });
        }

        sections
    }

    /// Упаковка индексов в байты
    fn pack_indices(indices: &[u16], bits: u8) -> Vec<u8> {
        let values_per_byte = 8 / bits as usize;
        let total_bytes = (SECTION_VOLUME + values_per_byte - 1) / values_per_byte;
        let mut data = vec![0u8; total_bytes];
        
        for (i, &idx) in indices.iter().enumerate() {
            let byte_idx = i / values_per_byte;
            let bit_offset = (i % values_per_byte) * bits as usize;
            data[byte_idx] |= (idx as u8 & ((1 << bits) - 1)) << bit_offset;
        }
        
        data
    }

    /// Распаковка индексов из байтов
    fn unpack_indices(data: &[u8], bits: u8) -> Vec<u16> {
        let values_per_byte = 8 / bits as usize;
        let mask = (1u8 << bits) - 1;
        let mut indices = Vec::with_capacity(SECTION_VOLUME);
        
        for i in 0..SECTION_VOLUME {
            let byte_idx = i / values_per_byte;
            let bit_offset = (i % values_per_byte) * bits as usize;
            let value = (data.get(byte_idx).copied().unwrap_or(0) >> bit_offset) & mask;
            indices.push(value as u16);
        }
        
        indices
    }

    /// Извлекаем изменения из секций
    fn extract_changes(sections: &[SavedSection]) -> HashMap<BlockPos, BlockType> {
        let mut changes = HashMap::new();

        for section in sections {
            let base_x = section.cx * SECTION_SIZE;
            let base_y = section.sy * SECTION_SIZE;
            let base_z = section.cz * SECTION_SIZE;
            
            let indices = Self::unpack_indices(&section.data, section.bits_per_block);
            
            for (i, &palette_idx) in indices.iter().enumerate() {
                if palette_idx == 0 {
                    continue; // Нет изменения
                }
                
                if let Some(&(block_id, is_change)) = section.palette.get(palette_idx as usize) {
                    if is_change {
                        let lx = (i % 16) as i32;
                        let lz = ((i / 16) % 16) as i32;
                        let ly = (i / 256) as i32;
                        
                        let pos = BlockPos::new(base_x + lx, base_y + ly, base_z + lz);
                        let block = unsafe { std::mem::transmute::<u8, BlockType>(block_id) };
                        changes.insert(pos, block);
                    }
                }
            }
        }

        changes
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_save_load_roundtrip() {
        let mut world_changes = WorldChanges::new();
        world_changes.set_block(BlockPos::new(10, 64, 10), BlockType::Stone);
        world_changes.set_block(BlockPos::new(11, 64, 10), BlockType::Dirt);
        world_changes.set_block(BlockPos::new(12, 64, 10), BlockType::Air); // Сломанный блок!
        
        let subvoxel_storage = SubVoxelStorage::new();

        let path = "test_world3.dat";
        
        WorldFile::save(path, 12345, [10.0, 65.0, 10.0], &world_changes, &subvoxel_storage).unwrap();
        let loaded = WorldFile::load(path).unwrap();

        assert_eq!(loaded.seed, 12345);
        assert_eq!(loaded.changes.len(), 3);
        assert_eq!(loaded.changes.get(&BlockPos::new(10, 64, 10)), Some(&BlockType::Stone));
        assert_eq!(loaded.changes.get(&BlockPos::new(12, 64, 10)), Some(&BlockType::Air));

        std::fs::remove_file(path).ok();
    }
}


============================================================
FILE: shaders\celestial.wgsl
============================================================

// ============================================
// Celestial Bodies Shader - Солнце и Луна
// ============================================

struct CelestialUniforms {
    view_proj: mat4x4<f32>,
    camera_pos: vec4<f32>,        // xyz + pad
    sun_direction: vec4<f32>,     // xyz + visibility
    sun_color: vec4<f32>,         // rgb + size
    moon_direction: vec4<f32>,    // xyz + visibility
    moon_color: vec4<f32>,        // rgb + phase
    time_of_day: vec4<f32>,       // time + pad
}

@group(0) @binding(0)
var<uniform> uniforms: CelestialUniforms;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) uv: vec2<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) uv: vec2<f32>,
    @location(1) @interpolate(flat) instance: u32,
}

const SKY_DISTANCE: f32 = 500.0;

@vertex
fn vs_main(in: VertexInput, @builtin(instance_index) instance: u32) -> VertexOutput {
    var out: VertexOutput;
    
    var direction: vec3<f32>;
    var size: f32;
    var visibility: f32;
    
    if (instance == 0u) {
        direction = uniforms.sun_direction.xyz;
        size = uniforms.sun_color.w;
        visibility = uniforms.sun_direction.w;
    } else {
        direction = uniforms.moon_direction.xyz;
        size = uniforms.sun_color.w * 0.8;
        visibility = uniforms.moon_direction.w;
    }
    
    if (visibility < 0.01) {
        out.clip_position = vec4<f32>(0.0, 0.0, -2.0, 1.0);
        out.uv = in.uv;
        out.instance = instance;
        return out;
    }
    
    let center = uniforms.camera_pos.xyz + direction * SKY_DISTANCE;
    let to_camera = normalize(uniforms.camera_pos.xyz - center);
    
    var up = vec3<f32>(0.0, 1.0, 0.0);
    if (abs(dot(to_camera, up)) > 0.99) {
        up = vec3<f32>(0.0, 0.0, 1.0);
    }
    let right = normalize(cross(up, to_camera));
    let billboard_up = normalize(cross(to_camera, right));
    
    let scale = SKY_DISTANCE * size;
    let offset = right * in.position.x * scale + billboard_up * in.position.y * scale;
    let world_pos = center + offset;
    
    out.clip_position = uniforms.view_proj * vec4<f32>(world_pos, 1.0);
    out.uv = in.uv;
    out.instance = instance;
    
    return out;
}


fn draw_sun(uv: vec2<f32>) -> vec4<f32> {
    let center = vec2<f32>(0.5, 0.5);
    let dist = length(uv - center);
    
    let core_radius = 0.2;
    let glow_radius = 0.5;
    
    let core = smoothstep(core_radius, core_radius * 0.5, dist);
    let glow = smoothstep(glow_radius, core_radius, dist) * 0.6;
    
    let angle = atan2(uv.y - 0.5, uv.x - 0.5);
    let rays = (sin(angle * 12.0) * 0.5 + 0.5) * 0.3;
    let ray_intensity = rays * smoothstep(glow_radius, core_radius * 1.5, dist) * smoothstep(0.0, core_radius * 2.0, dist);
    
    let sun_core_color = vec3<f32>(1.0, 1.0, 0.95);
    let sun_glow_color = uniforms.sun_color.xyz;
    let sun_ray_color = vec3<f32>(1.0, 0.8, 0.4);
    
    var color = sun_core_color * core;
    color += sun_glow_color * glow;
    color += sun_ray_color * ray_intensity;
    
    let alpha = (core + glow + ray_intensity * 0.5) * uniforms.sun_direction.w;
    
    return vec4<f32>(color, alpha);
}

fn draw_moon(uv: vec2<f32>) -> vec4<f32> {
    let center = vec2<f32>(0.5, 0.5);
    let dist = length(uv - center);
    
    let moon_radius = 0.35;
    let glow_radius = 0.45;
    
    let moon_disk = smoothstep(moon_radius, moon_radius - 0.02, dist);
    let glow = smoothstep(glow_radius, moon_radius, dist) * 0.3;
    
    let phase = uniforms.moon_color.w;
    let phase_offset = (phase - 0.5) * 2.0;
    let shadow_center = vec2<f32>(0.5 + phase_offset * 0.4, 0.5);
    let shadow_dist = length(uv - shadow_center);
    let shadow = smoothstep(moon_radius * 0.9, moon_radius * 0.7, shadow_dist);
    
    var phase_factor = 1.0;
    if (phase < 0.5) {
        phase_factor = 1.0 - shadow * (1.0 - phase * 2.0);
    } else {
        phase_factor = 1.0 - shadow * ((phase - 0.5) * 2.0);
    }
    
    let crater_noise = crater_pattern(uv * 8.0);
    let surface_detail = 1.0 - crater_noise * 0.15;
    
    let moon_color = uniforms.moon_color.xyz * surface_detail;
    
    var color = moon_color * moon_disk * phase_factor;
    color += uniforms.moon_color.xyz * 0.5 * glow;
    
    let alpha = (moon_disk * phase_factor + glow) * uniforms.moon_direction.w;
    
    return vec4<f32>(color, alpha);
}

fn crater_pattern(p: vec2<f32>) -> f32 {
    let i = floor(p);
    let f = fract(p);
    
    var min_dist = 1.0;
    for (var y = -1; y <= 1; y++) {
        for (var x = -1; x <= 1; x++) {
            let neighbor = vec2<f32>(f32(x), f32(y));
            let point = hash2d(i + neighbor);
            let diff = neighbor + point - f;
            let dist = length(diff);
            min_dist = min(min_dist, dist);
        }
    }
    return smoothstep(0.0, 0.3, min_dist);
}

fn hash2d(p: vec2<f32>) -> vec2<f32> {
    let k = vec2<f32>(0.3183099, 0.3678794);
    var q = p * k + k.yx;
    return fract(16.0 * k * fract(q.x * q.y * (q.x + q.y))) * 2.0 - 1.0;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    if (in.instance == 0u) {
        return draw_sun(in.uv);
    } else {
        return draw_moon(in.uv);
    }
}


============================================================
FILE: shaders\highlight.wgsl
============================================================

// ============================================
// Block Highlight Shader - Выделение блока
// ============================================

struct Uniforms {
    view_proj: mat4x4<f32>,
    block_pos: vec3<f32>,
    block_size: f32,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) color: vec4<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) color: vec4<f32>,
}

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    
    // Масштабируем вершины по размеру блока и смещаем на позицию
    let scaled_pos = in.position * uniforms.block_size;
    let world_pos = scaled_pos + uniforms.block_pos;
    out.clip_position = uniforms.view_proj * vec4<f32>(world_pos, 1.0);
    out.color = in.color;
    
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    return in.color;
}


============================================================
FILE: shaders\terrain.wgsl
============================================================

// ============================================
// Terrain Shader with Texture Atlas Support
// ============================================

struct Uniforms {
    view_proj: mat4x4<f32>,
    camera_pos: vec3<f32>,
    time: f32,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

// Текстурный атлас (опционально)
@group(1) @binding(0)
var atlas_texture: texture_2d<f32>;
@group(1) @binding(1)
var atlas_sampler: sampler;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) color: vec3<f32>,
    @location(3) block_id: u32,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) world_pos: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) color: vec3<f32>,
    @location(3) block_id: u32,
}

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    
    out.clip_position = uniforms.view_proj * vec4<f32>(in.position, 1.0);
    out.world_pos = in.position;
    out.normal = in.normal;
    out.color = in.color;
    out.block_id = in.block_id;
    
    return out;
}

// Константы атласа
const ATLAS_SIZE: f32 = 16.0;  // 16x16 блоков в атласе
const TEXTURE_SIZE: f32 = 16.0; // 16x16 пикселей на текстуру

// Хеш для процедурного шума
fn hash2(p: vec2<f32>) -> f32 {
    let k = vec2<f32>(0.3183099, 0.3678794);
    let q = p * k + k.yx;
    return fract(16.0 * k.x * fract(q.x * q.y * (q.x + q.y)));
}

// Получить UV координаты на грани блока
fn get_block_uv(world_pos: vec3<f32>, normal: vec3<f32>) -> vec2<f32> {
    if (abs(normal.y) > 0.5) {
        return fract(world_pos.xz);
    } else if (abs(normal.x) > 0.5) {
        return fract(vec2<f32>(world_pos.z, world_pos.y));
    } else {
        return fract(vec2<f32>(world_pos.x, world_pos.y));
    }
}

// Получить UV в атласе для блока
fn get_atlas_uv(block_id: u32, local_uv: vec2<f32>) -> vec2<f32> {
    let atlas_x = f32(block_id % u32(ATLAS_SIZE));
    let atlas_y = f32(block_id / u32(ATLAS_SIZE));
    
    let u = (atlas_x + local_uv.x) / ATLAS_SIZE;
    let v = (atlas_y + local_uv.y) / ATLAS_SIZE;
    
    return vec2<f32>(u, v);
}

// Проверить, кастомный ли блок (ID >= 100)
fn is_custom_block(block_id: u32) -> bool {
    return block_id >= 100u;
}

// Анти-муар функции
fn get_detail_fade(dist: f32) -> f32 {
    return 1.0 - smoothstep(15.0, 40.0, dist);
}

fn get_side_face_fade(dist: f32) -> f32 {
    return smoothstep(20.0, 60.0, dist);
}

fn get_edge_fade(dist: f32) -> f32 {
    return 1.0 - smoothstep(10.0, 35.0, dist);
}

// Процедурные текстуры для стандартных блоков
fn grass_texture(uv: vec2<f32>, world_pos: vec3<f32>, dist: f32) -> f32 {
    var variation = 0.0;
    let edge_fade = get_edge_fade(dist);
    let detail_fade = get_detail_fade(dist);
    
    let edge_width = 0.06;
    let edge_x = min(uv.x, 1.0 - uv.x);
    let edge_y = min(uv.y, 1.0 - uv.y);
    let edge_dist = min(edge_x, edge_y);
    let edge_factor = smoothstep(0.0, edge_width, edge_dist);
    variation = mix(-0.15, 0.0, edge_factor) * edge_fade;
    
    if (detail_fade > 0.01) {
        let pixel_size = 0.0625;
        let pixel_uv = floor(uv / pixel_size);
        let seed = pixel_uv + floor(world_pos.xz);
        let noise_val = hash2(seed * 0.1);
        
        if (noise_val > 0.85) {
            variation = variation + 0.08 * detail_fade;
        } else if (noise_val < 0.15) {
            variation = variation - 0.06 * detail_fade;
        }
    }
    
    return variation;
}

fn stone_texture(uv: vec2<f32>, world_pos: vec3<f32>, dist: f32) -> f32 {
    var variation = 0.0;
    let edge_fade = get_edge_fade(dist);
    let detail_fade = get_detail_fade(dist);
    
    let edge_width = 0.04;
    let edge_x = min(uv.x, 1.0 - uv.x);
    let edge_y = min(uv.y, 1.0 - uv.y);
    let edge_dist = min(edge_x, edge_y);
    let edge_factor = smoothstep(0.0, edge_width, edge_dist);
    variation = mix(-0.1, 0.0, edge_factor) * edge_fade;
    
    if (detail_fade > 0.01) {
        let pixel_size = 0.0625;
        let pixel_uv = floor(uv / pixel_size);
        let seed = pixel_uv + floor(world_pos.xz) * 2.3;
        let noise_val = hash2(seed * 0.17);
        
        if (noise_val > 0.75) {
            variation = variation + 0.06 * detail_fade;
        } else if (noise_val < 0.25) {
            variation = variation - 0.06 * detail_fade;
        }
    }
    
    return variation;
}

fn get_procedural_variation(base_color: vec3<f32>, uv: vec2<f32>, world_pos: vec3<f32>, dist: f32) -> f32 {
    // Трава
    if (base_color.g > 0.5 && base_color.r < 0.5) {
        return grass_texture(uv, world_pos, dist);
    }
    // Камень
    if (abs(base_color.r - base_color.g) < 0.1 && base_color.r > 0.4 && base_color.r < 0.7) {
        return stone_texture(uv, world_pos, dist);
    }
    // Остальные - минимальная обводка
    let edge_fade = get_edge_fade(dist);
    let edge_width = 0.04;
    let edge_x = min(uv.x, 1.0 - uv.x);
    let edge_y = min(uv.y, 1.0 - uv.y);
    let edge_dist = min(edge_x, edge_y);
    let edge_factor = smoothstep(0.0, edge_width, edge_dist);
    return mix(-0.06, 0.0, edge_factor) * edge_fade;
}

fn get_average_surface_color(base_color: vec3<f32>) -> vec3<f32> {
    if (base_color.r > 0.4 && base_color.g > 0.25 && base_color.g < 0.5) {
        return vec3<f32>(0.35, 0.55, 0.25);
    }
    if (abs(base_color.r - base_color.g) < 0.15 && base_color.r > 0.35) {
        return vec3<f32>(0.5, 0.5, 0.5);
    }
    return base_color;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    let light_dir = normalize(vec3<f32>(0.4, 0.8, 0.3));
    let ndotl = max(dot(in.normal, light_dir), 0.0);
    
    let dist = length(in.world_pos - uniforms.camera_pos);
    let is_side_face = abs(in.normal.y) < 0.5;
    let side_fade = get_side_face_fade(dist);
    
    var face_light = 1.0;
    if (in.normal.y > 0.5) { 
        face_light = 1.0; 
    } else if (abs(in.normal.x) > 0.5) { 
        face_light = mix(0.85, 1.0, side_fade); 
    } else { 
        face_light = mix(0.75, 1.0, side_fade); 
    }
    
    let lighting = (0.4 + ndotl * 0.6) * face_light;
    
    let uv = get_block_uv(in.world_pos, in.normal);
    var color: vec3<f32>;
    
    // Кастомные блоки (ID >= 100) используют текстурный атлас
    if (is_custom_block(in.block_id) && in.block_id > 0u) {
        let atlas_uv = get_atlas_uv(in.block_id, uv);
        let tex_color = textureSample(atlas_texture, atlas_sampler, atlas_uv);
        color = tex_color.rgb * lighting;
    } else {
        // Стандартные блоки - процедурные текстуры
        var base_color = in.color;
        if (is_side_face) {
            let avg_color = get_average_surface_color(in.color);
            base_color = mix(in.color, avg_color, side_fade);
        }
        
        let tex_variation = get_procedural_variation(in.color, uv, in.world_pos, dist);
        color = base_color * (1.0 + tex_variation) * lighting;
    }
    
    // Туман
    let fog_color = vec3<f32>(0.7, 0.8, 0.9);
    let fog_factor = smoothstep(300.0, 600.0, dist);
    color = mix(color, fog_color, fog_factor);
    
    return vec4<f32>(color, 1.0);
}


============================================================
FILE: shaders\terrain_shadows.wgsl
============================================================

// ============================================
// Terrain Shader with CSM Shadows + Texture Atlas
// ============================================
// Полная версия с каскадными тенями, динамическим небом и текстурным атласом

struct Uniforms {
    view_proj: mat4x4<f32>,
    camera_pos: vec3<f32>,
    time: f32,
    sky_color: vec3<f32>,
    time_of_day: f32,
    fog_color: vec3<f32>,
    _pad: f32,
}

struct LightData {
    direction: vec3<f32>,
    intensity: f32,
    color: vec3<f32>,
    _padding: f32,
}

struct ShadowData {
    light_vp_0: mat4x4<f32>,
    light_vp_1: mat4x4<f32>,
    light_vp_2: mat4x4<f32>,
    light_vp_3: mat4x4<f32>,
    cascade_splits: vec4<f32>,
    num_cascades: u32,
    texel_size: f32,
    bias: f32,
    _pad: f32,
}

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

@group(1) @binding(0)
var<uniform> light: LightData;

@group(2) @binding(0)
var shadow_map: texture_depth_2d_array;
@group(2) @binding(1)
var shadow_sampler: sampler_comparison;
@group(2) @binding(2)
var<uniform> shadow_data: ShadowData;

// Текстурный атлас для кастомных блоков (ID >= 100)
@group(3) @binding(0)
var atlas_texture: texture_2d<f32>;
@group(3) @binding(1)
var atlas_sampler: sampler;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) color: vec3<f32>,
    @location(3) block_id: u32,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) world_pos: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) color: vec3<f32>,
    @location(3) view_depth: f32,
    @location(4) block_id: u32,
}

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    
    let world_pos = vec4<f32>(in.position, 1.0);
    out.clip_position = uniforms.view_proj * world_pos;
    out.world_pos = in.position;
    out.normal = in.normal;
    out.color = in.color;
    out.block_id = in.block_id;
    
    // Расстояние от камеры для выбора каскада
    out.view_depth = length(in.position - uniforms.camera_pos);
    
    return out;
}

// === Shadow Sampling Functions ===

fn select_cascade(view_depth: f32) -> u32 {
    if (view_depth < shadow_data.cascade_splits.x) { return 0u; }
    if (view_depth < shadow_data.cascade_splits.y) { return 1u; }
    if (view_depth < shadow_data.cascade_splits.z) { return 2u; }
    return 3u;
}

fn get_light_matrix(cascade: u32) -> mat4x4<f32> {
    switch (cascade) {
        case 0u: { return shadow_data.light_vp_0; }
        case 1u: { return shadow_data.light_vp_1; }
        case 2u: { return shadow_data.light_vp_2; }
        default: { return shadow_data.light_vp_3; }
    }
}

fn sample_shadow_pcf(world_pos: vec3<f32>, normal: vec3<f32>, cascade: u32) -> f32 {
    let light_matrix = get_light_matrix(cascade);
    
    // Normal offset bias - сдвигаем позицию вдоль нормали
    let normal_offset = normal * 0.1 * (1.0 + f32(cascade) * 0.3);
    let biased_pos = world_pos + normal_offset;
    
    let light_space = light_matrix * vec4<f32>(biased_pos, 1.0);
    
    let ndc = light_space.xyz / light_space.w;
    
    let uv = vec2<f32>(
        ndc.x * 0.5 + 0.5,
        -ndc.y * 0.5 + 0.5
    );
    
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || ndc.z < 0.0 || ndc.z > 1.0) {
        return 1.0;
    }
    
    let depth = ndc.z - 0.001;
    let texel_size = 1.0 / 2048.0;
    
    // Poisson disk - фиксированный паттерн для мягких теней без ряби
    let poisson = array<vec2<f32>, 16>(
        vec2<f32>(-0.94201624, -0.39906216),
        vec2<f32>(0.94558609, -0.76890725),
        vec2<f32>(-0.09418410, -0.92938870),
        vec2<f32>(0.34495938, 0.29387760),
        vec2<f32>(-0.91588581, 0.45771432),
        vec2<f32>(-0.81544232, -0.87912464),
        vec2<f32>(-0.38277543, 0.27676845),
        vec2<f32>(0.97484398, 0.75648379),
        vec2<f32>(0.44323325, -0.97511554),
        vec2<f32>(0.53742981, -0.47373420),
        vec2<f32>(-0.26496911, -0.41893023),
        vec2<f32>(0.79197514, 0.19090188),
        vec2<f32>(-0.24188840, 0.99706507),
        vec2<f32>(-0.81409955, 0.91437590),
        vec2<f32>(0.19984126, 0.78641367),
        vec2<f32>(0.14383161, -0.14100790)
    );
    
    var shadow = 0.0;
    let spread = 2.5 * texel_size;
    
    for (var i = 0; i < 16; i++) {
        let offset = poisson[i] * spread;
        shadow += textureSampleCompareLevel(
            shadow_map, shadow_sampler,
            uv + offset, i32(cascade), depth
        );
    }
    
    return shadow / 16.0;
}

fn calculate_shadow(world_pos: vec3<f32>, normal: vec3<f32>, view_depth: f32) -> f32 {
    if (shadow_data.num_cascades == 0u) {
        return 1.0;
    }
    
    // За пределами последнего каскада - нет теней
    let last_split = shadow_data.cascade_splits[shadow_data.num_cascades - 1u];
    if (view_depth > last_split) {
        return 1.0;
    }
    
    let cascade = select_cascade(view_depth);
    return sample_shadow_pcf(world_pos, normal, cascade);
}

// === Texture Functions ===

fn hash2(p: vec2<f32>) -> f32 {
    let k = vec2<f32>(0.3183099, 0.3678794);
    let q = p * k + k.yx;
    return fract(16.0 * k.x * fract(q.x * q.y * (q.x + q.y)));
}

fn get_block_uv(world_pos: vec3<f32>, normal: vec3<f32>) -> vec2<f32> {
    if (abs(normal.y) > 0.5) {
        return fract(world_pos.xz);
    } else if (abs(normal.x) > 0.5) {
        return fract(vec2<f32>(world_pos.z, world_pos.y));
    } else {
        return fract(vec2<f32>(world_pos.x, world_pos.y));
    }
}

fn get_texture_variation(base_color: vec3<f32>, uv: vec2<f32>, world_pos: vec3<f32>) -> f32 {
    let edge_width = 0.05;
    let edge_x = min(uv.x, 1.0 - uv.x);
    let edge_y = min(uv.y, 1.0 - uv.y);
    let edge_dist = min(edge_x, edge_y);
    
    if (edge_dist < edge_width) {
        return -0.15;
    }
    
    let pixel_size = 0.0625;
    let pixel_uv = floor(uv / pixel_size);
    let seed = pixel_uv + floor(world_pos.xz);
    let noise = hash2(seed * 0.1);
    
    if (noise > 0.85) { return 0.1; }
    if (noise < 0.15) { return -0.08; }
    return 0.0;
}

// === Texture Atlas Functions ===

const ATLAS_SIZE: f32 = 16.0;  // 16x16 блоков в атласе

// Получить UV в атласе для блока
fn get_atlas_uv(block_id: u32, local_uv: vec2<f32>) -> vec2<f32> {
    let atlas_x = f32(block_id % u32(ATLAS_SIZE));
    let atlas_y = f32(block_id / u32(ATLAS_SIZE));
    
    // Небольшой отступ от краёв чтобы избежать bleeding
    let padding = 0.001;
    let clamped_uv = clamp(local_uv, vec2<f32>(padding), vec2<f32>(1.0 - padding));
    
    let u = (atlas_x + clamped_uv.x) / ATLAS_SIZE;
    let v = (atlas_y + clamped_uv.y) / ATLAS_SIZE;
    
    return vec2<f32>(u, v);
}

// Проверить, кастомный ли блок (ID >= 100)
fn is_custom_block(block_id: u32) -> bool {
    return block_id >= 100u;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    // Направленное освещение
    let ndotl = max(dot(in.normal, -light.direction), 0.0);
    
    // Освещение граней (ambient occlusion стиль)
    var face_light = 1.0;
    if (in.normal.y > 0.5) { face_light = 1.0; }
    else if (abs(in.normal.x) > 0.5) { face_light = 0.75; }
    else { face_light = 0.6; }
    
    // Тени с normal offset bias
    let shadow = calculate_shadow(in.world_pos, in.normal, in.view_depth);
    
    // Финальное освещение
    let ambient = 0.3;
    let diffuse = ndotl * light.intensity * shadow;
    let lighting = (ambient + diffuse * 0.7) * face_light;
    
    // UV координаты на грани блока
    let uv = get_block_uv(in.world_pos, in.normal);
    
    var color: vec3<f32>;
    
    // Кастомные блоки (ID >= 100) используют текстурный атлас
    if (is_custom_block(in.block_id)) {
        let atlas_uv = get_atlas_uv(in.block_id, uv);
        let tex_color = textureSample(atlas_texture, atlas_sampler, atlas_uv);
        color = tex_color.rgb * lighting;
    } else {
        // Стандартные блоки - процедурные текстуры
        let tex_var = get_texture_variation(in.color, uv, in.world_pos);
        color = in.color * light.color * (1.0 + tex_var) * lighting;
    }
    
    // Туман с динамическим цветом
    let dist = length(in.world_pos.xz - uniforms.camera_pos.xz);
    let fog = smoothstep(800.0, 1000.0, dist);
    color = mix(color, uniforms.fog_color, fog);
    
    return vec4<f32>(color, 1.0);
}


============================================================
FILE: shaders\ui.wgsl
============================================================

// ============================================
// UI Shader - Прицел и другие 2D элементы
// ============================================

struct VertexInput {
    @location(0) position: vec2<f32>,
    @location(1) color: vec4<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) color: vec4<f32>,
}

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    // Позиция уже в NDC (-1 to 1)
    out.clip_position = vec4<f32>(in.position, 0.0, 1.0);
    out.color = in.color;
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    return in.color;
}


============================================================
FILE: subvoxel\components.rs
============================================================

// ============================================
// SubVoxel Components - ECS компоненты (ОПТИМИЗИРОВАННЫЕ)
// ============================================
//
// Использует:
// - SparseChunkStorage вместо ChunkSubVoxelStorage (O(N) память)
// - CompactOctree вместо LinearOctree (4 байта на узел)

use std::collections::HashMap;
use crate::gpu::blocks::{BlockType, AIR};
use super::chunk::{SubVoxelChunkKey, SparseChunkStorage};

/// Уровень детализации субвокселя
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum SubVoxelLevel {
    /// Полный блок 1x1x1
    Full = 0,
    /// Половинный блок 1/2 (8 в одном полном)
    Half = 1,
    /// Четвертинный блок 1/4 (64 в одном полном)
    Quarter = 2,
}

impl SubVoxelLevel {
    #[inline]
    pub fn size(&self) -> f32 {
        match self {
            SubVoxelLevel::Full => 1.0,
            SubVoxelLevel::Half => 0.5,
            SubVoxelLevel::Quarter => 0.25,
        }
    }

    #[inline]
    pub fn divisions(&self) -> u8 {
        match self {
            SubVoxelLevel::Full => 1,
            SubVoxelLevel::Half => 2,
            SubVoxelLevel::Quarter => 4,
        }
    }

    #[inline]
    pub fn depth(&self) -> u8 {
        match self {
            SubVoxelLevel::Full => 0,
            SubVoxelLevel::Half => 1,
            SubVoxelLevel::Quarter => 2,
        }
    }

    pub fn next(&self) -> Self {
        match self {
            SubVoxelLevel::Full => SubVoxelLevel::Half,
            SubVoxelLevel::Half => SubVoxelLevel::Quarter,
            SubVoxelLevel::Quarter => SubVoxelLevel::Full,
        }
    }
}

impl Default for SubVoxelLevel {
    fn default() -> Self {
        SubVoxelLevel::Quarter
    }
}

/// Позиция субвокселя в мире
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct SubVoxelPos {
    pub block_x: i32,
    pub block_y: i32,
    pub block_z: i32,
    pub sub_x: u8,
    pub sub_y: u8,
    pub sub_z: u8,
    pub level: SubVoxelLevel,
}

impl SubVoxelPos {
    #[inline]
    pub fn new(
        block_x: i32, block_y: i32, block_z: i32,
        sub_x: u8, sub_y: u8, sub_z: u8,
        level: SubVoxelLevel,
    ) -> Self {
        Self { block_x, block_y, block_z, sub_x, sub_y, sub_z, level }
    }

    #[inline]
    pub fn world_min(&self) -> [f32; 3] {
        let size = self.level.size();
        [
            self.block_x as f32 + self.sub_x as f32 * size,
            self.block_y as f32 + self.sub_y as f32 * size,
            self.block_z as f32 + self.sub_z as f32 * size,
        ]
    }

    #[inline]
    pub fn chunk_key(&self) -> SubVoxelChunkKey {
        SubVoxelChunkKey::from_block_pos(self.block_x, self.block_z)
    }

    #[inline]
    pub fn local_block(&self) -> (u8, u8, u8) {
        let local_x = self.block_x.rem_euclid(16) as u8;
        let local_z = self.block_z.rem_euclid(16) as u8;
        (local_x, self.block_y as u8, local_z)
    }
}

// ============================================
// SubVoxelWorld - ОПТИМИЗИРОВАННАЯ ВЕРСИЯ
// ============================================

/// Глобальное хранилище субвокселей (ECS Resource)
/// Использует SparseChunkStorage для O(N) памяти
pub struct SubVoxelWorld {
    /// Разреженные хранилища по чанкам
    chunks: HashMap<SubVoxelChunkKey, SparseChunkStorage>,
    /// Грязные чанки
    dirty_chunks: Vec<SubVoxelChunkKey>,
    /// Глобальная версия
    version: u64,
}

impl SubVoxelWorld {
    pub fn new() -> Self {
        Self {
            chunks: HashMap::new(),
            dirty_chunks: Vec::new(),
            version: 0,
        }
    }

    /// Установить субвоксель
    pub fn set(&mut self, pos: SubVoxelPos, block_type: BlockType) {
        let chunk_key = pos.chunk_key();
        let (local_x, local_y, local_z) = pos.local_block();
        
        let chunk = self.chunks.entry(chunk_key).or_insert_with(SparseChunkStorage::new);
        chunk.set(
            local_x, local_y, local_z,
            pos.sub_x, pos.sub_y, pos.sub_z,
            pos.level.depth(),
            block_type,
        );

        if !self.dirty_chunks.contains(&chunk_key) {
            self.dirty_chunks.push(chunk_key);
        }

        if chunk.is_empty() {
            self.chunks.remove(&chunk_key);
        }

        self.version += 1;
    }

    /// Получить субвоксель
    #[inline]
    pub fn get(&self, pos: &SubVoxelPos) -> Option<BlockType> {
        let chunk_key = pos.chunk_key();
        let (local_x, local_y, local_z) = pos.local_block();
        
        self.chunks.get(&chunk_key)?.get(
            local_x, local_y, local_z,
            pos.sub_x, pos.sub_y, pos.sub_z,
            pos.level.depth(),
        )
    }

    /// Удалить субвоксель
    #[inline]
    pub fn remove(&mut self, pos: &SubVoxelPos) {
        self.set(*pos, AIR);
    }

    /// Получить и очистить грязные чанки
    #[inline]
    pub fn take_dirty_chunks(&mut self) -> Vec<SubVoxelChunkKey> {
        std::mem::take(&mut self.dirty_chunks)
    }

    /// Получить хранилище чанка
    #[inline]
    pub fn get_chunk(&self, key: &SubVoxelChunkKey) -> Option<&SparseChunkStorage> {
        self.chunks.get(key)
    }

    /// Итератор по чанкам
    #[inline]
    pub fn iter_chunks(&self) -> impl Iterator<Item = (&SubVoxelChunkKey, &SparseChunkStorage)> {
        self.chunks.iter()
    }

    #[inline]
    pub fn chunk_count(&self) -> usize {
        self.chunks.len()
    }

    #[inline]
    pub fn version(&self) -> u64 {
        self.version
    }

    /// Общее использование памяти (байт)
    pub fn memory_usage(&self) -> usize {
        self.chunks.values().map(|c| c.memory_usage()).sum()
    }

    /// Проверка коллизии AABB
    pub fn check_aabb_collision(
        &self,
        min_x: f32, min_y: f32, min_z: f32,
        max_x: f32, max_y: f32, max_z: f32,
    ) -> bool {
        let min_chunk_x = (min_x.floor() as i32).div_euclid(16);
        let max_chunk_x = (max_x.ceil() as i32).div_euclid(16);
        let min_chunk_z = (min_z.floor() as i32).div_euclid(16);
        let max_chunk_z = (max_z.ceil() as i32).div_euclid(16);

        for cx in min_chunk_x..=max_chunk_x {
            for cz in min_chunk_z..=max_chunk_z {
                let key = SubVoxelChunkKey::new(cx, cz);
                if let Some(chunk) = self.chunks.get(&key) {
                    if check_chunk_aabb_collision(chunk, cx, cz, min_x, min_y, min_z, max_x, max_y, max_z) {
                        return true;
                    }
                }
            }
        }
        false
    }
}

impl Default for SubVoxelWorld {
    fn default() -> Self {
        Self::new()
    }
}

/// Проверка коллизии AABB с чанком
fn check_chunk_aabb_collision(
    chunk: &SparseChunkStorage,
    chunk_x: i32, chunk_z: i32,
    min_x: f32, min_y: f32, min_z: f32,
    max_x: f32, max_y: f32, max_z: f32,
) -> bool {
    let base_x = chunk_x * 16;
    let base_z = chunk_z * 16;

    for (key, octree) in chunk.iter_blocks() {
        let (bx, by, bz) = key.unpack();
        let block_x = (base_x + bx as i32) as f32;
        let block_y = by as f32;
        let block_z = (base_z + bz as i32) as f32;

        // Быстрая проверка AABB блока
        if max_x <= block_x || min_x >= block_x + 1.0 ||
           max_y <= block_y || min_y >= block_y + 1.0 ||
           max_z <= block_z || min_z >= block_z + 1.0 {
            continue;
        }

        // Детальная проверка через октодерево
        for (sx, sy, sz, size, _bt) in octree.iter_solid() {
            let sv_min_x = block_x + sx;
            let sv_min_y = block_y + sy;
            let sv_min_z = block_z + sz;
            let sv_max_x = sv_min_x + size;
            let sv_max_y = sv_min_y + size;
            let sv_max_z = sv_min_z + size;

            if max_x > sv_min_x && min_x < sv_max_x &&
               max_y > sv_min_y && min_y < sv_max_y &&
               max_z > sv_min_z && min_z < sv_max_z {
                return true;
            }
        }
    }
    false
}


============================================================
FILE: subvoxel\mod.rs
============================================================

// ============================================
// SubVoxel Module - Система субвокселей
// ============================================
//
// Две реализации:
// 1. Legacy (subvoxel.rs, subvoxel_render.rs) - используется сейчас
// 2. Optimized (chunk/, octree/, meshing/) - новая архитектура
//
// Оптимизации в новой версии:
// - SparseChunkStorage: O(N) память вместо ~3.5 МБ на чанк
// - CompactOctree: 4 байта на узел вместо 16+
// - PackedVertex: 8 байт вместо 36
// - MaskGreedy: битовые маски без сортировки

pub mod octree;
pub mod chunk;
pub mod meshing;
pub mod components;
pub mod systems;
pub mod render;

// Legacy API (используется в текущем коде)
mod subvoxel;
pub mod subvoxel_render;

pub use subvoxel::{
    SubVoxelLevel, SubVoxelPos, SubVoxelStorage, SubVoxel, SubVoxelHit,
    world_to_subvoxel, subvoxel_intersects_player, placement_pos_from_hit,
};
pub use subvoxel_render::SubVoxelRenderer;

// Оптимизированный API (для миграции)
pub use components::{
    SubVoxelLevel as OptSubVoxelLevel,
    SubVoxelPos as OptSubVoxelPos,
    SubVoxelWorld,
};
pub use chunk::{SubVoxelChunkKey, SparseChunkStorage, PackedBlockKey};
pub use octree::{CompactOctree, CompactNode};
pub use meshing::{PackedVertex, MaskGreedyContext, greedy_mesh_masked};
pub use render::OptimizedSubVoxelRenderer;
pub use systems::{
    MeshingSystemContext, MeshingConfig, ChunkMesh,
    mark_chunk_dirty, process_meshing_queue, get_meshing_stats,
};


============================================================
FILE: subvoxel\subvoxel.rs
============================================================

// ============================================
// SubVoxel System - Система ку-вокселей
// ============================================
// Позволяет размещать блоки меньшего размера (1/2, 1/4 от обычного)

use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use crate::gpu::blocks::{BlockType, AIR};

/// Уровень детализации суб-вокселя
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum SubVoxelLevel {
    /// Обычный блок 1x1x1
    Full = 0,
    /// Половинный блок 1/2 (8 в одном полном)
    Half = 1,
    /// Четвертинный блок 1/4 (64 в одном полном)
    Quarter = 2,
}

impl SubVoxelLevel {
    /// Размер блока на этом уровне
    pub fn size(&self) -> f32 {
        match self {
            SubVoxelLevel::Full => 1.0,
            SubVoxelLevel::Half => 0.5,
            SubVoxelLevel::Quarter => 0.25,
        }
    }
    
    /// Количество делений на ось
    pub fn divisions(&self) -> u8 {
        match self {
            SubVoxelLevel::Full => 1,
            SubVoxelLevel::Half => 2,
            SubVoxelLevel::Quarter => 4,
        }
    }
    
    /// Следующий уровень (меньше)
    pub fn next(&self) -> Self {
        match self {
            SubVoxelLevel::Full => SubVoxelLevel::Half,
            SubVoxelLevel::Half => SubVoxelLevel::Quarter,
            SubVoxelLevel::Quarter => SubVoxelLevel::Full, // Цикл обратно
        }
    }
    
    /// Название уровня
    pub fn name(&self) -> &'static str {
        match self {
            SubVoxelLevel::Full => "1x1x1",
            SubVoxelLevel::Half => "1/2",
            SubVoxelLevel::Quarter => "1/4",
        }
    }
}

impl Default for SubVoxelLevel {
    fn default() -> Self {
        SubVoxelLevel::Full
    }
}

/// Позиция суб-вокселя в мире
/// Для Half: sub_x/y/z = 0 или 1
/// Для Quarter: sub_x/y/z = 0, 1, 2 или 3
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct SubVoxelPos {
    /// Позиция базового блока
    pub block_x: i32,
    pub block_y: i32,
    pub block_z: i32,
    /// Позиция внутри блока (зависит от уровня)
    pub sub_x: u8,
    pub sub_y: u8,
    pub sub_z: u8,
    /// Уровень детализации
    pub level: SubVoxelLevel,
}

impl SubVoxelPos {
    pub fn new(block_x: i32, block_y: i32, block_z: i32, sub_x: u8, sub_y: u8, sub_z: u8, level: SubVoxelLevel) -> Self {
        Self { block_x, block_y, block_z, sub_x, sub_y, sub_z, level }
    }
    
    /// Создать позицию для полного блока
    pub fn full(x: i32, y: i32, z: i32) -> Self {
        Self::new(x, y, z, 0, 0, 0, SubVoxelLevel::Full)
    }
    
    /// Мировые координаты центра суб-вокселя
    pub fn world_center(&self) -> [f32; 3] {
        let size = self.level.size();
        let half = size / 2.0;
        [
            self.block_x as f32 + self.sub_x as f32 * size + half,
            self.block_y as f32 + self.sub_y as f32 * size + half,
            self.block_z as f32 + self.sub_z as f32 * size + half,
        ]
    }
    
    /// Мировые координаты минимального угла суб-вокселя
    pub fn world_min(&self) -> [f32; 3] {
        let size = self.level.size();
        [
            self.block_x as f32 + self.sub_x as f32 * size,
            self.block_y as f32 + self.sub_y as f32 * size,
            self.block_z as f32 + self.sub_z as f32 * size,
        ]
    }
}

/// Суб-воксель с типом блока
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub struct SubVoxel {
    pub pos: SubVoxelPos,
    pub block_type: BlockType,
}

/// Хранилище суб-вокселей
pub struct SubVoxelStorage {
    /// Суб-воксели по позиции
    subvoxels: HashMap<SubVoxelPos, BlockType>,
    /// Версия для отслеживания изменений
    version: u64,
}

impl SubVoxelStorage {
    pub fn new() -> Self {
        Self {
            subvoxels: HashMap::new(),
            version: 0,
        }
    }
    
    /// Проверить коллизию AABB с любым суб-вокселем
    pub fn check_aabb_collision(&self, min_x: f32, min_y: f32, min_z: f32, max_x: f32, max_y: f32, max_z: f32) -> bool {
        for (pos, block_type) in &self.subvoxels {
            if *block_type == AIR {
                continue;
            }
            
            let size = pos.level.size();
            let [sv_min_x, sv_min_y, sv_min_z] = pos.world_min();
            let sv_max_x = sv_min_x + size;
            let sv_max_y = sv_min_y + size;
            let sv_max_z = sv_min_z + size;
            
            // AABB intersection test
            if max_x > sv_min_x && min_x < sv_max_x &&
               max_y > sv_min_y && min_y < sv_max_y &&
               max_z > sv_min_z && min_z < sv_max_z {
                return true;
            }
        }
        false
    }
    
    /// Добавить суб-воксель
    pub fn set(&mut self, pos: SubVoxelPos, block_type: BlockType) {
        if block_type == AIR {
            self.subvoxels.remove(&pos);
        } else {
            self.subvoxels.insert(pos, block_type);
        }
        self.version += 1;
    }
    
    /// Получить суб-воксель
    pub fn get(&self, pos: &SubVoxelPos) -> Option<BlockType> {
        self.subvoxels.get(pos).copied()
    }
    
    /// Удалить суб-воксель
    pub fn remove(&mut self, pos: &SubVoxelPos) -> Option<BlockType> {
        self.version += 1;
        self.subvoxels.remove(pos)
    }
    
    /// Версия хранилища
    pub fn version(&self) -> u64 {
        self.version
    }
    
    /// Количество суб-вокселей
    pub fn count(&self) -> usize {
        self.subvoxels.len()
    }
    
    /// Получить все суб-воксели для сериализации
    pub fn get_all(&self) -> Vec<SubVoxel> {
        self.subvoxels.iter()
            .map(|(pos, block_type)| SubVoxel { pos: *pos, block_type: *block_type })
            .collect()
    }
    
    /// Загрузить суб-воксели
    pub fn load(&mut self, subvoxels: Vec<SubVoxel>) {
        self.subvoxels.clear();
        for sv in subvoxels {
            self.subvoxels.insert(sv.pos, sv.block_type);
        }
        self.version += 1;
    }
    
    /// Получить суб-воксели в области (для рендеринга)
    pub fn get_in_region(&self, min_x: i32, min_y: i32, min_z: i32, max_x: i32, max_y: i32, max_z: i32) -> Vec<SubVoxel> {
        self.subvoxels.iter()
            .filter(|(pos, _)| {
                pos.block_x >= min_x && pos.block_x <= max_x &&
                pos.block_y >= min_y && pos.block_y <= max_y &&
                pos.block_z >= min_z && pos.block_z <= max_z
            })
            .map(|(pos, block_type)| SubVoxel { pos: *pos, block_type: *block_type })
            .collect()
    }
}

impl Default for SubVoxelStorage {
    fn default() -> Self {
        Self::new()
    }
}

/// Вычислить позицию суб-вокселя из мировых координат
pub fn world_to_subvoxel(world_x: f32, world_y: f32, world_z: f32, level: SubVoxelLevel) -> SubVoxelPos {
    let size = level.size();
    let divisions = level.divisions() as f32;
    
    // Базовый блок
    let block_x = world_x.floor() as i32;
    let block_y = world_y.floor() as i32;
    let block_z = world_z.floor() as i32;
    
    // Позиция внутри блока
    let local_x = world_x - block_x as f32;
    let local_y = world_y - block_y as f32;
    let local_z = world_z - block_z as f32;
    
    // Индекс суб-вокселя
    let sub_x = ((local_x / size).floor() as u8).min(level.divisions() - 1);
    let sub_y = ((local_y / size).floor() as u8).min(level.divisions() - 1);
    let sub_z = ((local_z / size).floor() as u8).min(level.divisions() - 1);
    
    SubVoxelPos::new(block_x, block_y, block_z, sub_x, sub_y, sub_z, level)
}

/// Проверка пересечения суб-вокселя с AABB игрока
pub fn subvoxel_intersects_player(
    pos: &SubVoxelPos,
    player_x: f32, player_y: f32, player_z: f32,
    player_radius: f32, player_height: f32
) -> bool {
    let size = pos.level.size();
    let [sv_x, sv_y, sv_z] = pos.world_min();
    
    // AABB суб-вокселя
    let sv_max_x = sv_x + size;
    let sv_max_y = sv_y + size;
    let sv_max_z = sv_z + size;
    
    // AABB игрока
    let p_min_x = player_x - player_radius;
    let p_max_x = player_x + player_radius;
    let p_min_y = player_y;
    let p_max_y = player_y + player_height;
    let p_min_z = player_z - player_radius;
    let p_max_z = player_z + player_radius;
    
    // Проверка пересечения
    p_max_x > sv_x && p_min_x < sv_max_x &&
    p_max_y > sv_y && p_min_y < sv_max_y &&
    p_max_z > sv_z && p_min_z < sv_max_z
}

/// Результат raycast по суб-вокселям
#[derive(Clone, Copy, Debug)]
pub struct SubVoxelHit {
    pub pos: SubVoxelPos,
    pub block_type: BlockType,
    pub hit_point: [f32; 3],
    pub hit_normal: [f32; 3],
    pub distance: f32,
}

impl SubVoxelStorage {
    /// Raycast через суб-воксели
    /// Возвращает ближайший суб-воксель на пути луча
    pub fn raycast(
        &self,
        origin: [f32; 3],
        direction: [f32; 3],
        max_distance: f32,
        level: SubVoxelLevel,
    ) -> Option<SubVoxelHit> {
        let size = level.size();
        let mut closest_hit: Option<SubVoxelHit> = None;
        
        // Проверяем все суб-воксели (можно оптимизировать с spatial hash)
        for (pos, &block_type) in &self.subvoxels {
            // Пропускаем суб-воксели другого уровня
            if pos.level != level {
                continue;
            }
            
            let [min_x, min_y, min_z] = pos.world_min();
            let max_x = min_x + size;
            let max_y = min_y + size;
            let max_z = min_z + size;
            
            // Ray-AABB intersection
            if let Some((t, normal)) = ray_aabb_intersection(
                origin, direction,
                [min_x, min_y, min_z],
                [max_x, max_y, max_z],
            ) {
                if t > 0.0 && t < max_distance {
                    if closest_hit.is_none() || t < closest_hit.as_ref().unwrap().distance {
                        closest_hit = Some(SubVoxelHit {
                            pos: *pos,
                            block_type,
                            hit_point: [
                                origin[0] + direction[0] * t,
                                origin[1] + direction[1] * t,
                                origin[2] + direction[2] * t,
                            ],
                            hit_normal: normal,
                            distance: t,
                        });
                    }
                }
            }
        }
        
        closest_hit
    }
}

/// Ray-AABB intersection test
/// Returns (t, normal) where t is distance along ray and normal is hit face normal
fn ray_aabb_intersection(
    origin: [f32; 3],
    direction: [f32; 3],
    aabb_min: [f32; 3],
    aabb_max: [f32; 3],
) -> Option<(f32, [f32; 3])> {
    let mut t_min = f32::NEG_INFINITY;
    let mut t_max = f32::INFINITY;
    let mut normal = [0.0f32; 3];
    
    for i in 0..3 {
        if direction[i].abs() < 1e-8 {
            // Ray is parallel to slab
            if origin[i] < aabb_min[i] || origin[i] > aabb_max[i] {
                return None;
            }
        } else {
            let inv_d = 1.0 / direction[i];
            let mut t1 = (aabb_min[i] - origin[i]) * inv_d;
            let mut t2 = (aabb_max[i] - origin[i]) * inv_d;
            
            let mut n = [0.0f32; 3];
            n[i] = -1.0;
            
            if t1 > t2 {
                std::mem::swap(&mut t1, &mut t2);
                n[i] = 1.0;
            }
            
            if t1 > t_min {
                t_min = t1;
                normal = n;
            }
            t_max = t_max.min(t2);
            
            if t_min > t_max {
                return None;
            }
        }
    }
    
    Some((t_min, normal))
}

/// Вычислить позицию для размещения суб-вокселя рядом с hit
pub fn placement_pos_from_hit(hit: &SubVoxelHit, level: SubVoxelLevel) -> SubVoxelPos {
    let size = level.size();
    // Смещаем точку попадания немного в направлении нормали
    let place_x = hit.hit_point[0] + hit.hit_normal[0] * (size * 0.5);
    let place_y = hit.hit_point[1] + hit.hit_normal[1] * (size * 0.5);
    let place_z = hit.hit_point[2] + hit.hit_normal[2] * (size * 0.5);
    
    world_to_subvoxel(place_x, place_y, place_z, level)
}


============================================================
FILE: subvoxel\subvoxel_render.rs
============================================================

// ============================================
// SubVoxel Renderer - Рендеринг ку-вокселей
// ============================================

use super::subvoxel::{SubVoxelStorage, SubVoxel};
use crate::gpu::terrain::mesh::TerrainVertex;
use crate::gpu::blocks::get_face_colors;

/// Рендерер суб-вокселей
pub struct SubVoxelRenderer {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    num_indices: u32,
    capacity: usize,
    last_version: u64,
}

impl SubVoxelRenderer {
    pub fn new(device: &wgpu::Device) -> Self {
        let capacity = 1000; // Начальная ёмкость
        
        let vertex_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("SubVoxel Vertex Buffer"),
            size: (capacity * 24 * std::mem::size_of::<TerrainVertex>()) as u64,
            usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
            mapped_at_creation: false,
        });
        
        let index_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("SubVoxel Index Buffer"),
            size: (capacity * 36 * std::mem::size_of::<u32>()) as u64,
            usage: wgpu::BufferUsages::INDEX | wgpu::BufferUsages::COPY_DST,
            mapped_at_creation: false,
        });
        
        Self {
            vertex_buffer,
            index_buffer,
            num_indices: 0,
            capacity,
            last_version: 0,
        }
    }
    
    /// Обновить меш суб-вокселей
    pub fn update(&mut self, device: &wgpu::Device, queue: &wgpu::Queue, storage: &SubVoxelStorage) {
        if storage.version() == self.last_version {
            return;
        }
        self.last_version = storage.version();
        
        let subvoxels = storage.get_all();
        if subvoxels.is_empty() {
            self.num_indices = 0;
            return;
        }
        
        // Генерируем меш
        let (vertices, indices) = generate_subvoxel_mesh(&subvoxels);
        
        if vertices.is_empty() {
            self.num_indices = 0;
            return;
        }
        
        // Проверяем ёмкость
        let needed_capacity = subvoxels.len();
        if needed_capacity > self.capacity {
            self.capacity = needed_capacity * 2;
            
            self.vertex_buffer = device.create_buffer(&wgpu::BufferDescriptor {
                label: Some("SubVoxel Vertex Buffer"),
                size: (self.capacity * 24 * std::mem::size_of::<TerrainVertex>()) as u64,
                usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
                mapped_at_creation: false,
            });
            
            self.index_buffer = device.create_buffer(&wgpu::BufferDescriptor {
                label: Some("SubVoxel Index Buffer"),
                size: (self.capacity * 36 * std::mem::size_of::<u32>()) as u64,
                usage: wgpu::BufferUsages::INDEX | wgpu::BufferUsages::COPY_DST,
                mapped_at_creation: false,
            });
        }
        
        // Записываем данные
        queue.write_buffer(&self.vertex_buffer, 0, bytemuck::cast_slice(&vertices));
        queue.write_buffer(&self.index_buffer, 0, bytemuck::cast_slice(&indices));
        self.num_indices = indices.len() as u32;
    }
    
    /// Получить буферы для рендеринга
    pub fn vertex_buffer(&self) -> &wgpu::Buffer {
        &self.vertex_buffer
    }
    
    pub fn index_buffer(&self) -> &wgpu::Buffer {
        &self.index_buffer
    }
    
    pub fn num_indices(&self) -> u32 {
        self.num_indices
    }
    
    pub fn has_content(&self) -> bool {
        self.num_indices > 0
    }
}

/// Генерация меша для суб-вокселей
fn generate_subvoxel_mesh(subvoxels: &[SubVoxel]) -> (Vec<TerrainVertex>, Vec<u32>) {
    let mut vertices = Vec::with_capacity(subvoxels.len() * 24);
    let mut indices = Vec::with_capacity(subvoxels.len() * 36);
    
    for sv in subvoxels {
        let size = sv.pos.level.size();
        let [x, y, z] = sv.pos.world_min();
        let (top_color, side_color) = get_face_colors(sv.block_type);
        
        add_cube(&mut vertices, &mut indices, x, y, z, size, top_color, side_color);
    }
    
    (vertices, indices)
}

/// Добавить куб в меш
fn add_cube(
    vertices: &mut Vec<TerrainVertex>,
    indices: &mut Vec<u32>,
    x: f32, y: f32, z: f32,
    size: f32,
    top_color: [f32; 3],
    side_color: [f32; 3],
) {
    let base_idx = vertices.len() as u32;
    
    let x1 = x + size;
    let y1 = y + size;
    let z1 = z + size;
    
    let bottom_color = [side_color[0] * 0.5, side_color[1] * 0.5, side_color[2] * 0.5];
    
    // Top face (+Y) - CCW when viewed from above
    vertices.push(TerrainVertex { position: [x, y1, z], normal: [0.0, 1.0, 0.0], color: top_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x, y1, z1], normal: [0.0, 1.0, 0.0], color: top_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x1, y1, z1], normal: [0.0, 1.0, 0.0], color: top_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x1, y1, z], normal: [0.0, 1.0, 0.0], color: top_color, block_id: 0 });
    
    // Bottom face (-Y) - CCW when viewed from below
    vertices.push(TerrainVertex { position: [x, y, z], normal: [0.0, -1.0, 0.0], color: bottom_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x1, y, z], normal: [0.0, -1.0, 0.0], color: bottom_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x1, y, z1], normal: [0.0, -1.0, 0.0], color: bottom_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x, y, z1], normal: [0.0, -1.0, 0.0], color: bottom_color, block_id: 0 });
    
    // Front face (+Z) - CCW when viewed from front
    vertices.push(TerrainVertex { position: [x, y, z1], normal: [0.0, 0.0, 1.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x1, y, z1], normal: [0.0, 0.0, 1.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x1, y1, z1], normal: [0.0, 0.0, 1.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x, y1, z1], normal: [0.0, 0.0, 1.0], color: side_color, block_id: 0 });
    
    // Back face (-Z) - CCW when viewed from back
    vertices.push(TerrainVertex { position: [x1, y, z], normal: [0.0, 0.0, -1.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x, y, z], normal: [0.0, 0.0, -1.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x, y1, z], normal: [0.0, 0.0, -1.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x1, y1, z], normal: [0.0, 0.0, -1.0], color: side_color, block_id: 0 });
    
    // Right face (+X) - CCW when viewed from right
    vertices.push(TerrainVertex { position: [x1, y, z1], normal: [1.0, 0.0, 0.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x1, y, z], normal: [1.0, 0.0, 0.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x1, y1, z], normal: [1.0, 0.0, 0.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x1, y1, z1], normal: [1.0, 0.0, 0.0], color: side_color, block_id: 0 });
    
    // Left face (-X) - CCW when viewed from left
    vertices.push(TerrainVertex { position: [x, y, z], normal: [-1.0, 0.0, 0.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x, y, z1], normal: [-1.0, 0.0, 0.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x, y1, z1], normal: [-1.0, 0.0, 0.0], color: side_color, block_id: 0 });
    vertices.push(TerrainVertex { position: [x, y1, z], normal: [-1.0, 0.0, 0.0], color: side_color, block_id: 0 });
    
    // Indices for 6 faces (2 triangles each) - CCW winding
    for face in 0..6 {
        let i = base_idx + face * 4;
        indices.extend_from_slice(&[i, i + 1, i + 2, i, i + 2, i + 3]);
    }
}


============================================================
FILE: subvoxel\chunk\key.rs
============================================================

// ============================================
// Chunk Key - Ключ чанка для субвокселей
// ============================================

/// Ключ чанка (координаты чанка)
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]
pub struct SubVoxelChunkKey {
    pub x: i32,
    pub z: i32,
}

impl SubVoxelChunkKey {
    #[inline]
    pub fn new(x: i32, z: i32) -> Self {
        Self { x, z }
    }

    /// Из мировых координат блока
    #[inline]
    pub fn from_block_pos(block_x: i32, block_z: i32) -> Self {
        Self {
            x: block_x.div_euclid(16),
            z: block_z.div_euclid(16),
        }
    }

    /// Из мировых координат (float)
    #[inline]
    pub fn from_world_pos(world_x: f32, world_z: f32) -> Self {
        Self::from_block_pos(world_x.floor() as i32, world_z.floor() as i32)
    }
}


============================================================
FILE: subvoxel\chunk\mod.rs
============================================================

// ============================================
// Chunk Module - Чанковое хранение субвокселей
// ============================================
//
// Две реализации:
// - ChunkSubVoxelStorage: Оригинальная (плоский массив, ~3.5 МБ на чанк)
// - SparseChunkStorage: Оптимизированная (HashMap, O(N) память)

mod key;
mod storage;
mod sparse_storage;

pub use key::SubVoxelChunkKey;
pub use storage::{
    ChunkSubVoxelStorage, LocalBlockKey, RaycastHit,
    CHUNK_SIZE, CHUNK_HEIGHT, STORAGE_SIZE,
};
pub use sparse_storage::{SparseChunkStorage, PackedBlockKey};


============================================================
FILE: subvoxel\chunk\sparse_storage.rs
============================================================

// ============================================
// Sparse Chunk Storage - Разреженное хранение субвокселей
// ============================================
//
// Вместо Vec<Option<LinearOctree>> размером 65536 элементов (~3.5 МБ)
// используем HashMap с интовыми ключами. Память O(N) где N = занятые блоки.

use std::collections::HashMap;
use crate::gpu::blocks::{BlockType, AIR};
use super::super::octree::CompactOctree;

/// Упакованный ключ блока внутри чанка (20 бит: 4+8+4 для x,y,z)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct PackedBlockKey(u32);

impl PackedBlockKey {
    #[inline]
    pub fn new(x: u8, y: u8, z: u8) -> Self {
        debug_assert!(x < 16 && z < 16);
        Self(((y as u32) << 8) | ((z as u32) << 4) | (x as u32))
    }

    #[inline]
    pub fn unpack(self) -> (u8, u8, u8) {
        let x = (self.0 & 0xF) as u8;
        let z = ((self.0 >> 4) & 0xF) as u8;
        let y = ((self.0 >> 8) & 0xFF) as u8;
        (x, y, z)
    }

    #[inline]
    pub fn x(self) -> u8 { (self.0 & 0xF) as u8 }
    
    #[inline]
    pub fn y(self) -> u8 { ((self.0 >> 8) & 0xFF) as u8 }
    
    #[inline]
    pub fn z(self) -> u8 { ((self.0 >> 4) & 0xF) as u8 }
}

/// Разреженное хранилище субвокселей для чанка
/// Память: O(N) где N = количество блоков с субвокселями
/// Типичный чанк: 10-100 блоков = 1-10 КБ вместо 3.5 МБ
pub struct SparseChunkStorage {
    /// HashMap вместо плоского массива
    blocks: HashMap<PackedBlockKey, CompactOctree>,
    /// Версия для отслеживания изменений
    version: u64,
    /// Флаг грязности
    dirty: bool,
    /// Кэш min/max Y для быстрого доступа
    min_y: u8,
    max_y: u8,
}

impl SparseChunkStorage {
    pub fn new() -> Self {
        Self {
            blocks: HashMap::with_capacity(16), // Начинаем с малого
            version: 0,
            dirty: false,
            min_y: 255,
            max_y: 0,
        }
    }

    #[inline]
    pub fn is_empty(&self) -> bool {
        self.blocks.is_empty()
    }

    #[inline]
    pub fn block_count(&self) -> usize {
        self.blocks.len()
    }

    #[inline]
    pub fn is_dirty(&self) -> bool {
        self.dirty
    }

    #[inline]
    pub fn clear_dirty(&mut self) {
        self.dirty = false;
    }

    #[inline]
    pub fn version(&self) -> u64 {
        self.version
    }

    #[inline]
    pub fn y_range(&self) -> (u8, u8) {
        (self.min_y, self.max_y)
    }

    /// Установить субвоксель
    pub fn set(
        &mut self,
        block_x: u8, block_y: u8, block_z: u8,
        sub_x: u8, sub_y: u8, sub_z: u8,
        depth: u8,
        block_type: BlockType,
    ) {
        let key = PackedBlockKey::new(block_x, block_y, block_z);

        if block_type == AIR {
            // Удаление
            if let Some(octree) = self.blocks.get_mut(&key) {
                octree.remove(sub_x, sub_y, sub_z, depth);
                if octree.is_empty() {
                    self.blocks.remove(&key);
                    self.update_y_bounds();
                }
            }
        } else {
            // Добавление
            let octree = self.blocks.entry(key).or_insert_with(CompactOctree::new);
            octree.set(sub_x, sub_y, sub_z, depth, block_type);
            
            // Обновляем Y bounds
            self.min_y = self.min_y.min(block_y);
            self.max_y = self.max_y.max(block_y);
        }

        self.dirty = true;
        self.version += 1;
    }

    /// Получить субвоксель
    #[inline]
    pub fn get(
        &self,
        block_x: u8, block_y: u8, block_z: u8,
        sub_x: u8, sub_y: u8, sub_z: u8,
        depth: u8,
    ) -> Option<BlockType> {
        let key = PackedBlockKey::new(block_x, block_y, block_z);
        self.blocks.get(&key)?.get(sub_x, sub_y, sub_z, depth)
    }

    /// Получить октодерево блока
    #[inline]
    pub fn get_block(&self, block_x: u8, block_y: u8, block_z: u8) -> Option<&CompactOctree> {
        let key = PackedBlockKey::new(block_x, block_y, block_z);
        self.blocks.get(&key)
    }

    /// Итератор по занятым блокам
    #[inline]
    pub fn iter_blocks(&self) -> impl Iterator<Item = (PackedBlockKey, &CompactOctree)> {
        self.blocks.iter().map(|(&k, v)| (k, v))
    }

    /// Проверка solid в точке (для culling)
    #[inline]
    pub fn is_solid_at(&self, block_x: u8, block_y: u8, block_z: u8, sub_x: u8, sub_y: u8, sub_z: u8, depth: u8) -> bool {
        self.get(block_x, block_y, block_z, sub_x, sub_y, sub_z, depth).is_some()
    }

    /// Обновить Y bounds после удаления
    fn update_y_bounds(&mut self) {
        if self.blocks.is_empty() {
            self.min_y = 255;
            self.max_y = 0;
            return;
        }

        self.min_y = 255;
        self.max_y = 0;
        for key in self.blocks.keys() {
            let y = key.y();
            self.min_y = self.min_y.min(y);
            self.max_y = self.max_y.max(y);
        }
    }

    /// Память в байтах (приблизительно)
    pub fn memory_usage(&self) -> usize {
        std::mem::size_of::<Self>() + 
        self.blocks.len() * (std::mem::size_of::<PackedBlockKey>() + std::mem::size_of::<CompactOctree>())
    }
}

impl Default for SparseChunkStorage {
    fn default() -> Self {
        Self::new()
    }
}


============================================================
FILE: subvoxel\chunk\storage.rs
============================================================

// ============================================
// Chunk SubVoxel Storage - Плоский массив для O(1) доступа
// ============================================
//
// Вместо HashMap используем Vec<Option<LinearOctree>> с индексацией:
// index = y * 256 + z * 16 + x
// Это дает O(1) доступ вместо хеширования.

use crate::gpu::blocks::{BlockType, AIR};
use super::super::octree::LinearOctree;

/// Размер чанка
pub const CHUNK_SIZE: usize = 16;
/// Высота мира (для Y координаты)
pub const CHUNK_HEIGHT: usize = 256;
/// Общий размер массива
pub const STORAGE_SIZE: usize = CHUNK_HEIGHT * CHUNK_SIZE * CHUNK_SIZE;

/// Ключ блока внутри чанка (локальные координаты)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct LocalBlockKey {
    pub x: u8,
    pub y: u8,
    pub z: u8,
}

impl LocalBlockKey {
    #[inline]
    pub fn new(x: u8, y: u8, z: u8) -> Self {
        Self { x, y, z }
    }

    /// Из мировых координат блока и координат чанка
    #[inline]
    pub fn from_world(block_x: i32, block_y: i32, block_z: i32, chunk_x: i32, chunk_z: i32) -> Self {
        let local_x = (block_x - chunk_x * 16).rem_euclid(16) as u8;
        let local_z = (block_z - chunk_z * 16).rem_euclid(16) as u8;
        Self {
            x: local_x,
            y: block_y as u8,
            z: local_z,
        }
    }

    /// Индекс в плоском массиве
    #[inline]
    pub fn to_index(&self) -> usize {
        (self.y as usize) * 256 + (self.z as usize) * 16 + (self.x as usize)
    }

    /// Из индекса в плоском массиве
    #[inline]
    pub fn from_index(index: usize) -> Self {
        let y = (index / 256) as u8;
        let z = ((index % 256) / 16) as u8;
        let x = (index % 16) as u8;
        Self { x, y, z }
    }
}

/// Хранилище субвокселей для одного чанка
/// Использует плоский массив для O(1) доступа
pub struct ChunkSubVoxelStorage {
    /// Плоский массив октодеревьев (None = нет субвокселей в этом блоке)
    /// Индексация: y * 256 + z * 16 + x
    blocks: Vec<Option<LinearOctree>>,
    /// Количество непустых блоков (для быстрой проверки is_empty)
    block_count: usize,
    /// Список индексов непустых блоков (для быстрой итерации)
    occupied_indices: Vec<usize>,
    /// Флаг "грязности"
    dirty: bool,
    /// Версия для отслеживания изменений
    version: u64,
}

impl ChunkSubVoxelStorage {
    pub fn new() -> Self {
        Self {
            blocks: vec![None; STORAGE_SIZE],
            block_count: 0,
            occupied_indices: Vec::with_capacity(64),
            dirty: false,
            version: 0,
        }
    }

    #[inline]
    pub fn is_empty(&self) -> bool {
        self.block_count == 0
    }

    #[inline]
    pub fn is_dirty(&self) -> bool {
        self.dirty
    }

    #[inline]
    pub fn clear_dirty(&mut self) {
        self.dirty = false;
    }

    #[inline]
    pub fn mark_dirty(&mut self) {
        self.dirty = true;
    }

    #[inline]
    pub fn version(&self) -> u64 {
        self.version
    }

    /// Индекс в плоском массиве
    #[inline]
    fn index(x: u8, y: u8, z: u8) -> usize {
        (y as usize) * 256 + (z as usize) * 16 + (x as usize)
    }

    /// Установить субвоксель
    pub fn set(
        &mut self,
        local_x: u8, local_y: u8, local_z: u8,
        sub_x: u8, sub_y: u8, sub_z: u8,
        divisions: u8,
        block_type: BlockType,
    ) {
        let depth = match divisions {
            1 => 0,
            2 => 1,
            4 => 2,
            _ => return,
        };

        let idx = Self::index(local_x, local_y, local_z);

        if block_type == AIR {
            // Удаление
            if let Some(ref mut octree) = self.blocks[idx] {
                octree.remove_discrete(sub_x, sub_y, sub_z, depth);
                if octree.is_empty() {
                    self.blocks[idx] = None;
                    self.block_count -= 1;
                    self.occupied_indices.retain(|&i| i != idx);
                }
            }
        } else {
            // Добавление
            let was_empty = self.blocks[idx].is_none();
            let octree = self.blocks[idx].get_or_insert_with(LinearOctree::new);
            octree.set_discrete(sub_x, sub_y, sub_z, depth, block_type);
            
            if was_empty {
                self.block_count += 1;
                self.occupied_indices.push(idx);
            }
        }

        self.dirty = true;
        self.version += 1;
    }

    /// Получить субвоксель - O(1)
    #[inline]
    pub fn get(
        &self,
        local_x: u8, local_y: u8, local_z: u8,
        sub_x: u8, sub_y: u8, sub_z: u8,
        divisions: u8,
    ) -> Option<BlockType> {
        let depth = match divisions {
            1 => 0,
            2 => 1,
            4 => 2,
            _ => return None,
        };

        let idx = Self::index(local_x, local_y, local_z);
        self.blocks[idx].as_ref()?.get_discrete(sub_x, sub_y, sub_z, depth)
    }

    /// Получить октодерево для блока - O(1)
    #[inline]
    pub fn get_block_octree(&self, local_x: u8, local_y: u8, local_z: u8) -> Option<&LinearOctree> {
        let idx = Self::index(local_x, local_y, local_z);
        self.blocks[idx].as_ref()
    }

    /// Получить мутабельное октодерево - O(1)
    #[inline]
    pub fn get_block_octree_mut(&mut self, local_x: u8, local_y: u8, local_z: u8) -> Option<&mut LinearOctree> {
        let idx = Self::index(local_x, local_y, local_z);
        self.blocks[idx].as_mut()
    }

    /// Удалить все субвоксели в блоке
    pub fn clear_block(&mut self, local_x: u8, local_y: u8, local_z: u8) {
        let idx = Self::index(local_x, local_y, local_z);
        if self.blocks[idx].take().is_some() {
            self.block_count -= 1;
            self.occupied_indices.retain(|&i| i != idx);
            self.dirty = true;
            self.version += 1;
        }
    }

    /// Количество блоков с субвокселями
    #[inline]
    pub fn block_count(&self) -> usize {
        self.block_count
    }

    /// Общее количество субвокселей
    pub fn subvoxel_count(&self) -> usize {
        self.occupied_indices.iter()
            .filter_map(|&idx| self.blocks[idx].as_ref())
            .map(|o| o.count_solid())
            .sum()
    }

    /// Быстрый итератор по непустым блокам (использует occupied_indices)
    pub fn iter_blocks(&self) -> impl Iterator<Item = (LocalBlockKey, &LinearOctree)> {
        self.occupied_indices.iter()
            .filter_map(move |&idx| {
                self.blocks[idx].as_ref().map(|octree| {
                    (LocalBlockKey::from_index(idx), octree)
                })
            })
    }

    /// Проверка коллизии AABB с субвокселями чанка
    pub fn check_aabb_collision(
        &self,
        chunk_x: i32, chunk_z: i32,
        min_x: f32, min_y: f32, min_z: f32,
        max_x: f32, max_y: f32, max_z: f32,
    ) -> bool {
        let base_x = chunk_x * 16;
        let base_z = chunk_z * 16;

        // Определяем диапазон блоков для проверки
        let local_min_x = ((min_x - base_x as f32).floor().max(0.0) as u8).min(15);
        let local_max_x = ((max_x - base_x as f32).ceil().max(0.0) as u8).min(15);
        let local_min_y = (min_y.floor().max(0.0) as u8);
        let local_max_y = (max_y.ceil().max(0.0) as u8).min(255);
        let local_min_z = ((min_z - base_z as f32).floor().max(0.0) as u8).min(15);
        let local_max_z = ((max_z - base_z as f32).ceil().max(0.0) as u8).min(15);

        // Проверяем только блоки в диапазоне
        for y in local_min_y..=local_max_y {
            for z in local_min_z..=local_max_z {
                for x in local_min_x..=local_max_x {
                    let idx = Self::index(x, y, z);
                    let Some(octree) = &self.blocks[idx] else { continue };

                    let block_world_x = (base_x + x as i32) as f32;
                    let block_world_y = y as f32;
                    let block_world_z = (base_z + z as i32) as f32;

                    // Детальная проверка субвокселей
                    for (sx, sy, sz, size, _block_type) in octree.iter_solid() {
                        let sv_min_x = block_world_x + sx;
                        let sv_min_y = block_world_y + sy;
                        let sv_min_z = block_world_z + sz;
                        let sv_max_x = sv_min_x + size;
                        let sv_max_y = sv_min_y + size;
                        let sv_max_z = sv_min_z + size;

                        if max_x > sv_min_x && min_x < sv_max_x &&
                           max_y > sv_min_y && min_y < sv_max_y &&
                           max_z > sv_min_z && min_z < sv_max_z {
                            return true;
                        }
                    }
                }
            }
        }

        false
    }

    /// Raycast через блоки чанка - O(log N) для каждого блока
    pub fn raycast_blocks(
        &self,
        chunk_x: i32, chunk_z: i32,
        origin: [f32; 3],
        direction: [f32; 3],
        max_distance: f32,
    ) -> Option<RaycastHit> {
        let base_x = chunk_x * 16;
        let base_z = chunk_z * 16;

        let mut closest: Option<RaycastHit> = None;

        // Используем occupied_indices для быстрой итерации
        for &idx in &self.occupied_indices {
            let Some(octree) = &self.blocks[idx] else { continue };
            
            let key = LocalBlockKey::from_index(idx);
            let block_world_x = (base_x + key.x as i32) as f32;
            let block_world_y = key.y as f32;
            let block_world_z = (base_z + key.z as i32) as f32;

            // Быстрая проверка - луч пересекает блок?
            let current_max = closest.as_ref().map(|c| c.distance).unwrap_or(max_distance);
            if !ray_intersects_block(origin, direction, block_world_x, block_world_y, block_world_z, current_max) {
                continue;
            }

            // Трансформируем луч в локальные координаты блока [0, 1)
            let local_origin = [
                origin[0] - block_world_x,
                origin[1] - block_world_y,
                origin[2] - block_world_z,
            ];

            // O(log N) raycast через октодерево
            if let Some(hit) = octree.raycast(local_origin, direction, current_max) {
                let world_hit_point = [
                    block_world_x + local_origin[0] + direction[0] * hit.t,
                    block_world_y + local_origin[1] + direction[1] * hit.t,
                    block_world_z + local_origin[2] + direction[2] * hit.t,
                ];

                if closest.is_none() || hit.t < closest.as_ref().unwrap().distance {
                    closest = Some(RaycastHit {
                        block_key: key,
                        sub_pos: [hit.x, hit.y, hit.z],
                        size: hit.size,
                        block_type: hit.block_type,
                        hit_point: world_hit_point,
                        hit_normal: hit.normal,
                        distance: hit.t,
                    });
                }
            }
        }

        closest
    }
}

impl Default for ChunkSubVoxelStorage {
    fn default() -> Self {
        Self::new()
    }
}

/// Результат raycast
#[derive(Clone, Copy, Debug)]
pub struct RaycastHit {
    pub block_key: LocalBlockKey,
    pub sub_pos: [f32; 3],
    pub size: f32,
    pub block_type: BlockType,
    pub hit_point: [f32; 3],
    pub hit_normal: [f32; 3],
    pub distance: f32,
}

/// Быстрая проверка пересечения луча с блоком 1x1x1
#[inline]
fn ray_intersects_block(
    origin: [f32; 3],
    direction: [f32; 3],
    bx: f32, by: f32, bz: f32,
    max_dist: f32,
) -> bool {
    ray_aabb_intersection(
        origin, direction,
        [bx, by, bz],
        [bx + 1.0, by + 1.0, bz + 1.0],
    ).map(|(t, _)| t >= 0.0 && t <= max_dist).unwrap_or(false)
}

/// Ray-AABB intersection
fn ray_aabb_intersection(
    origin: [f32; 3],
    direction: [f32; 3],
    aabb_min: [f32; 3],
    aabb_max: [f32; 3],
) -> Option<(f32, [f32; 3])> {
    let mut t_min = f32::NEG_INFINITY;
    let mut t_max = f32::INFINITY;
    let mut normal = [0.0f32; 3];

    for i in 0..3 {
        if direction[i].abs() < 1e-8 {
            if origin[i] < aabb_min[i] || origin[i] > aabb_max[i] {
                return None;
            }
        } else {
            let inv_d = 1.0 / direction[i];
            let mut t1 = (aabb_min[i] - origin[i]) * inv_d;
            let mut t2 = (aabb_max[i] - origin[i]) * inv_d;

            let mut n = [0.0f32; 3];
            n[i] = -1.0;

            if t1 > t2 {
                std::mem::swap(&mut t1, &mut t2);
                n[i] = 1.0;
            }

            if t1 > t_min {
                t_min = t1;
                normal = n;
            }
            t_max = t_max.min(t2);

            if t_min > t_max {
                return None;
            }
        }
    }

    Some((t_min, normal))
}


============================================================
FILE: subvoxel\meshing\chunk_grid.rs
============================================================

// ============================================
// Chunk Grid - Единая сетка субвокселей чанка
// ============================================
//
// Вместо greedy meshing на уровне отдельных блоков,
// строим единую сетку для всего чанка и делаем greedy на ней.
// Это позволяет:
// 1. Culling граней между соседними блоками
// 2. Greedy meshing через границы блоков
// 3. Эффективность на больших полотнах

use crate::gpu::blocks::BlockType;
use crate::gpu::subvoxel::chunk::ChunkSubVoxelStorage;

/// Размер сетки чанка в субвокселях (16 блоков * 4 субвокселя = 64)
pub const CHUNK_GRID_SIZE: usize = 64;
/// Максимальная высота сетки (оптимизация - только занятый диапазон)
pub const MAX_GRID_HEIGHT: usize = 64;

/// Единая 3D сетка субвокселей для чанка
/// Хранит только занятый по Y диапазон для экономии памяти
pub struct ChunkGrid {
    /// Данные сетки [z][y_local][x] где y_local = y - min_y
    data: Vec<Option<BlockType>>,
    /// Минимальная Y координата
    pub min_y: i32,
    /// Максимальная Y координата
    pub max_y: i32,
    /// Высота сетки в субвокселях
    height: usize,
}

impl ChunkGrid {
    /// Создать сетку из хранилища чанка
    pub fn from_chunk_storage(storage: &ChunkSubVoxelStorage) -> Option<Self> {
        if storage.is_empty() {
            return None;
        }

        // Находим диапазон Y
        let mut min_block_y = i32::MAX;
        let mut max_block_y = i32::MIN;

        for (key, _) in storage.iter_blocks() {
            min_block_y = min_block_y.min(key.y as i32);
            max_block_y = max_block_y.max(key.y as i32);
        }

        if min_block_y > max_block_y {
            return None;
        }

        // Конвертируем в субвоксельные координаты (4 субвокселя на блок)
        let min_y = min_block_y * 4;
        let max_y = (max_block_y + 1) * 4 - 1;
        let height = ((max_y - min_y + 1) as usize).min(MAX_GRID_HEIGHT);

        // Аллоцируем сетку
        let total_size = CHUNK_GRID_SIZE * height * CHUNK_GRID_SIZE;
        let mut data = vec![None; total_size];

        // Заполняем сетку из октодеревьев
        for (key, octree) in storage.iter_blocks() {
            let block_base_x = (key.x as usize) * 4;
            let block_base_y = ((key.y as i32 - min_block_y) * 4) as usize;
            let block_base_z = (key.z as usize) * 4;

            // Итерируем по субвокселям в октодереве
            for (sx, sy, sz, size, block_type) in octree.iter_solid() {
                // Конвертируем нормализованные координаты [0,1) в индексы [0,4)
                let cells = (size * 4.0).round() as usize;
                let start_x = (sx * 4.0).floor() as usize;
                let start_y = (sy * 4.0).floor() as usize;
                let start_z = (sz * 4.0).floor() as usize;

                // Заполняем все ячейки субвокселя
                for dz in 0..cells {
                    for dy in 0..cells {
                        for dx in 0..cells {
                            let gx = block_base_x + start_x + dx;
                            let gy = block_base_y + start_y + dy;
                            let gz = block_base_z + start_z + dz;

                            if gx < CHUNK_GRID_SIZE && gy < height && gz < CHUNK_GRID_SIZE {
                                let idx = gz * height * CHUNK_GRID_SIZE + gy * CHUNK_GRID_SIZE + gx;
                                data[idx] = Some(block_type);
                            }
                        }
                    }
                }
            }
        }

        Some(Self {
            data,
            min_y,
            max_y,
            height,
        })
    }

    /// Получить блок по координатам сетки
    #[inline]
    pub fn get(&self, x: usize, y: usize, z: usize) -> Option<BlockType> {
        if x >= CHUNK_GRID_SIZE || y >= self.height || z >= CHUNK_GRID_SIZE {
            return None;
        }
        let idx = z * self.height * CHUNK_GRID_SIZE + y * CHUNK_GRID_SIZE + x;
        self.data[idx]
    }

    /// Проверить, есть ли блок (для culling)
    #[inline]
    pub fn is_solid(&self, x: i32, y: i32, z: i32) -> bool {
        if x < 0 || x >= CHUNK_GRID_SIZE as i32 || 
           y < 0 || y >= self.height as i32 || 
           z < 0 || z >= CHUNK_GRID_SIZE as i32 {
            return false;
        }
        self.get(x as usize, y as usize, z as usize).is_some()
    }

    /// Размеры сетки
    #[inline]
    pub fn width(&self) -> usize { CHUNK_GRID_SIZE }
    
    #[inline]
    pub fn height(&self) -> usize { self.height }
    
    #[inline]
    pub fn depth(&self) -> usize { CHUNK_GRID_SIZE }

    /// Размер одного субвокселя в мировых координатах
    #[inline]
    pub fn cell_size(&self) -> f32 { 0.25 } // 1/4 блока
}


============================================================
FILE: subvoxel\meshing\chunk_mesher.rs
============================================================

// ============================================
// Chunk Mesher - Greedy meshing на уровне чанка
// ============================================
//
// Ключевые оптимизации:
// 1. Единая сетка для всего чанка (не по блокам)
// 2. Culling граней между соседними субвокселями
// 3. Greedy meshing на полотнах 64x64 (эффективно!)
// 4. Нет промежуточных структур - работаем напрямую

use crate::gpu::blocks::get_face_colors;
use crate::gpu::subvoxel::chunk::{ChunkSubVoxelStorage, SubVoxelChunkKey};
use super::chunk_grid::{ChunkGrid, CHUNK_GRID_SIZE};
use super::greedy::{FaceInfo, GreedyQuad, greedy_mesh_layer_into};
use super::vertex::SubVoxelVertex;

/// Данные меша чанка
pub struct ChunkMeshData {
    pub vertices: Vec<SubVoxelVertex>,
    pub indices: Vec<u32>,
    pub chunk_key: SubVoxelChunkKey,
    pub version: u64,
}

/// Контекст для chunk meshing (переиспользуемые буферы)
pub struct ChunkMeshContext {
    /// Маска для greedy meshing (64x64 = 4096)
    mask: Vec<Option<FaceInfo>>,
    /// Visited флаги
    visited: Vec<bool>,
    /// Результаты greedy
    quads: Vec<GreedyQuad>,
    /// Выходные буферы
    vertices: Vec<SubVoxelVertex>,
    indices: Vec<u32>,
}

impl ChunkMeshContext {
    pub fn new() -> Self {
        let mask_size = CHUNK_GRID_SIZE * CHUNK_GRID_SIZE;
        Self {
            mask: vec![None; mask_size],
            visited: vec![false; mask_size],
            quads: Vec::with_capacity(256),
            vertices: Vec::with_capacity(4096),
            indices: Vec::with_capacity(8192),
        }
    }

    fn clear(&mut self) {
        self.vertices.clear();
        self.indices.clear();
    }

    fn clear_mask(&mut self) {
        for m in self.mask.iter_mut() {
            *m = None;
        }
    }
}

impl Default for ChunkMeshContext {
    fn default() -> Self {
        Self::new()
    }
}

/// Генерация меша для чанка с полным greedy meshing
pub fn mesh_chunk(
    storage: &ChunkSubVoxelStorage,
    chunk_key: SubVoxelChunkKey,
    ctx: &mut ChunkMeshContext,
) -> ChunkMeshData {
    ctx.clear();

    // Строим единую сетку чанка
    let Some(grid) = ChunkGrid::from_chunk_storage(storage) else {
        return ChunkMeshData {
            vertices: Vec::new(),
            indices: Vec::new(),
            chunk_key,
            version: storage.version(),
        };
    };

    let base_x = (chunk_key.x * 16) as f32;
    let base_z = (chunk_key.z * 16) as f32;
    let base_y = grid.min_y as f32 * 0.25; // Конвертируем субвоксельную Y в мировую
    let cell_size = grid.cell_size();

    // Greedy mesh для каждой оси
    mesh_y_faces(&grid, base_x, base_y, base_z, cell_size, ctx);
    mesh_x_faces(&grid, base_x, base_y, base_z, cell_size, ctx);
    mesh_z_faces(&grid, base_x, base_y, base_z, cell_size, ctx);

    ChunkMeshData {
        vertices: std::mem::take(&mut ctx.vertices),
        indices: std::mem::take(&mut ctx.indices),
        chunk_key,
        version: storage.version(),
    }
}

/// Генерация Y граней (+Y и -Y) с culling и greedy
fn mesh_y_faces(
    grid: &ChunkGrid,
    base_x: f32, base_y: f32, base_z: f32,
    cell_size: f32,
    ctx: &mut ChunkMeshContext,
) {
    let width = grid.width();
    let height = grid.height();
    let depth = grid.depth();

    // Проходим по каждому слою Y
    for y in 0..=height {
        ctx.clear_mask();

        // Заполняем маску для +Y граней
        for z in 0..depth {
            for x in 0..width {
                let idx = z * width + x;

                // +Y грань: блок снизу есть, сверху нет (или край)
                if y > 0 {
                    if let Some(block_type) = grid.get(x, y - 1, z) {
                        let above_empty = y >= height || grid.get(x, y, z).is_none();
                        if above_empty {
                            ctx.mask[idx] = Some(FaceInfo::new(block_type, true));
                        }
                    }
                }
            }
        }

        // Greedy mesh +Y
        greedy_mesh_layer_into(
            &ctx.mask[..width * depth],
            &mut ctx.visited[..width * depth],
            width, depth,
            &mut ctx.quads,
        );

        let world_y = base_y + y as f32 * cell_size;
        for quad in &ctx.quads {
            add_y_quad(
                &mut ctx.vertices, &mut ctx.indices,
                base_x + quad.u as f32 * cell_size,
                world_y,
                base_z + quad.v as f32 * cell_size,
                quad.width as f32 * cell_size,
                quad.height as f32 * cell_size,
                quad.face,
                true, // +Y
            );
        }

        // Заполняем маску для -Y граней
        ctx.clear_mask();
        for z in 0..depth {
            for x in 0..width {
                let idx = z * width + x;

                // -Y грань: блок есть, снизу нет (или край)
                if y < height {
                    if let Some(block_type) = grid.get(x, y, z) {
                        let below_empty = y == 0 || grid.get(x, y - 1, z).is_none();
                        if below_empty {
                            ctx.mask[idx] = Some(FaceInfo::new(block_type, false));
                        }
                    }
                }
            }
        }

        // Greedy mesh -Y
        greedy_mesh_layer_into(
            &ctx.mask[..width * depth],
            &mut ctx.visited[..width * depth],
            width, depth,
            &mut ctx.quads,
        );

        for quad in &ctx.quads {
            add_y_quad(
                &mut ctx.vertices, &mut ctx.indices,
                base_x + quad.u as f32 * cell_size,
                world_y,
                base_z + quad.v as f32 * cell_size,
                quad.width as f32 * cell_size,
                quad.height as f32 * cell_size,
                quad.face,
                false, // -Y
            );
        }
    }
}

/// Генерация X граней (+X и -X) с culling и greedy
fn mesh_x_faces(
    grid: &ChunkGrid,
    base_x: f32, base_y: f32, base_z: f32,
    cell_size: f32,
    ctx: &mut ChunkMeshContext,
) {
    let width = grid.width();
    let height = grid.height();
    let depth = grid.depth();

    for x in 0..=width {
        ctx.clear_mask();

        // +X грань: блок слева есть, справа нет
        for y in 0..height {
            for z in 0..depth {
                let idx = y * depth + z;

                if x > 0 {
                    if let Some(block_type) = grid.get(x - 1, y, z) {
                        let right_empty = x >= width || grid.get(x, y, z).is_none();
                        if right_empty {
                            ctx.mask[idx] = Some(FaceInfo::new(block_type, false));
                        }
                    }
                }
            }
        }

        greedy_mesh_layer_into(
            &ctx.mask[..height * depth],
            &mut ctx.visited[..height * depth],
            depth, height,
            &mut ctx.quads,
        );

        let world_x = base_x + x as f32 * cell_size;
        for quad in &ctx.quads {
            add_x_quad(
                &mut ctx.vertices, &mut ctx.indices,
                world_x,
                base_y + quad.v as f32 * cell_size,
                base_z + quad.u as f32 * cell_size,
                quad.width as f32 * cell_size,
                quad.height as f32 * cell_size,
                quad.face,
                true, // +X
            );
        }

        // -X грань
        ctx.clear_mask();
        for y in 0..height {
            for z in 0..depth {
                let idx = y * depth + z;

                if x < width {
                    if let Some(block_type) = grid.get(x, y, z) {
                        let left_empty = x == 0 || grid.get(x - 1, y, z).is_none();
                        if left_empty {
                            ctx.mask[idx] = Some(FaceInfo::new(block_type, false));
                        }
                    }
                }
            }
        }

        greedy_mesh_layer_into(
            &ctx.mask[..height * depth],
            &mut ctx.visited[..height * depth],
            depth, height,
            &mut ctx.quads,
        );

        for quad in &ctx.quads {
            add_x_quad(
                &mut ctx.vertices, &mut ctx.indices,
                world_x,
                base_y + quad.v as f32 * cell_size,
                base_z + quad.u as f32 * cell_size,
                quad.width as f32 * cell_size,
                quad.height as f32 * cell_size,
                quad.face,
                false, // -X
            );
        }
    }
}

/// Генерация Z граней (+Z и -Z) с culling и greedy
fn mesh_z_faces(
    grid: &ChunkGrid,
    base_x: f32, base_y: f32, base_z: f32,
    cell_size: f32,
    ctx: &mut ChunkMeshContext,
) {
    let width = grid.width();
    let height = grid.height();
    let depth = grid.depth();

    for z in 0..=depth {
        ctx.clear_mask();

        // +Z грань: блок сзади есть, спереди нет
        for y in 0..height {
            for x in 0..width {
                let idx = y * width + x;

                if z > 0 {
                    if let Some(block_type) = grid.get(x, y, z - 1) {
                        let front_empty = z >= depth || grid.get(x, y, z).is_none();
                        if front_empty {
                            ctx.mask[idx] = Some(FaceInfo::new(block_type, false));
                        }
                    }
                }
            }
        }

        greedy_mesh_layer_into(
            &ctx.mask[..height * width],
            &mut ctx.visited[..height * width],
            width, height,
            &mut ctx.quads,
        );

        let world_z = base_z + z as f32 * cell_size;
        for quad in &ctx.quads {
            add_z_quad(
                &mut ctx.vertices, &mut ctx.indices,
                base_x + quad.u as f32 * cell_size,
                base_y + quad.v as f32 * cell_size,
                world_z,
                quad.width as f32 * cell_size,
                quad.height as f32 * cell_size,
                quad.face,
                true, // +Z
            );
        }

        // -Z грань
        ctx.clear_mask();
        for y in 0..height {
            for x in 0..width {
                let idx = y * width + x;

                if z < depth {
                    if let Some(block_type) = grid.get(x, y, z) {
                        let back_empty = z == 0 || grid.get(x, y, z - 1).is_none();
                        if back_empty {
                            ctx.mask[idx] = Some(FaceInfo::new(block_type, false));
                        }
                    }
                }
            }
        }

        greedy_mesh_layer_into(
            &ctx.mask[..height * width],
            &mut ctx.visited[..height * width],
            width, height,
            &mut ctx.quads,
        );

        for quad in &ctx.quads {
            add_z_quad(
                &mut ctx.vertices, &mut ctx.indices,
                base_x + quad.u as f32 * cell_size,
                base_y + quad.v as f32 * cell_size,
                world_z,
                quad.width as f32 * cell_size,
                quad.height as f32 * cell_size,
                quad.face,
                false, // -Z
            );
        }
    }
}

// ============================================
// Функции добавления квадов
// ============================================

#[inline]
fn add_y_quad(
    vertices: &mut Vec<SubVoxelVertex>,
    indices: &mut Vec<u32>,
    x: f32, y: f32, z: f32,
    w: f32, h: f32,
    face: FaceInfo,
    positive: bool,
) {
    let base = vertices.len() as u32;
    let (top_color, side_color) = get_face_colors(face.block_type);
    let color = if face.is_top { top_color } else { 
        [side_color[0] * 0.5, side_color[1] * 0.5, side_color[2] * 0.5] 
    };

    if positive {
        let normal = [0.0, 1.0, 0.0];
        vertices.push(SubVoxelVertex::new([x, y, z], normal, top_color));
        vertices.push(SubVoxelVertex::new([x, y, z + h], normal, top_color));
        vertices.push(SubVoxelVertex::new([x + w, y, z + h], normal, top_color));
        vertices.push(SubVoxelVertex::new([x + w, y, z], normal, top_color));
    } else {
        let normal = [0.0, -1.0, 0.0];
        vertices.push(SubVoxelVertex::new([x, y, z], normal, color));
        vertices.push(SubVoxelVertex::new([x + w, y, z], normal, color));
        vertices.push(SubVoxelVertex::new([x + w, y, z + h], normal, color));
        vertices.push(SubVoxelVertex::new([x, y, z + h], normal, color));
    }

    indices.extend_from_slice(&[base, base + 1, base + 2, base, base + 2, base + 3]);
}

#[inline]
fn add_x_quad(
    vertices: &mut Vec<SubVoxelVertex>,
    indices: &mut Vec<u32>,
    x: f32, y: f32, z: f32,
    w: f32, h: f32,
    face: FaceInfo,
    positive: bool,
) {
    let base = vertices.len() as u32;
    let (_, side_color) = get_face_colors(face.block_type);

    if positive {
        let normal = [1.0, 0.0, 0.0];
        vertices.push(SubVoxelVertex::new([x, y, z], normal, side_color));
        vertices.push(SubVoxelVertex::new([x, y, z + w], normal, side_color));
        vertices.push(SubVoxelVertex::new([x, y + h, z + w], normal, side_color));
        vertices.push(SubVoxelVertex::new([x, y + h, z], normal, side_color));
    } else {
        let normal = [-1.0, 0.0, 0.0];
        vertices.push(SubVoxelVertex::new([x, y, z], normal, side_color));
        vertices.push(SubVoxelVertex::new([x, y + h, z], normal, side_color));
        vertices.push(SubVoxelVertex::new([x, y + h, z + w], normal, side_color));
        vertices.push(SubVoxelVertex::new([x, y, z + w], normal, side_color));
    }

    indices.extend_from_slice(&[base, base + 1, base + 2, base, base + 2, base + 3]);
}

#[inline]
fn add_z_quad(
    vertices: &mut Vec<SubVoxelVertex>,
    indices: &mut Vec<u32>,
    x: f32, y: f32, z: f32,
    w: f32, h: f32,
    face: FaceInfo,
    positive: bool,
) {
    let base = vertices.len() as u32;
    let (_, side_color) = get_face_colors(face.block_type);

    if positive {
        let normal = [0.0, 0.0, 1.0];
        vertices.push(SubVoxelVertex::new([x, y, z], normal, side_color));
        vertices.push(SubVoxelVertex::new([x + w, y, z], normal, side_color));
        vertices.push(SubVoxelVertex::new([x + w, y + h, z], normal, side_color));
        vertices.push(SubVoxelVertex::new([x, y + h, z], normal, side_color));
    } else {
        let normal = [0.0, 0.0, -1.0];
        vertices.push(SubVoxelVertex::new([x, y, z], normal, side_color));
        vertices.push(SubVoxelVertex::new([x, y + h, z], normal, side_color));
        vertices.push(SubVoxelVertex::new([x + w, y + h, z], normal, side_color));
        vertices.push(SubVoxelVertex::new([x + w, y, z], normal, side_color));
    }

    indices.extend_from_slice(&[base, base + 1, base + 2, base, base + 2, base + 3]);
}

/// Генерация меша (создает новый контекст)
pub fn mesh_chunk_new(
    storage: &ChunkSubVoxelStorage,
    chunk_key: SubVoxelChunkKey,
) -> ChunkMeshData {
    let mut ctx = ChunkMeshContext::new();
    mesh_chunk(storage, chunk_key, &mut ctx)
}


============================================================
FILE: subvoxel\meshing\greedy.rs
============================================================

// ============================================
// Greedy Meshing для субвокселей
// ============================================
//
// Объединяет соседние грани одного типа в большие прямоугольники.
// Значительно сокращает количество вершин и draw calls.

use crate::gpu::blocks::BlockType;

/// Направление грани
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum FaceDir {
    PosX, NegX,
    PosY, NegY,
    PosZ, NegZ,
}

impl FaceDir {
    #[inline]
    pub fn normal(&self) -> [f32; 3] {
        match self {
            FaceDir::PosX => [1.0, 0.0, 0.0],
            FaceDir::NegX => [-1.0, 0.0, 0.0],
            FaceDir::PosY => [0.0, 1.0, 0.0],
            FaceDir::NegY => [0.0, -1.0, 0.0],
            FaceDir::PosZ => [0.0, 0.0, 1.0],
            FaceDir::NegZ => [0.0, 0.0, -1.0],
        }
    }

    #[inline]
    pub fn axis(&self) -> usize {
        match self {
            FaceDir::PosX | FaceDir::NegX => 0,
            FaceDir::PosY | FaceDir::NegY => 1,
            FaceDir::PosZ | FaceDir::NegZ => 2,
        }
    }
}

/// Информация о грани для greedy meshing
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct FaceInfo {
    pub block_type: BlockType,
    pub is_top: bool, // Для выбора цвета (top vs side)
}

impl FaceInfo {
    #[inline]
    pub fn new(block_type: BlockType, is_top: bool) -> Self {
        Self { block_type, is_top }
    }
}

/// Результат greedy mesh - объединенный прямоугольник
#[derive(Clone, Copy, Debug)]
pub struct GreedyQuad {
    /// Начальные координаты в 2D слое (u, v)
    pub u: u8,
    pub v: u8,
    /// Размеры
    pub width: u8,
    pub height: u8,
    /// Информация о грани
    pub face: FaceInfo,
}

/// Greedy meshing для 2D слоя
/// mask: 2D массив Option<FaceInfo>, размер width x height
/// Возвращает список объединенных прямоугольников
pub fn greedy_mesh_layer(
    mask: &[Option<FaceInfo>],
    width: usize,
    height: usize,
) -> Vec<GreedyQuad> {
    let mut result = Vec::new();
    let mut visited = vec![false; width * height];

    for v in 0..height {
        for u in 0..width {
            let idx = v * width + u;

            if visited[idx] {
                continue;
            }

            let Some(face) = mask[idx] else {
                continue;
            };

            // Находим максимальную ширину
            let mut w = 1usize;
            while u + w < width {
                let next_idx = v * width + (u + w);
                if visited[next_idx] {
                    break;
                }
                match mask[next_idx] {
                    Some(f) if f == face => w += 1,
                    _ => break,
                }
            }

            // Находим максимальную высоту
            let mut h = 1usize;
            'height_loop: while v + h < height {
                for du in 0..w {
                    let check_idx = (v + h) * width + (u + du);
                    if visited[check_idx] {
                        break 'height_loop;
                    }
                    match mask[check_idx] {
                        Some(f) if f == face => {}
                        _ => break 'height_loop,
                    }
                }
                h += 1;
            }

            // Помечаем как посещенные
            for dv in 0..h {
                for du in 0..w {
                    visited[(v + dv) * width + (u + du)] = true;
                }
            }

            result.push(GreedyQuad {
                u: u as u8,
                v: v as u8,
                width: w as u8,
                height: h as u8,
                face,
            });
        }
    }

    result
}

/// Greedy meshing с переиспользованием буферов (zero-allocation в hot path)
pub fn greedy_mesh_layer_into(
    mask: &[Option<FaceInfo>],
    visited: &mut [bool],
    width: usize,
    height: usize,
    result: &mut Vec<GreedyQuad>,
) {
    result.clear();

    // Очищаем visited
    for v in visited.iter_mut().take(width * height) {
        *v = false;
    }

    for v in 0..height {
        for u in 0..width {
            let idx = v * width + u;

            if visited[idx] {
                continue;
            }

            let Some(face) = mask[idx] else {
                continue;
            };

            // Находим максимальную ширину
            let mut w = 1usize;
            while u + w < width {
                let next_idx = v * width + (u + w);
                if visited[next_idx] {
                    break;
                }
                match mask[next_idx] {
                    Some(f) if f == face => w += 1,
                    _ => break,
                }
            }

            // Находим максимальную высоту
            let mut h = 1usize;
            'height_loop: while v + h < height {
                for du in 0..w {
                    let check_idx = (v + h) * width + (u + du);
                    if visited[check_idx] {
                        break 'height_loop;
                    }
                    match mask[check_idx] {
                        Some(f) if f == face => {}
                        _ => break 'height_loop,
                    }
                }
                h += 1;
            }

            // Помечаем как посещенные
            for dv in 0..h {
                for du in 0..w {
                    visited[(v + dv) * width + (u + du)] = true;
                }
            }

            result.push(GreedyQuad {
                u: u as u8,
                v: v as u8,
                width: w as u8,
                height: h as u8,
                face,
            });
        }
    }
}


============================================================
FILE: subvoxel\meshing\mask_greedy.rs
============================================================

// ============================================
// Mask-Based Greedy Meshing - Без сортировки и аллокаций
// ============================================
//
// Классический алгоритм greedy meshing через битовые маски.
// Работает за один проход по каждому слою без промежуточных структур.
//
// Сложность: O(W*H*D) где W,H,D - размеры сетки
// Память: O(W*H) для маски одного слоя

use crate::gpu::blocks::{BlockType, get_face_colors, STONE};
use super::packed_vertex::{PackedVertex, NormalIndex, pack_color};

/// Размер маски (64x64 для субвокселей в чанке)
pub const MASK_SIZE: usize = 64;
pub const MASK_WORDS: usize = MASK_SIZE; // 64 бита = 1 u64 на строку

/// Контекст для mask-based greedy meshing
pub struct MaskGreedyContext {
    /// Битовая маска слоя [row] = u64 битов
    mask: [u64; MASK_SIZE],
    /// Типы блоков для маски
    types: [[u8; MASK_SIZE]; MASK_SIZE],
    /// Выходные буферы
    pub vertices: Vec<PackedVertex>,
    pub indices: Vec<u32>,
}

impl MaskGreedyContext {
    pub fn new() -> Self {
        Self {
            mask: [0; MASK_SIZE],
            types: [[0; MASK_SIZE]; MASK_SIZE],
            vertices: Vec::with_capacity(4096),
            indices: Vec::with_capacity(8192),
        }
    }

    pub fn clear(&mut self) {
        self.vertices.clear();
        self.indices.clear();
    }

    fn clear_mask(&mut self) {
        self.mask = [0; MASK_SIZE];
    }
}

impl Default for MaskGreedyContext {
    fn default() -> Self {
        Self::new()
    }
}

/// Интерфейс для доступа к данным вокселей
pub trait VoxelAccess {
    /// Получить тип блока в точке (None = воздух)
    fn get(&self, x: i32, y: i32, z: i32) -> Option<BlockType>;
    
    /// Границы данных
    fn bounds(&self) -> (i32, i32, i32, i32, i32, i32); // min_x, min_y, min_z, max_x, max_y, max_z
}

/// Greedy meshing через битовые маски
pub fn greedy_mesh_masked<V: VoxelAccess>(
    voxels: &V,
    ctx: &mut MaskGreedyContext,
    chunk_offset: [f32; 3],
) {
    ctx.clear();
    
    let (min_x, min_y, min_z, max_x, max_y, max_z) = voxels.bounds();
    
    // Проходим по каждой оси
    mesh_axis::<V>(voxels, ctx, chunk_offset, Axis::X, min_x, max_x, min_y, max_y, min_z, max_z);
    mesh_axis::<V>(voxels, ctx, chunk_offset, Axis::Y, min_y, max_y, min_x, max_x, min_z, max_z);
    mesh_axis::<V>(voxels, ctx, chunk_offset, Axis::Z, min_z, max_z, min_x, max_x, min_y, max_y);
}

#[derive(Clone, Copy)]
enum Axis { X, Y, Z }

fn mesh_axis<V: VoxelAccess>(
    voxels: &V,
    ctx: &mut MaskGreedyContext,
    chunk_offset: [f32; 3],
    axis: Axis,
    axis_min: i32, axis_max: i32,
    u_min: i32, u_max: i32,
    v_min: i32, v_max: i32,
) {
    let u_size = (u_max - u_min + 1) as usize;
    let v_size = (v_max - v_min + 1) as usize;
    
    if u_size > MASK_SIZE || v_size > MASK_SIZE {
        return; // Слишком большой слой
    }

    // Проходим по слоям вдоль оси
    for d in axis_min..=axis_max + 1 {
        ctx.clear_mask();
        
        // Заполняем маску для положительного направления
        for v in 0..v_size {
            for u in 0..u_size {
                let (x, y, z, nx, ny, nz) = match axis {
                    Axis::X => (d - 1, u_min + u as i32, v_min + v as i32, d, u_min + u as i32, v_min + v as i32),
                    Axis::Y => (u_min + u as i32, d - 1, v_min + v as i32, u_min + u as i32, d, v_min + v as i32),
                    Axis::Z => (u_min + u as i32, v_min + v as i32, d - 1, u_min + u as i32, v_min + v as i32, d),
                };
                
                let current = voxels.get(x, y, z);
                let neighbor = voxels.get(nx, ny, nz);
                
                // Грань видна если текущий solid и сосед пустой
                if let Some(bt) = current {
                    if neighbor.is_none() {
                        ctx.mask[v] |= 1u64 << u;
                        ctx.types[v][u] = bt as u8;
                    }
                }
            }
        }
        
        // Greedy merge для положительного направления
        let normal = match axis {
            Axis::X => NormalIndex::PosX,
            Axis::Y => NormalIndex::PosY,
            Axis::Z => NormalIndex::PosZ,
        };
        greedy_merge_layer(ctx, d as f32, axis, normal, chunk_offset, u_size, v_size, true);
        
        // Заполняем маску для отрицательного направления
        ctx.clear_mask();
        for v in 0..v_size {
            for u in 0..u_size {
                let (x, y, z, nx, ny, nz) = match axis {
                    Axis::X => (d, u_min + u as i32, v_min + v as i32, d - 1, u_min + u as i32, v_min + v as i32),
                    Axis::Y => (u_min + u as i32, d, v_min + v as i32, u_min + u as i32, d - 1, v_min + v as i32),
                    Axis::Z => (u_min + u as i32, v_min + v as i32, d, u_min + u as i32, v_min + v as i32, d - 1),
                };
                
                let current = voxels.get(x, y, z);
                let neighbor = voxels.get(nx, ny, nz);
                
                if let Some(bt) = current {
                    if neighbor.is_none() {
                        ctx.mask[v] |= 1u64 << u;
                        ctx.types[v][u] = bt as u8;
                    }
                }
            }
        }
        
        let normal = match axis {
            Axis::X => NormalIndex::NegX,
            Axis::Y => NormalIndex::NegY,
            Axis::Z => NormalIndex::NegZ,
        };
        greedy_merge_layer(ctx, d as f32, axis, normal, chunk_offset, u_size, v_size, false);
    }
}

/// Greedy merge одного слоя через битовые операции
fn greedy_merge_layer(
    ctx: &mut MaskGreedyContext,
    d: f32,
    axis: Axis,
    normal: NormalIndex,
    chunk_offset: [f32; 3],
    u_size: usize,
    v_size: usize,
    positive: bool,
) {
    for v in 0..v_size {
        let mut u = 0;
        while u < u_size {
            // Пропускаем пустые биты
            if (ctx.mask[v] & (1u64 << u)) == 0 {
                u += 1;
                continue;
            }
            
            let block_type = ctx.types[v][u];
            
            // Находим ширину (расширяем по U)
            let mut width = 1;
            while u + width < u_size {
                let bit = 1u64 << (u + width);
                if (ctx.mask[v] & bit) == 0 || ctx.types[v][u + width] != block_type {
                    break;
                }
                width += 1;
            }
            
            // Находим высоту (расширяем по V)
            let mut height = 1;
            'height: while v + height < v_size {
                for du in 0..width {
                    let bit = 1u64 << (u + du);
                    if (ctx.mask[v + height] & bit) == 0 || ctx.types[v + height][u + du] != block_type {
                        break 'height;
                    }
                }
                height += 1;
            }
            
            // Очищаем использованные биты
            for dv in 0..height {
                for du in 0..width {
                    ctx.mask[v + dv] &= !(1u64 << (u + du));
                }
            }
            
            // Генерируем квад
            emit_quad_packed(
                ctx,
                d, u as f32, v as f32,
                width as f32, height as f32,
                axis, normal, chunk_offset,
                block_type, positive,
            );
            
            u += width;
        }
    }
}

/// Генерация квада с упакованными вершинами
fn emit_quad_packed(
    ctx: &mut MaskGreedyContext,
    d: f32, u: f32, v: f32,
    w: f32, h: f32,
    axis: Axis,
    normal: NormalIndex,
    offset: [f32; 3],
    block_type: u8,
    positive: bool,
) {
    let base = ctx.vertices.len() as u32;
    
    // Получаем цвет из типа блока
    let bt: BlockType = block_type;
    let (top_color, side_color) = get_face_colors(bt);
    
    let color = match normal {
        NormalIndex::PosY => pack_color(top_color[0], top_color[1], top_color[2], 1.0),
        NormalIndex::NegY => pack_color(side_color[0] * 0.5, side_color[1] * 0.5, side_color[2] * 0.5, 1.0),
        _ => pack_color(side_color[0], side_color[1], side_color[2], 1.0),
    };
    
    // Конвертируем координаты в позиции вершин
    let (p0, p1, p2, p3) = match axis {
        Axis::X => {
            let x = (d + offset[0]) * 4.0;
            let y0 = (u + offset[1]) * 4.0;
            let y1 = (u + w + offset[1]) * 4.0;
            let z0 = (v + offset[2]) * 4.0;
            let z1 = (v + h + offset[2]) * 4.0;
            if positive {
                ([x, y0, z0], [x, y0, z1], [x, y1, z1], [x, y1, z0])
            } else {
                ([x, y0, z0], [x, y1, z0], [x, y1, z1], [x, y0, z1])
            }
        }
        Axis::Y => {
            let y = (d + offset[1]) * 4.0;
            let x0 = (u + offset[0]) * 4.0;
            let x1 = (u + w + offset[0]) * 4.0;
            let z0 = (v + offset[2]) * 4.0;
            let z1 = (v + h + offset[2]) * 4.0;
            if positive {
                ([x0, y, z0], [x0, y, z1], [x1, y, z1], [x1, y, z0])
            } else {
                ([x0, y, z0], [x1, y, z0], [x1, y, z1], [x0, y, z1])
            }
        }
        Axis::Z => {
            let z = (d + offset[2]) * 4.0;
            let x0 = (u + offset[0]) * 4.0;
            let x1 = (u + w + offset[0]) * 4.0;
            let y0 = (v + offset[1]) * 4.0;
            let y1 = (v + h + offset[1]) * 4.0;
            if positive {
                ([x0, y0, z], [x1, y0, z], [x1, y1, z], [x0, y1, z])
            } else {
                ([x0, y0, z], [x0, y1, z], [x1, y1, z], [x1, y0, z])
            }
        }
    };
    
    // Добавляем вершины
    let to_u8 = |v: f32| v.clamp(0.0, 255.0) as u8;
    
    ctx.vertices.push(PackedVertex {
        pos_x: to_u8(p0[0]), pos_y: to_u8(p0[1]), pos_z: to_u8(p0[2]),
        normal_flags: normal as u8,
        color,
    });
    ctx.vertices.push(PackedVertex {
        pos_x: to_u8(p1[0]), pos_y: to_u8(p1[1]), pos_z: to_u8(p1[2]),
        normal_flags: normal as u8,
        color,
    });
    ctx.vertices.push(PackedVertex {
        pos_x: to_u8(p2[0]), pos_y: to_u8(p2[1]), pos_z: to_u8(p2[2]),
        normal_flags: normal as u8,
        color,
    });
    ctx.vertices.push(PackedVertex {
        pos_x: to_u8(p3[0]), pos_y: to_u8(p3[1]), pos_z: to_u8(p3[2]),
        normal_flags: normal as u8,
        color,
    });
    
    // Индексы
    ctx.indices.extend_from_slice(&[base, base + 1, base + 2, base, base + 2, base + 3]);
}


============================================================
FILE: subvoxel\meshing\mod.rs
============================================================

// ============================================
// Meshing Module - Greedy Meshing для субвокселей
// ============================================
//
// Три реализации:
// - chunk_mesher: Оригинальная с ChunkGrid (legacy)
// - octree_mesher: Прямой обход октодерева
// - mask_greedy: Битовые маски без сортировки (рекомендуется)
//
// Два формата вершин:
// - SubVoxelVertex: 36 байт (legacy)
// - PackedVertex: 8 байт (рекомендуется)

mod greedy;
mod chunk_grid;
mod chunk_mesher;
mod octree_mesher;
mod mask_greedy;
mod vertex;
mod packed_vertex;

// Legacy
pub use greedy::{FaceDir, FaceInfo, GreedyQuad, greedy_mesh_layer, greedy_mesh_layer_into};
pub use chunk_grid::{ChunkGrid, CHUNK_GRID_SIZE};
pub use chunk_mesher::{ChunkMeshData, ChunkMeshContext, mesh_chunk, mesh_chunk_new};
pub use vertex::SubVoxelVertex;

// Octree mesher
pub use octree_mesher::{OctreeMeshData, OctreeMeshContext, mesh_chunk_octree, mesh_chunk_octree_new};

// Optimized (рекомендуется)
pub use packed_vertex::{PackedVertex, NormalIndex, MicroVertex, ColorPalette, pack_color, unpack_color};
pub use mask_greedy::{MaskGreedyContext, VoxelAccess, greedy_mesh_masked, MASK_SIZE};


============================================================
FILE: subvoxel\meshing\octree_mesher.rs
============================================================

// ============================================
// Octree Mesher - Greedy Meshing напрямую по октодереву
// ============================================
//
// Без промежуточной декомпрессии в ChunkGrid.
// Работает напрямую с иерархией октодерева.
//
// Ключевые оптимизации:
// 1. Пропуск пустых поддеревьев (O(log N) вместо O(N))
// 2. Нет memory traffic от декомпрессии
// 3. Greedy на уровне листьев октодерева
// 4. Culling через соседние узлы

use crate::gpu::blocks::{BlockType, get_face_colors};
use crate::gpu::subvoxel::chunk::{ChunkSubVoxelStorage, SubVoxelChunkKey};
use crate::gpu::subvoxel::octree::{LinearOctree, NodeData};
use super::vertex::SubVoxelVertex;

/// Данные меша чанка (без декомпрессии)
#[derive(Default)]
pub struct OctreeMeshData {
    pub vertices: Vec<SubVoxelVertex>,
    pub indices: Vec<u32>,
    pub chunk_key: SubVoxelChunkKey,
    pub version: u64,
}

/// Контекст для octree meshing (переиспользуемые буферы)
pub struct OctreeMeshContext {
    /// Собранные грани для greedy
    faces: Vec<OctreeFace>,
    /// Выходные буферы
    vertices: Vec<SubVoxelVertex>,
    indices: Vec<u32>,
    /// Visited для greedy
    visited: Vec<bool>,
}

/// Грань субвокселя для greedy meshing
#[derive(Clone, Copy, Debug)]
struct OctreeFace {
    /// Мировые координаты грани
    x: f32,
    y: f32,
    z: f32,
    /// Размер грани
    size: f32,
    /// Тип блока
    block_type: BlockType,
    /// Направление грани
    dir: FaceDir,
    /// Координата по оси грани (для сортировки)
    axis_coord: f32,
}

/// Направление грани
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum FaceDir {
    PosX, NegX,
    PosY, NegY,
    PosZ, NegZ,
}

impl FaceDir {
    #[inline]
    pub fn normal(&self) -> [f32; 3] {
        match self {
            FaceDir::PosX => [1.0, 0.0, 0.0],
            FaceDir::NegX => [-1.0, 0.0, 0.0],
            FaceDir::PosY => [0.0, 1.0, 0.0],
            FaceDir::NegY => [0.0, -1.0, 0.0],
            FaceDir::PosZ => [0.0, 0.0, 1.0],
            FaceDir::NegZ => [0.0, 0.0, -1.0],
        }
    }

    #[inline]
    pub fn axis(&self) -> usize {
        match self {
            FaceDir::PosX | FaceDir::NegX => 0,
            FaceDir::PosY | FaceDir::NegY => 1,
            FaceDir::PosZ | FaceDir::NegZ => 2,
        }
    }

    #[inline]
    pub fn is_positive(&self) -> bool {
        matches!(self, FaceDir::PosX | FaceDir::PosY | FaceDir::PosZ)
    }
}

impl OctreeMeshContext {
    pub fn new() -> Self {
        Self {
            faces: Vec::with_capacity(4096),
            vertices: Vec::with_capacity(8192),
            indices: Vec::with_capacity(16384),
            visited: Vec::with_capacity(4096),
        }
    }

    fn clear(&mut self) {
        self.faces.clear();
        self.vertices.clear();
        self.indices.clear();
    }
}

impl Default for OctreeMeshContext {
    fn default() -> Self {
        Self::new()
    }
}

// ============================================
// Главная функция мешинга
// ============================================

/// Генерация меша напрямую из октодеревьев (без ChunkGrid)
pub fn mesh_chunk_octree(
    storage: &ChunkSubVoxelStorage,
    chunk_key: SubVoxelChunkKey,
    ctx: &mut OctreeMeshContext,
) -> OctreeMeshData {
    ctx.clear();

    if storage.is_empty() {
        return OctreeMeshData {
            vertices: Vec::new(),
            indices: Vec::new(),
            chunk_key,
            version: storage.version(),
        };
    }

    let base_x = (chunk_key.x * 16) as f32;
    let base_z = (chunk_key.z * 16) as f32;

    // Собираем все видимые грани из октодеревьев
    collect_visible_faces(storage, base_x, base_z, &mut ctx.faces);

    // Greedy meshing по собранным граням
    greedy_mesh_faces(&mut ctx.faces, &mut ctx.visited, &mut ctx.vertices, &mut ctx.indices);

    OctreeMeshData {
        vertices: std::mem::take(&mut ctx.vertices),
        indices: std::mem::take(&mut ctx.indices),
        chunk_key,
        version: storage.version(),
    }
}

// ============================================
// Сбор видимых граней из октодеревьев
// ============================================

/// Собирает видимые грани из всех октодеревьев чанка
fn collect_visible_faces(
    storage: &ChunkSubVoxelStorage,
    base_x: f32,
    base_z: f32,
    faces: &mut Vec<OctreeFace>,
) {
    for (key, octree) in storage.iter_blocks() {
        let block_x = base_x + key.x as f32;
        let block_y = key.y as f32;
        let block_z = base_z + key.z as f32;

        // Получаем соседние октодеревья для culling
        let neighbors = BlockNeighbors {
            pos_x: storage.get_block_octree(key.x.wrapping_add(1), key.y, key.z),
            neg_x: if key.x > 0 { storage.get_block_octree(key.x - 1, key.y, key.z) } else { None },
            pos_y: storage.get_block_octree(key.x, key.y.wrapping_add(1), key.z),
            neg_y: if key.y > 0 { storage.get_block_octree(key.x, key.y - 1, key.z) } else { None },
            pos_z: storage.get_block_octree(key.x, key.y, key.z.wrapping_add(1)),
            neg_z: if key.z > 0 { storage.get_block_octree(key.x, key.y, key.z - 1) } else { None },
        };

        // Рекурсивно обходим октодерево
        collect_faces_recursive(
            octree,
            0, // root node
            block_x, block_y, block_z,
            1.0, // size = 1 block
            &neighbors,
            faces,
        );
    }
}

/// Соседние октодеревья для culling
struct BlockNeighbors<'a> {
    pos_x: Option<&'a LinearOctree>,
    neg_x: Option<&'a LinearOctree>,
    pos_y: Option<&'a LinearOctree>,
    neg_y: Option<&'a LinearOctree>,
    pos_z: Option<&'a LinearOctree>,
    neg_z: Option<&'a LinearOctree>,
}

/// Рекурсивный обход октодерева для сбора граней
fn collect_faces_recursive(
    octree: &LinearOctree,
    node_idx: u32,
    x: f32, y: f32, z: f32,
    size: f32,
    neighbors: &BlockNeighbors,
    faces: &mut Vec<OctreeFace>,
) {
    let node = octree.get_node(node_idx);

    match node.data {
        NodeData::Empty => {
            // Пустой узел - пропускаем всё поддерево
            return;
        }
        NodeData::Solid(block_type) => {
            // Листовой узел - генерируем грани с culling
            generate_leaf_faces(x, y, z, size, block_type, neighbors, octree, faces);
        }
        NodeData::Branch => {
            if !node.has_children() {
                return;
            }

            let half = size * 0.5;
            let first_child = node.first_child;

            // Рекурсивно обходим детей
            for i in 0..8u32 {
                let (lx, ly, lz) = child_offset_to_local(i);
                let child_x = x + lx as f32 * half;
                let child_y = y + ly as f32 * half;
                let child_z = z + lz as f32 * half;

                collect_faces_recursive(
                    octree,
                    first_child + i,
                    child_x, child_y, child_z,
                    half,
                    neighbors,
                    faces,
                );
            }
        }
    }
}

/// Генерация граней для листового узла с culling
fn generate_leaf_faces(
    x: f32, y: f32, z: f32,
    size: f32,
    block_type: BlockType,
    neighbors: &BlockNeighbors,
    octree: &LinearOctree,
    faces: &mut Vec<OctreeFace>,
) {
    // +X грань
    if !is_occluded_positive_x(x, y, z, size, octree, neighbors.pos_x) {
        faces.push(OctreeFace {
            x: x + size, y, z,
            size,
            block_type,
            dir: FaceDir::PosX,
            axis_coord: x + size,
        });
    }

    // -X грань
    if !is_occluded_negative_x(x, y, z, size, octree, neighbors.neg_x) {
        faces.push(OctreeFace {
            x, y, z,
            size,
            block_type,
            dir: FaceDir::NegX,
            axis_coord: x,
        });
    }

    // +Y грань
    if !is_occluded_positive_y(x, y, z, size, octree, neighbors.pos_y) {
        faces.push(OctreeFace {
            x, y: y + size, z,
            size,
            block_type,
            dir: FaceDir::PosY,
            axis_coord: y + size,
        });
    }

    // -Y грань
    if !is_occluded_negative_y(x, y, z, size, octree, neighbors.neg_y) {
        faces.push(OctreeFace {
            x, y, z,
            size,
            block_type,
            dir: FaceDir::NegY,
            axis_coord: y,
        });
    }

    // +Z грань
    if !is_occluded_positive_z(x, y, z, size, octree, neighbors.pos_z) {
        faces.push(OctreeFace {
            x, y, z: z + size,
            size,
            block_type,
            dir: FaceDir::PosZ,
            axis_coord: z + size,
        });
    }

    // -Z грань
    if !is_occluded_negative_z(x, y, z, size, octree, neighbors.neg_z) {
        faces.push(OctreeFace {
            x, y, z,
            size,
            block_type,
            dir: FaceDir::NegZ,
            axis_coord: z,
        });
    }
}

// ============================================
// Функции проверки окклюзии (culling)
// ============================================

/// Проверка окклюзии +X грани
#[inline]
fn is_occluded_positive_x(
    x: f32, y: f32, z: f32,
    size: f32,
    octree: &LinearOctree,
    neighbor: Option<&LinearOctree>,
) -> bool {
    let check_x = x + size;
    
    // Внутри блока
    if check_x < 1.0 {
        return octree.is_solid_at(check_x, y, z, size);
    }
    
    // В соседнем блоке
    if let Some(neighbor_octree) = neighbor {
        return neighbor_octree.is_solid_at(0.0, y, z, size);
    }
    
    false
}

/// Проверка окклюзии -X грани
#[inline]
fn is_occluded_negative_x(
    x: f32, y: f32, z: f32,
    size: f32,
    octree: &LinearOctree,
    neighbor: Option<&LinearOctree>,
) -> bool {
    // Внутри блока
    if x > 0.0 {
        return octree.is_solid_at(x - size, y, z, size);
    }
    
    // В соседнем блоке
    if let Some(neighbor_octree) = neighbor {
        return neighbor_octree.is_solid_at(1.0 - size, y, z, size);
    }
    
    false
}

/// Проверка окклюзии +Y грани
#[inline]
fn is_occluded_positive_y(
    x: f32, y: f32, z: f32,
    size: f32,
    octree: &LinearOctree,
    neighbor: Option<&LinearOctree>,
) -> bool {
    let check_y = y + size;
    
    if check_y < 1.0 {
        return octree.is_solid_at(x, check_y, z, size);
    }
    
    if let Some(neighbor_octree) = neighbor {
        return neighbor_octree.is_solid_at(x, 0.0, z, size);
    }
    
    false
}

/// Проверка окклюзии -Y грани
#[inline]
fn is_occluded_negative_y(
    x: f32, y: f32, z: f32,
    size: f32,
    octree: &LinearOctree,
    neighbor: Option<&LinearOctree>,
) -> bool {
    if y > 0.0 {
        return octree.is_solid_at(x, y - size, z, size);
    }
    
    if let Some(neighbor_octree) = neighbor {
        return neighbor_octree.is_solid_at(x, 1.0 - size, z, size);
    }
    
    false
}

/// Проверка окклюзии +Z грани
#[inline]
fn is_occluded_positive_z(
    x: f32, y: f32, z: f32,
    size: f32,
    octree: &LinearOctree,
    neighbor: Option<&LinearOctree>,
) -> bool {
    let check_z = z + size;
    
    if check_z < 1.0 {
        return octree.is_solid_at(x, y, check_z, size);
    }
    
    if let Some(neighbor_octree) = neighbor {
        return neighbor_octree.is_solid_at(x, y, 0.0, size);
    }
    
    false
}

/// Проверка окклюзии -Z грани
#[inline]
fn is_occluded_negative_z(
    x: f32, y: f32, z: f32,
    size: f32,
    octree: &LinearOctree,
    neighbor: Option<&LinearOctree>,
) -> bool {
    if z > 0.0 {
        return octree.is_solid_at(x, y, z - size, size);
    }
    
    if let Some(neighbor_octree) = neighbor {
        return neighbor_octree.is_solid_at(x, y, 1.0 - size, size);
    }
    
    false
}

// ============================================
// Greedy Meshing по собранным граням
// ============================================

/// Greedy meshing по собранным граням
fn greedy_mesh_faces(
    faces: &mut Vec<OctreeFace>,
    visited: &mut Vec<bool>,
    vertices: &mut Vec<SubVoxelVertex>,
    indices: &mut Vec<u32>,
) {
    if faces.is_empty() {
        return;
    }

    // Сортируем грани по направлению и координате оси
    faces.sort_by(|a, b| {
        match (a.dir as u8).cmp(&(b.dir as u8)) {
            std::cmp::Ordering::Equal => {
                a.axis_coord.partial_cmp(&b.axis_coord).unwrap_or(std::cmp::Ordering::Equal)
            }
            other => other,
        }
    });

    // Greedy для каждого направления отдельно
    let mut start = 0;
    while start < faces.len() {
        let dir = faces[start].dir;
        let mut end = start + 1;
        
        // Находим конец группы с одинаковым направлением
        while end < faces.len() && faces[end].dir == dir {
            end += 1;
        }

        // Greedy mesh для этой группы
        greedy_mesh_face_group(&faces[start..end], visited, vertices, indices, dir);
        
        start = end;
    }
}

/// Greedy meshing для группы граней одного направления
fn greedy_mesh_face_group(
    faces: &[OctreeFace],
    visited: &mut Vec<bool>,
    vertices: &mut Vec<SubVoxelVertex>,
    indices: &mut Vec<u32>,
    dir: FaceDir,
) {
    if faces.is_empty() {
        return;
    }

    // Подготавливаем visited
    visited.clear();
    visited.resize(faces.len(), false);

    // Группируем по axis_coord (слои)
    let mut layer_start = 0;
    while layer_start < faces.len() {
        let axis_coord = faces[layer_start].axis_coord;
        let mut layer_end = layer_start + 1;
        
        while layer_end < faces.len() && 
              (faces[layer_end].axis_coord - axis_coord).abs() < 0.001 {
            layer_end += 1;
        }

        // Greedy для этого слоя
        greedy_mesh_layer_direct(
            &faces[layer_start..layer_end],
            &mut visited[layer_start..layer_end],
            vertices,
            indices,
            dir,
        );

        layer_start = layer_end;
    }
}

/// Greedy meshing для одного слоя граней
fn greedy_mesh_layer_direct(
    faces: &[OctreeFace],
    visited: &mut [bool],
    vertices: &mut Vec<SubVoxelVertex>,
    indices: &mut Vec<u32>,
    dir: FaceDir,
) {
    for i in 0..faces.len() {
        if visited[i] {
            continue;
        }

        let face = &faces[i];
        visited[i] = true;

        // Пытаемся расширить грань
        let (merged_width, merged_height) = try_merge_faces(
            faces, visited, i, face, dir
        );

        // Генерируем квад
        emit_quad(vertices, indices, face, merged_width, merged_height, dir);
    }
}

/// Попытка объединить соседние грани
fn try_merge_faces(
    faces: &[OctreeFace],
    visited: &mut [bool],
    start_idx: usize,
    start_face: &OctreeFace,
    dir: FaceDir,
) -> (f32, f32) {
    let mut width = start_face.size;
    let mut height = start_face.size;

    // Определяем оси для расширения в зависимости от направления грани
    let (u_axis, v_axis) = match dir {
        FaceDir::PosX | FaceDir::NegX => (2, 1), // Z, Y
        FaceDir::PosY | FaceDir::NegY => (0, 2), // X, Z
        FaceDir::PosZ | FaceDir::NegZ => (0, 1), // X, Y
    };

    let start_pos = [start_face.x, start_face.y, start_face.z];

    // Расширяем по U
    'expand_u: loop {
        let next_u = start_pos[u_axis] + width;
        
        for j in (start_idx + 1)..faces.len() {
            if visited[j] {
                continue;
            }
            
            let other = &faces[j];
            if other.block_type != start_face.block_type || other.size != start_face.size {
                continue;
            }

            let other_pos = [other.x, other.y, other.z];
            
            // Проверяем что грань примыкает по U
            if (other_pos[u_axis] - next_u).abs() < 0.001 &&
               (other_pos[v_axis] - start_pos[v_axis]).abs() < 0.001 {
                visited[j] = true;
                width += other.size;
                continue 'expand_u;
            }
        }
        break;
    }

    // Расширяем по V
    'expand_v: loop {
        let next_v = start_pos[v_axis] + height;
        let mut row_complete = true;
        let mut row_faces = Vec::new();

        // Проверяем всю строку
        let mut check_u = start_pos[u_axis];
        while check_u < start_pos[u_axis] + width {
            let mut found = false;
            
            for j in (start_idx + 1)..faces.len() {
                if visited[j] {
                    continue;
                }
                
                let other = &faces[j];
                if other.block_type != start_face.block_type || other.size != start_face.size {
                    continue;
                }

                let other_pos = [other.x, other.y, other.z];
                
                if (other_pos[u_axis] - check_u).abs() < 0.001 &&
                   (other_pos[v_axis] - next_v).abs() < 0.001 {
                    row_faces.push(j);
                    found = true;
                    check_u += other.size;
                    break;
                }
            }
            
            if !found {
                row_complete = false;
                break;
            }
        }

        if row_complete && !row_faces.is_empty() {
            for j in row_faces {
                visited[j] = true;
            }
            height += start_face.size;
        } else {
            break 'expand_v;
        }
    }

    (width, height)
}

/// Генерация квада
fn emit_quad(
    vertices: &mut Vec<SubVoxelVertex>,
    indices: &mut Vec<u32>,
    face: &OctreeFace,
    width: f32,
    height: f32,
    dir: FaceDir,
) {
    let base = vertices.len() as u32;
    let normal = dir.normal();
    let (top_color, side_color) = get_face_colors(face.block_type);
    
    let color = if matches!(dir, FaceDir::PosY) {
        top_color
    } else if matches!(dir, FaceDir::NegY) {
        [side_color[0] * 0.5, side_color[1] * 0.5, side_color[2] * 0.5]
    } else {
        side_color
    };

    let (x, y, z) = (face.x, face.y, face.z);

    match dir {
        FaceDir::PosX => {
            vertices.push(SubVoxelVertex::new([x, y, z], normal, color));
            vertices.push(SubVoxelVertex::new([x, y, z + width], normal, color));
            vertices.push(SubVoxelVertex::new([x, y + height, z + width], normal, color));
            vertices.push(SubVoxelVertex::new([x, y + height, z], normal, color));
        }
        FaceDir::NegX => {
            vertices.push(SubVoxelVertex::new([x, y, z], normal, color));
            vertices.push(SubVoxelVertex::new([x, y + height, z], normal, color));
            vertices.push(SubVoxelVertex::new([x, y + height, z + width], normal, color));
            vertices.push(SubVoxelVertex::new([x, y, z + width], normal, color));
        }
        FaceDir::PosY => {
            vertices.push(SubVoxelVertex::new([x, y, z], normal, color));
            vertices.push(SubVoxelVertex::new([x, y, z + height], normal, color));
            vertices.push(SubVoxelVertex::new([x + width, y, z + height], normal, color));
            vertices.push(SubVoxelVertex::new([x + width, y, z], normal, color));
        }
        FaceDir::NegY => {
            vertices.push(SubVoxelVertex::new([x, y, z], normal, color));
            vertices.push(SubVoxelVertex::new([x + width, y, z], normal, color));
            vertices.push(SubVoxelVertex::new([x + width, y, z + height], normal, color));
            vertices.push(SubVoxelVertex::new([x, y, z + height], normal, color));
        }
        FaceDir::PosZ => {
            vertices.push(SubVoxelVertex::new([x, y, z], normal, color));
            vertices.push(SubVoxelVertex::new([x + width, y, z], normal, color));
            vertices.push(SubVoxelVertex::new([x + width, y + height, z], normal, color));
            vertices.push(SubVoxelVertex::new([x, y + height, z], normal, color));
        }
        FaceDir::NegZ => {
            vertices.push(SubVoxelVertex::new([x, y, z], normal, color));
            vertices.push(SubVoxelVertex::new([x, y + height, z], normal, color));
            vertices.push(SubVoxelVertex::new([x + width, y + height, z], normal, color));
            vertices.push(SubVoxelVertex::new([x + width, y, z], normal, color));
        }
    }

    indices.extend_from_slice(&[base, base + 1, base + 2, base, base + 2, base + 3]);
}

// ============================================
// Вспомогательные функции
// ============================================

/// Конвертация offset ребёнка в локальные координаты
#[inline]
fn child_offset_to_local(offset: u32) -> (u8, u8, u8) {
    let lx = (offset & 1) as u8;
    let ly = ((offset >> 1) & 1) as u8;
    let lz = ((offset >> 2) & 1) as u8;
    (lx, ly, lz)
}

/// Создание меша (создает новый контекст)
pub fn mesh_chunk_octree_new(
    storage: &ChunkSubVoxelStorage,
    chunk_key: SubVoxelChunkKey,
) -> OctreeMeshData {
    let mut ctx = OctreeMeshContext::new();
    mesh_chunk_octree(storage, chunk_key, &mut ctx)
}


============================================================
FILE: subvoxel\meshing\packed_vertex.rs
============================================================

// ============================================
// Packed Vertex - Компактный формат вершины
// ============================================
//
// Вместо 36 байт (3x f32 position + 3x f32 normal + 3x f32 color)
// используем 8 байт:
// - Position: 3x u8 (относительно чанка, 0-255)
// - Normal: 1 байт (индекс 0-5, куб имеет 6 нормалей)
// - Color: u32 RGBA8
//
// Экономия: 4.5x меньше bandwidth GPU

use bytemuck::{Pod, Zeroable};

/// Упакованная вершина субвокселя (8 байт)
#[repr(C)]
#[derive(Clone, Copy, Debug, Pod, Zeroable)]
pub struct PackedVertex {
    /// Позиция относительно чанка (x, y, z в субвоксельных единицах 0-255)
    pub pos_x: u8,
    pub pos_y: u8,
    pub pos_z: u8,
    /// Индекс нормали (0-5) + флаги
    pub normal_flags: u8,
    /// Цвет RGBA8
    pub color: u32,
}

/// Индексы нормалей
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum NormalIndex {
    PosX = 0,
    NegX = 1,
    PosY = 2,
    NegY = 3,
    PosZ = 4,
    NegZ = 5,
}

impl NormalIndex {
    #[inline]
    pub fn to_vec3(&self) -> [f32; 3] {
        match self {
            NormalIndex::PosX => [1.0, 0.0, 0.0],
            NormalIndex::NegX => [-1.0, 0.0, 0.0],
            NormalIndex::PosY => [0.0, 1.0, 0.0],
            NormalIndex::NegY => [0.0, -1.0, 0.0],
            NormalIndex::PosZ => [0.0, 0.0, 1.0],
            NormalIndex::NegZ => [0.0, 0.0, -1.0],
        }
    }
}

impl PackedVertex {
    pub const ATTRIBS: [wgpu::VertexAttribute; 3] = wgpu::vertex_attr_array![
        0 => Uint8x4,  // pos_x, pos_y, pos_z, normal_flags
        1 => Uint32,   // color
        2 => Uint32,   // padding/reserved (для выравнивания)
    ];

    pub fn desc() -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<Self>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &Self::ATTRIBS,
        }
    }

    #[inline]
    pub fn new(pos: [u8; 3], normal: NormalIndex, color: [u8; 4]) -> Self {
        Self {
            pos_x: pos[0],
            pos_y: pos[1],
            pos_z: pos[2],
            normal_flags: normal as u8,
            color: u32::from_le_bytes(color),
        }
    }

    /// Создать из float координат (конвертирует в u8)
    #[inline]
    pub fn from_float(
        x: f32, y: f32, z: f32,
        normal: NormalIndex,
        r: f32, g: f32, b: f32,
    ) -> Self {
        Self {
            pos_x: (x * 4.0).clamp(0.0, 255.0) as u8,
            pos_y: (y * 4.0).clamp(0.0, 255.0) as u8,
            pos_z: (z * 4.0).clamp(0.0, 255.0) as u8,
            normal_flags: normal as u8,
            color: pack_color(r, g, b, 1.0),
        }
    }
}

/// Упаковать цвет в u32 RGBA8
#[inline]
pub fn pack_color(r: f32, g: f32, b: f32, a: f32) -> u32 {
    let r = (r.clamp(0.0, 1.0) * 255.0) as u8;
    let g = (g.clamp(0.0, 1.0) * 255.0) as u8;
    let b = (b.clamp(0.0, 1.0) * 255.0) as u8;
    let a = (a.clamp(0.0, 1.0) * 255.0) as u8;
    u32::from_le_bytes([r, g, b, a])
}

/// Распаковать цвет из u32
#[inline]
pub fn unpack_color(packed: u32) -> [f32; 4] {
    let bytes = packed.to_le_bytes();
    [
        bytes[0] as f32 / 255.0,
        bytes[1] as f32 / 255.0,
        bytes[2] as f32 / 255.0,
        bytes[3] as f32 / 255.0,
    ]
}

// ============================================
// Ещё более компактный формат: 4 байта на вершину
// ============================================

/// Ультра-компактная вершина (4 байта)
/// Для случаев когда нужна максимальная экономия
#[repr(C)]
#[derive(Clone, Copy, Debug, Pod, Zeroable)]
pub struct MicroVertex {
    /// Биты 0-7: X (0-255)
    /// Биты 8-15: Y (0-255)  
    /// Биты 16-23: Z (0-255)
    /// Биты 24-26: Normal index (0-5)
    /// Биты 27-31: Color palette index (0-31)
    pub packed: u32,
}

impl MicroVertex {
    #[inline]
    pub fn new(x: u8, y: u8, z: u8, normal: u8, color_idx: u8) -> Self {
        Self {
            packed: (x as u32) 
                | ((y as u32) << 8)
                | ((z as u32) << 16)
                | ((normal as u32 & 0x7) << 24)
                | ((color_idx as u32 & 0x1F) << 27),
        }
    }

    #[inline]
    pub fn x(&self) -> u8 { (self.packed & 0xFF) as u8 }
    
    #[inline]
    pub fn y(&self) -> u8 { ((self.packed >> 8) & 0xFF) as u8 }
    
    #[inline]
    pub fn z(&self) -> u8 { ((self.packed >> 16) & 0xFF) as u8 }
    
    #[inline]
    pub fn normal(&self) -> u8 { ((self.packed >> 24) & 0x7) as u8 }
    
    #[inline]
    pub fn color_idx(&self) -> u8 { ((self.packed >> 27) & 0x1F) as u8 }
}

/// Палитра цветов для MicroVertex (32 цвета)
pub struct ColorPalette {
    pub colors: [[f32; 3]; 32],
}

impl Default for ColorPalette {
    fn default() -> Self {
        let mut colors = [[0.0; 3]; 32];
        // Базовые цвета блоков
        colors[0] = [0.0, 0.0, 0.0];       // Air/Empty
        colors[1] = [0.5, 0.5, 0.5];       // Stone
        colors[2] = [0.55, 0.35, 0.2];     // Dirt
        colors[3] = [0.3, 0.6, 0.2];       // Grass top
        colors[4] = [0.4, 0.3, 0.2];       // Grass side
        colors[5] = [0.8, 0.8, 0.6];       // Sand
        colors[6] = [0.4, 0.25, 0.15];     // Wood
        colors[7] = [0.2, 0.5, 0.2];       // Leaves
        colors[8] = [0.3, 0.3, 0.35];      // Cobblestone
        colors[9] = [0.9, 0.9, 0.9];       // Snow
        colors[10] = [0.2, 0.4, 0.8];      // Water
        // ... остальные по необходимости
        Self { colors }
    }
}


============================================================
FILE: subvoxel\meshing\vertex.rs
============================================================

// ============================================
// SubVoxel Vertex - Вершина субвокселя
// ============================================

use bytemuck::{Pod, Zeroable};

/// Вершина субвокселя (совместима с TerrainVertex)
#[repr(C)]
#[derive(Clone, Copy, Debug, Pod, Zeroable)]
pub struct SubVoxelVertex {
    pub position: [f32; 3],
    pub normal: [f32; 3],
    pub color: [f32; 3],
}

impl SubVoxelVertex {
    pub const ATTRIBS: [wgpu::VertexAttribute; 3] = wgpu::vertex_attr_array![
        0 => Float32x3,
        1 => Float32x3,
        2 => Float32x3,
    ];

    pub fn desc() -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<Self>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &Self::ATTRIBS,
        }
    }

    #[inline]
    pub fn new(position: [f32; 3], normal: [f32; 3], color: [f32; 3]) -> Self {
        Self { position, normal, color }
    }
}


============================================================
FILE: subvoxel\octree\compact.rs
============================================================

// ============================================
// Compact Octree - Минимальный размер узла
// ============================================
//
// Узел занимает 4 байта вместо 16+:
// - 1 байт: тип данных (Empty/Solid/Branch) + BlockType
// - 1 байт: child_mask (какие дети существуют)
// - 2 байта: offset к первому ребёнку
//
// Дети хранятся компактно: только существующие, без пустых слотов.

use crate::gpu::blocks::{BlockType, AIR};

/// Максимальная глубина (0=1 блок, 1=1/2, 2=1/4)
pub const MAX_DEPTH: u8 = 2;

/// Компактный узел октодерева (4 байта)
#[derive(Clone, Copy)]
#[repr(C, packed)]
pub struct CompactNode {
    /// Биты 0-5: BlockType (0 = Empty, 1-63 = solid types)
    /// Бит 6: is_branch
    /// Бит 7: reserved
    pub data: u8,
    /// Битовая маска детей (какие из 8 существуют)
    pub child_mask: u8,
    /// Offset к первому ребёнку в массиве узлов
    pub child_offset: u16,
}

impl CompactNode {
    pub const EMPTY: Self = Self {
        data: 0,
        child_mask: 0,
        child_offset: 0,
    };

    #[inline]
    pub fn solid(block_type: BlockType) -> Self {
        Self {
            data: block_type as u8,
            child_mask: 0,
            child_offset: 0,
        }
    }

    #[inline]
    pub fn branch(child_mask: u8, child_offset: u16) -> Self {
        Self {
            data: 0x40, // is_branch bit
            child_mask,
            child_offset,
        }
    }

    #[inline]
    pub fn is_empty(&self) -> bool {
        self.data == 0 && self.child_mask == 0
    }

    #[inline]
    pub fn is_solid(&self) -> bool {
        self.data != 0 && (self.data & 0x40) == 0
    }

    #[inline]
    pub fn is_branch(&self) -> bool {
        (self.data & 0x40) != 0
    }

    #[inline]
    pub fn block_type(&self) -> Option<BlockType> {
        if self.is_solid() {
            Some(self.data & 0x3F)
        } else {
            None
        }
    }

    #[inline]
    pub fn child_count(&self) -> u8 {
        self.child_mask.count_ones() as u8
    }

    /// Индекс ребёнка в компактном массиве (только существующие дети)
    #[inline]
    pub fn child_index(&self, octant: u8) -> Option<u16> {
        if (self.child_mask & (1 << octant)) == 0 {
            return None;
        }
        // Считаем сколько детей до этого октанта
        let mask_before = self.child_mask & ((1 << octant) - 1);
        Some(self.child_offset + mask_before.count_ones() as u16)
    }
}

/// Компактное октодерево
/// Все узлы в одном Vec, дети хранятся компактно
pub struct CompactOctree {
    nodes: Vec<CompactNode>,
}

impl CompactOctree {
    pub fn new() -> Self {
        Self {
            nodes: vec![CompactNode::EMPTY],
        }
    }

    #[inline]
    pub fn is_empty(&self) -> bool {
        self.nodes.len() == 1 && self.nodes[0].is_empty()
    }

    #[inline]
    pub fn node_count(&self) -> usize {
        self.nodes.len()
    }

    /// Память в байтах
    #[inline]
    pub fn memory_usage(&self) -> usize {
        self.nodes.len() * 4
    }

    /// Установить субвоксель
    pub fn set(&mut self, x: u8, y: u8, z: u8, depth: u8, block_type: BlockType) {
        let target_depth = depth.min(MAX_DEPTH);
        self.set_recursive(0, x, y, z, 0, target_depth, block_type);
        self.try_simplify(0);
    }

    fn set_recursive(
        &mut self,
        node_idx: u16,
        x: u8, y: u8, z: u8,
        current_depth: u8,
        target_depth: u8,
        block_type: BlockType,
    ) {
        if current_depth == target_depth {
            // Достигли целевой глубины
            if block_type == AIR {
                self.nodes[node_idx as usize] = CompactNode::EMPTY;
            } else {
                self.nodes[node_idx as usize] = CompactNode::solid(block_type);
            }
            return;
        }

        // Определяем октант
        let shift = target_depth - current_depth - 1;
        let octant = ((x >> shift) & 1) | (((y >> shift) & 1) << 1) | (((z >> shift) & 1) << 2);

        // Нужно спуститься - создаём детей если нет
        let node = self.nodes[node_idx as usize];
        
        if !node.is_branch() {
            // Превращаем в branch, создаём детей
            let parent_data = node.data;
            let child_offset = self.nodes.len() as u16;
            
            // Создаём всех 8 детей с данными родителя
            for _ in 0..8 {
                if parent_data == 0 {
                    self.nodes.push(CompactNode::EMPTY);
                } else {
                    self.nodes.push(CompactNode::solid(parent_data & 0x3F));
                }
            }
            
            self.nodes[node_idx as usize] = CompactNode::branch(0xFF, child_offset);
        }

        let node = self.nodes[node_idx as usize];
        if let Some(child_idx) = node.child_index(octant) {
            self.set_recursive(child_idx, x, y, z, current_depth + 1, target_depth, block_type);
        }
    }

    /// Получить субвоксель
    pub fn get(&self, x: u8, y: u8, z: u8, depth: u8) -> Option<BlockType> {
        let target_depth = depth.min(MAX_DEPTH);
        self.get_recursive(0, x, y, z, 0, target_depth)
    }

    fn get_recursive(
        &self,
        node_idx: u16,
        x: u8, y: u8, z: u8,
        current_depth: u8,
        target_depth: u8,
    ) -> Option<BlockType> {
        let node = self.nodes[node_idx as usize];

        if node.is_empty() {
            return None;
        }

        if node.is_solid() {
            return node.block_type();
        }

        if current_depth >= target_depth {
            return None;
        }

        // Branch - спускаемся
        let shift = target_depth - current_depth - 1;
        let octant = ((x >> shift) & 1) | (((y >> shift) & 1) << 1) | (((z >> shift) & 1) << 2);

        let child_idx = node.child_index(octant)?;
        self.get_recursive(child_idx, x, y, z, current_depth + 1, target_depth)
    }

    /// Удалить субвоксель
    #[inline]
    pub fn remove(&mut self, x: u8, y: u8, z: u8, depth: u8) {
        self.set(x, y, z, depth, AIR);
    }

    /// Упростить дерево (объединить одинаковых детей)
    fn try_simplify(&mut self, node_idx: u16) -> bool {
        let node = self.nodes[node_idx as usize];
        
        if !node.is_branch() || node.child_mask == 0 {
            return false;
        }

        // Рекурсивно упрощаем детей
        for octant in 0..8u8 {
            if let Some(child_idx) = node.child_index(octant) {
                self.try_simplify(child_idx);
            }
        }

        // Проверяем все ли дети одинаковые solid
        let first_child_idx = node.child_offset;
        let first = self.nodes[first_child_idx as usize];
        
        if !first.is_solid() && !first.is_empty() {
            return false;
        }

        let all_same = (1..8u8).all(|i| {
            if let Some(child_idx) = node.child_index(i) {
                let child = self.nodes[child_idx as usize];
                child.data == first.data && !child.is_branch()
            } else {
                false
            }
        });

        if all_same {
            self.nodes[node_idx as usize] = first;
            return true;
        }

        false
    }

    /// Итератор по solid субвокселям
    pub fn iter_solid(&self) -> CompactOctreeIterator<'_> {
        CompactOctreeIterator::new(self)
    }

    /// Проверка solid в области (для culling)
    pub fn is_solid_at(&self, x: f32, y: f32, z: f32, size: f32) -> bool {
        self.is_solid_at_recursive(0, x, y, z, size, 0.0, 0.0, 0.0, 1.0)
    }

    fn is_solid_at_recursive(
        &self,
        node_idx: u16,
        qx: f32, qy: f32, qz: f32, qsize: f32,
        nx: f32, ny: f32, nz: f32, nsize: f32,
    ) -> bool {
        // AABB test
        if qx + qsize <= nx || qx >= nx + nsize ||
           qy + qsize <= ny || qy >= ny + nsize ||
           qz + qsize <= nz || qz >= nz + nsize {
            return false;
        }

        let node = self.nodes[node_idx as usize];

        if node.is_empty() {
            return false;
        }

        if node.is_solid() {
            return true;
        }

        // Branch
        let half = nsize * 0.5;
        for octant in 0..8u8 {
            if let Some(child_idx) = node.child_index(octant) {
                let cx = nx + ((octant & 1) as f32) * half;
                let cy = ny + (((octant >> 1) & 1) as f32) * half;
                let cz = nz + (((octant >> 2) & 1) as f32) * half;

                if self.is_solid_at_recursive(child_idx, qx, qy, qz, qsize, cx, cy, cz, half) {
                    return true;
                }
            }
        }

        false
    }
}

impl Default for CompactOctree {
    fn default() -> Self {
        Self::new()
    }
}

/// Итератор по solid субвокселям
pub struct CompactOctreeIterator<'a> {
    octree: &'a CompactOctree,
    stack: Vec<(u16, f32, f32, f32, f32)>, // (node_idx, x, y, z, size)
}

impl<'a> CompactOctreeIterator<'a> {
    fn new(octree: &'a CompactOctree) -> Self {
        let mut iter = Self {
            octree,
            stack: Vec::with_capacity(32),
        };
        if !octree.nodes.is_empty() && !octree.nodes[0].is_empty() {
            iter.stack.push((0, 0.0, 0.0, 0.0, 1.0));
        }
        iter
    }
}

impl<'a> Iterator for CompactOctreeIterator<'a> {
    type Item = (f32, f32, f32, f32, BlockType); // x, y, z, size, block_type

    fn next(&mut self) -> Option<Self::Item> {
        while let Some((node_idx, x, y, z, size)) = self.stack.pop() {
            let node = self.octree.nodes[node_idx as usize];

            if node.is_empty() {
                continue;
            }

            if let Some(bt) = node.block_type() {
                return Some((x, y, z, size, bt));
            }

            if node.is_branch() {
                let half = size * 0.5;
                for octant in (0..8u8).rev() {
                    if let Some(child_idx) = node.child_index(octant) {
                        let cx = x + ((octant & 1) as f32) * half;
                        let cy = y + (((octant >> 1) & 1) as f32) * half;
                        let cz = z + (((octant >> 2) & 1) as f32) * half;
                        
                        let child = self.octree.nodes[child_idx as usize];
                        if !child.is_empty() {
                            self.stack.push((child_idx, cx, cy, cz, half));
                        }
                    }
                }
            }
        }
        None
    }
}


============================================================
FILE: subvoxel\octree\linear.rs
============================================================

// ============================================
// Linear Octree - Кэш-дружественное октодерево
// ============================================
//
// Все узлы хранятся в непрерывном Vec, ссылки через u32 индексы.
// Это устраняет pointer chasing и cache misses.

use crate::gpu::blocks::{BlockType, AIR};

/// Невалидный индекс (аналог null)
pub const INVALID_INDEX: u32 = u32::MAX;

/// Максимальная глубина (0=1 блок, 1=1/2, 2=1/4)
pub const MAX_DEPTH: u8 = 2;

/// Данные узла
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum NodeData {
    /// Пустой (воздух)
    Empty,
    /// Заполнен одним типом
    Solid(BlockType),
    /// Смешанный - есть дети
    Branch,
}

/// Узел октодерева (32 байта, выровнен для кэша)
#[derive(Clone, Copy)]
#[repr(C)]
pub struct OctreeNode {
    /// Данные узла
    pub data: NodeData,
    /// Глубина (0 = корень)
    pub depth: u8,
    /// Индекс первого ребенка (дети идут подряд: first, first+1, ..., first+7)
    /// INVALID_INDEX если нет детей
    pub first_child: u32,
}

impl OctreeNode {
    #[inline]
    pub fn empty(depth: u8) -> Self {
        Self {
            data: NodeData::Empty,
            depth,
            first_child: INVALID_INDEX,
        }
    }

    #[inline]
    pub fn solid(block_type: BlockType, depth: u8) -> Self {
        Self {
            data: NodeData::Solid(block_type),
            depth,
            first_child: INVALID_INDEX,
        }
    }

    #[inline]
    pub fn branch(depth: u8, first_child: u32) -> Self {
        Self {
            data: NodeData::Branch,
            depth,
            first_child,
        }
    }

    #[inline]
    pub fn has_children(&self) -> bool {
        self.first_child != INVALID_INDEX
    }

    #[inline]
    pub fn is_empty(&self) -> bool {
        matches!(self.data, NodeData::Empty)
    }

    #[inline]
    pub fn is_solid(&self) -> bool {
        matches!(self.data, NodeData::Solid(_))
    }
}

impl Default for OctreeNode {
    fn default() -> Self {
        Self::empty(0)
    }
}

/// Linear Octree - все узлы в одном Vec
#[derive(Clone)]
pub struct LinearOctree {
    /// Плоский массив узлов
    nodes: Vec<OctreeNode>,
    /// Свободные слоты (для переиспользования)
    free_list: Vec<u32>,
}

impl LinearOctree {
    /// Создать пустое октодерево
    pub fn new() -> Self {
        let mut octree = Self {
            nodes: Vec::with_capacity(64),
            free_list: Vec::new(),
        };
        // Корень всегда на индексе 0
        octree.nodes.push(OctreeNode::empty(0));
        octree
    }

    /// Создать заполненное октодерево
    pub fn solid(block_type: BlockType) -> Self {
        let mut octree = Self {
            nodes: Vec::with_capacity(64),
            free_list: Vec::new(),
        };
        octree.nodes.push(OctreeNode::solid(block_type, 0));
        octree
    }

    /// Проверить пустоту
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.nodes.get(0).map(|n| n.is_empty()).unwrap_or(true)
    }

    /// Количество узлов
    #[inline]
    pub fn node_count(&self) -> usize {
        self.nodes.len() - self.free_list.len()
    }

    /// Установить субвоксель по дискретным координатам
    /// x, y, z: 0..divisions, divisions = 2^depth
    pub fn set_discrete(&mut self, x: u8, y: u8, z: u8, depth: u8, block_type: BlockType) {
        let target_depth = depth.min(MAX_DEPTH);
        self.set_at_node(0, x, y, z, 0, target_depth, block_type);
        self.try_simplify(0);
    }

    fn set_at_node(
        &mut self,
        node_idx: u32,
        x: u8, y: u8, z: u8,
        current_depth: u8,
        target_depth: u8,
        block_type: BlockType,
    ) {
        // Достигли целевой глубины
        if current_depth == target_depth {
            // Сначала проверяем и освобождаем детей
            let first_child = self.nodes[node_idx as usize].first_child;
            if first_child != INVALID_INDEX {
                self.free_children(first_child);
            }
            // Теперь обновляем узел
            let node = &mut self.nodes[node_idx as usize];
            node.first_child = INVALID_INDEX;
            node.data = if block_type == AIR {
                NodeData::Empty
            } else {
                NodeData::Solid(block_type)
            };
            return;
        }

        // Нужно спуститься глубже - создаем детей если нет
        let first_child = {
            let node = &self.nodes[node_idx as usize];
            if node.has_children() {
                node.first_child
            } else {
                // Создаем 8 детей с данными родителя
                let parent_data = node.data;
                let child_depth = current_depth + 1;
                let first = self.alloc_children(parent_data, child_depth);
                self.nodes[node_idx as usize].first_child = first;
                self.nodes[node_idx as usize].data = NodeData::Branch;
                first
            }
        };

        // Определяем какой ребенок
        let shift = target_depth - current_depth - 1;
        let lx = (x >> shift) & 1;
        let ly = (y >> shift) & 1;
        let lz = (z >> shift) & 1;
        let child_idx = first_child + Self::child_offset(lx, ly, lz);

        // Рекурсия
        self.set_at_node(child_idx, x, y, z, current_depth + 1, target_depth, block_type);
    }

    /// Получить субвоксель
    pub fn get_discrete(&self, x: u8, y: u8, z: u8, depth: u8) -> Option<BlockType> {
        let target_depth = depth.min(MAX_DEPTH);
        self.get_at_node(0, x, y, z, 0, target_depth)
    }

    fn get_at_node(
        &self,
        node_idx: u32,
        x: u8, y: u8, z: u8,
        current_depth: u8,
        target_depth: u8,
    ) -> Option<BlockType> {
        let node = &self.nodes[node_idx as usize];

        match node.data {
            NodeData::Empty => None,
            NodeData::Solid(bt) => Some(bt),
            NodeData::Branch => {
                if current_depth >= target_depth || !node.has_children() {
                    return None;
                }

                let shift = target_depth - current_depth - 1;
                let lx = (x >> shift) & 1;
                let ly = (y >> shift) & 1;
                let lz = (z >> shift) & 1;
                let child_idx = node.first_child + Self::child_offset(lx, ly, lz);

                self.get_at_node(child_idx, x, y, z, current_depth + 1, target_depth)
            }
        }
    }

    /// Удалить субвоксель
    #[inline]
    pub fn remove_discrete(&mut self, x: u8, y: u8, z: u8, depth: u8) {
        self.set_discrete(x, y, z, depth, AIR);
    }

    /// Попытаться упростить узел (если все дети одинаковые)
    fn try_simplify(&mut self, node_idx: u32) -> bool {
        let node = &self.nodes[node_idx as usize];
        if !node.has_children() {
            return false;
        }

        let first_child = node.first_child;

        // Сначала рекурсивно упрощаем детей
        for i in 0..8 {
            self.try_simplify(first_child + i);
        }

        // Проверяем все ли дети одинаковые листья
        let first_data = self.nodes[first_child as usize].data;
        if matches!(first_data, NodeData::Branch) {
            return false;
        }

        let all_same = (1..8).all(|i| {
            let child = &self.nodes[(first_child + i) as usize];
            !child.has_children() && child.data == first_data
        });

        if all_same {
            // Освобождаем детей
            self.free_children(first_child);
            // Упрощаем узел
            let node = &mut self.nodes[node_idx as usize];
            node.first_child = INVALID_INDEX;
            node.data = first_data;
            return true;
        }

        false
    }

    /// Аллоцировать 8 детей
    fn alloc_children(&mut self, data: NodeData, depth: u8) -> u32 {
        // Пытаемся переиспользовать из free_list (нужно 8 подряд)
        // Для простоты всегда аллоцируем новые
        let first = self.nodes.len() as u32;
        let child_node = OctreeNode {
            data,
            depth,
            first_child: INVALID_INDEX,
        };
        for _ in 0..8 {
            self.nodes.push(child_node);
        }
        first
    }

    /// Освободить 8 детей
    fn free_children(&mut self, first_child: u32) {
        // Рекурсивно освобождаем внуков
        for i in 0..8 {
            let child_idx = first_child + i;
            let child = &self.nodes[child_idx as usize];
            if child.has_children() {
                self.free_children(child.first_child);
            }
        }
        // Добавляем в free_list
        for i in 0..8 {
            self.free_list.push(first_child + i);
        }
    }

    /// Индекс ребенка по локальным координатам
    #[inline]
    fn child_offset(lx: u8, ly: u8, lz: u8) -> u32 {
        ((lz as u32) << 2) | ((ly as u32) << 1) | (lx as u32)
    }

    /// Локальные координаты из offset
    #[inline]
    pub fn offset_to_local(offset: u32) -> (u8, u8, u8) {
        let lx = (offset & 1) as u8;
        let ly = ((offset >> 1) & 1) as u8;
        let lz = ((offset >> 2) & 1) as u8;
        (lx, ly, lz)
    }

    /// Получить узел по индексу (для внешнего обхода)
    #[inline]
    pub fn get_node(&self, idx: u32) -> &OctreeNode {
        &self.nodes[idx as usize]
    }

    /// Проверка, есть ли solid воксель в заданной области
    /// x, y, z в нормализованных координатах [0, 1)
    /// size - размер проверяемой области
    pub fn is_solid_at(&self, x: f32, y: f32, z: f32, size: f32) -> bool {
        self.is_solid_at_node(0, x, y, z, size, 0.0, 0.0, 0.0, 1.0)
    }

    fn is_solid_at_node(
        &self,
        node_idx: u32,
        qx: f32, qy: f32, qz: f32, qsize: f32,
        nx: f32, ny: f32, nz: f32, nsize: f32,
    ) -> bool {
        // Проверяем пересечение AABB
        if qx + qsize <= nx || qx >= nx + nsize ||
           qy + qsize <= ny || qy >= ny + nsize ||
           qz + qsize <= nz || qz >= nz + nsize {
            return false;
        }

        let node = &self.nodes[node_idx as usize];

        match node.data {
            NodeData::Empty => false,
            NodeData::Solid(_) => true,
            NodeData::Branch => {
                if !node.has_children() {
                    return false;
                }

                let half = nsize * 0.5;
                let first = node.first_child;

                for i in 0..8u32 {
                    let (lx, ly, lz) = Self::offset_to_local(i);
                    let cx = nx + lx as f32 * half;
                    let cy = ny + ly as f32 * half;
                    let cz = nz + lz as f32 * half;

                    if self.is_solid_at_node(first + i, qx, qy, qz, qsize, cx, cy, cz, half) {
                        return true;
                    }
                }
                false
            }
        }
    }

    /// Итератор по всем непустым субвокселям
    /// Возвращает (x, y, z, size, block_type) в нормализованных координатах [0, 1)
    pub fn iter_solid(&self) -> LinearOctreeIterator<'_> {
        LinearOctreeIterator::new(self)
    }

    /// Подсчет непустых вокселей
    pub fn count_solid(&self) -> usize {
        self.count_solid_at(0)
    }

    fn count_solid_at(&self, node_idx: u32) -> usize {
        let node = &self.nodes[node_idx as usize];
        match node.data {
            NodeData::Empty => 0,
            NodeData::Solid(_) => 1,
            NodeData::Branch => {
                if node.has_children() {
                    (0..8).map(|i| self.count_solid_at(node.first_child + i)).sum()
                } else {
                    0
                }
            }
        }
    }

    /// Raycast через октодерево - O(log N)
    /// Пропускает пустые поддеревья через Ray-AABB тест
    /// Возвращает (x, y, z, size, block_type, t, normal)
    pub fn raycast(
        &self,
        origin: [f32; 3],
        direction: [f32; 3],
        max_t: f32,
    ) -> Option<OctreeRaycastHit> {
        if self.nodes.is_empty() || self.nodes[0].is_empty() {
            return None;
        }
        self.raycast_node(0, origin, direction, [0.0, 0.0, 0.0], 1.0, max_t)
    }

    fn raycast_node(
        &self,
        node_idx: u32,
        origin: [f32; 3],
        direction: [f32; 3],
        node_min: [f32; 3],
        size: f32,
        max_t: f32,
    ) -> Option<OctreeRaycastHit> {
        let node = &self.nodes[node_idx as usize];

        // Ray-AABB тест - пропускаем узел если луч не пересекает
        let node_max = [node_min[0] + size, node_min[1] + size, node_min[2] + size];
        let Some((t_entry, normal)) = octree_ray_aabb(origin, direction, node_min, node_max) else {
            return None;
        };

        if t_entry > max_t {
            return None;
        }

        match node.data {
            NodeData::Empty => None,
            NodeData::Solid(block_type) => Some(OctreeRaycastHit {
                x: node_min[0],
                y: node_min[1],
                z: node_min[2],
                size,
                block_type,
                t: t_entry.max(0.0),
                normal,
            }),
            NodeData::Branch => {
                if !node.has_children() {
                    return None;
                }

                let half = size * 0.5;
                let first = node.first_child;
                let mut closest: Option<OctreeRaycastHit> = None;

                // Собираем детей с их t_entry для сортировки
                let mut children: [(u32, f32); 8] = [(0, f32::MAX); 8];
                for i in 0..8u32 {
                    let (lx, ly, lz) = Self::offset_to_local(i);
                    let child_min = [
                        node_min[0] + lx as f32 * half,
                        node_min[1] + ly as f32 * half,
                        node_min[2] + lz as f32 * half,
                    ];
                    let child_max = [child_min[0] + half, child_min[1] + half, child_min[2] + half];
                    
                    let t = octree_ray_aabb(origin, direction, child_min, child_max)
                        .map(|(t, _)| t)
                        .unwrap_or(f32::MAX);
                    children[i as usize] = (i, t);
                }

                // Сортируем по расстоянию для early-exit
                children.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap_or(std::cmp::Ordering::Equal));

                for (i, t_child) in children {
                    // Early exit: если ближайший ребёнок дальше текущего hit - выходим
                    let current_max = closest.as_ref().map(|c| c.t).unwrap_or(max_t);
                    if t_child > current_max {
                        break;
                    }

                    let (lx, ly, lz) = Self::offset_to_local(i);
                    let child_min = [
                        node_min[0] + lx as f32 * half,
                        node_min[1] + ly as f32 * half,
                        node_min[2] + lz as f32 * half,
                    ];

                    if let Some(hit) = self.raycast_node(first + i, origin, direction, child_min, half, current_max) {
                        if closest.is_none() || hit.t < closest.as_ref().unwrap().t {
                            closest = Some(hit);
                        }
                    }
                }
                closest
            }
        }
    }
}

/// Результат raycast в октодереве
#[derive(Clone, Copy, Debug)]
pub struct OctreeRaycastHit {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub size: f32,
    pub block_type: BlockType,
    pub t: f32,
    pub normal: [f32; 3],
}

/// Ray-AABB intersection для октодерева
#[inline]
fn octree_ray_aabb(
    origin: [f32; 3],
    direction: [f32; 3],
    aabb_min: [f32; 3],
    aabb_max: [f32; 3],
) -> Option<(f32, [f32; 3])> {
    let mut t_min = f32::NEG_INFINITY;
    let mut t_max = f32::INFINITY;
    let mut normal = [0.0f32; 3];

    for i in 0..3 {
        if direction[i].abs() < 1e-8 {
            if origin[i] < aabb_min[i] || origin[i] > aabb_max[i] {
                return None;
            }
        } else {
            let inv_d = 1.0 / direction[i];
            let mut t1 = (aabb_min[i] - origin[i]) * inv_d;
            let mut t2 = (aabb_max[i] - origin[i]) * inv_d;

            let mut n = [0.0f32; 3];
            n[i] = -inv_d.signum();

            if t1 > t2 {
                std::mem::swap(&mut t1, &mut t2);
                n[i] = inv_d.signum();
            }

            if t1 > t_min {
                t_min = t1;
                normal = n;
            }
            t_max = t_max.min(t2);

            if t_min > t_max {
                return None;
            }
        }
    }

    Some((t_min, normal))
}

impl Default for LinearOctree {
    fn default() -> Self {
        Self::new()
    }
}

/// Итератор по непустым субвокселям (stack-based, без аллокаций)
pub struct LinearOctreeIterator<'a> {
    octree: &'a LinearOctree,
    /// Стек: (node_idx, x, y, z, size)
    stack: Vec<(u32, f32, f32, f32, f32)>,
}

impl<'a> LinearOctreeIterator<'a> {
    fn new(octree: &'a LinearOctree) -> Self {
        let mut iter = Self {
            octree,
            stack: Vec::with_capacity(32),
        };
        if !octree.nodes.is_empty() && !octree.nodes[0].is_empty() {
            iter.stack.push((0, 0.0, 0.0, 0.0, 1.0));
        }
        iter
    }
}

impl<'a> Iterator for LinearOctreeIterator<'a> {
    type Item = (f32, f32, f32, f32, BlockType); // x, y, z, size, block_type

    fn next(&mut self) -> Option<Self::Item> {
        while let Some((node_idx, x, y, z, size)) = self.stack.pop() {
            let node = &self.octree.nodes[node_idx as usize];

            match node.data {
                NodeData::Empty => continue,
                NodeData::Solid(bt) => {
                    return Some((x, y, z, size, bt));
                }
                NodeData::Branch => {
                    if node.has_children() {
                        let half = size * 0.5;
                        let first = node.first_child;
                        // Добавляем детей в обратном порядке для правильного обхода
                        for i in (0..8).rev() {
                            let (lx, ly, lz) = LinearOctree::offset_to_local(i);
                            let cx = x + lx as f32 * half;
                            let cy = y + ly as f32 * half;
                            let cz = z + lz as f32 * half;
                            let child = &self.octree.nodes[(first + i) as usize];
                            if !child.is_empty() {
                                self.stack.push((first + i, cx, cy, cz, half));
                            }
                        }
                    }
                }
            }
        }
        None
    }
}


============================================================
FILE: subvoxel\octree\mod.rs
============================================================

// ============================================
// Octree Module - Compact Octree для субвокселей
// ============================================
//
// Две реализации:
// - LinearOctree: Оригинальная (для совместимости)
// - CompactOctree: Оптимизированная (4 байта на узел)

mod linear;
mod compact;

pub use linear::{LinearOctree, OctreeNode, NodeData, LinearOctreeIterator, OctreeRaycastHit, MAX_DEPTH, INVALID_INDEX};
pub use compact::{CompactOctree, CompactNode, CompactOctreeIterator};


============================================================
FILE: subvoxel\render\mod.rs
============================================================

// ============================================
// Render Module - Рендеринг субвокселей
// ============================================

mod renderer;

pub use renderer::OptimizedSubVoxelRenderer;


============================================================
FILE: subvoxel\render\renderer.rs
============================================================

// ============================================
// SubVoxel Renderer - GPU рендеринг (ОПТИМИЗИРОВАННЫЙ)
// ============================================
//
// Использует:
// - PackedVertex (8 байт вместо 36)
// - MaskGreedyContext (без сортировки)
// - SparseChunkStorage (O(N) память)

use std::collections::HashMap;
use crate::gpu::subvoxel::meshing::{PackedVertex, MaskGreedyContext, VoxelAccess, greedy_mesh_masked};
use crate::gpu::subvoxel::chunk::{SubVoxelChunkKey, SparseChunkStorage};
use crate::gpu::subvoxel::components::SubVoxelWorld;
use crate::gpu::blocks::BlockType;

/// GPU данные для одного чанка
struct ChunkGpuData {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    num_indices: u32,
    version: u64,
}

/// Рендерер субвокселей (оптимизированный)
pub struct OptimizedSubVoxelRenderer {
    /// GPU буферы по чанкам
    chunk_buffers: HashMap<SubVoxelChunkKey, ChunkGpuData>,
    /// Контекст для meshing (переиспользуется)
    mesh_ctx: MaskGreedyContext,
}

impl OptimizedSubVoxelRenderer {
    pub fn new(_device: &wgpu::Device) -> Self {
        Self {
            chunk_buffers: HashMap::new(),
            mesh_ctx: MaskGreedyContext::new(),
        }
    }

    /// Обновить только грязные чанки
    pub fn update_dirty_chunks(
        &mut self,
        device: &wgpu::Device,
        queue: &wgpu::Queue,
        world: &mut SubVoxelWorld,
    ) {
        let dirty_chunks = world.take_dirty_chunks();

        if dirty_chunks.is_empty() {
            return;
        }

        for chunk_key in dirty_chunks {
            if let Some(chunk) = world.get_chunk(&chunk_key) {
                if chunk.is_empty() {
                    self.chunk_buffers.remove(&chunk_key);
                    continue;
                }

                // Генерируем меш через mask greedy
                let chunk_offset = [
                    (chunk_key.x * 16) as f32,
                    0.0,
                    (chunk_key.z * 16) as f32,
                ];

                let voxel_access = SparseChunkVoxelAccess::new(chunk);
                greedy_mesh_masked(&voxel_access, &mut self.mesh_ctx, chunk_offset);

                if self.mesh_ctx.vertices.is_empty() {
                    self.chunk_buffers.remove(&chunk_key);
                } else {
                    let vertices = std::mem::take(&mut self.mesh_ctx.vertices);
                    let indices = std::mem::take(&mut self.mesh_ctx.indices);
                    self.update_chunk_buffers(
                        device, queue, chunk_key,
                        vertices, indices, chunk.version()
                    );
                }
            } else {
                self.chunk_buffers.remove(&chunk_key);
            }
        }
    }

    fn update_chunk_buffers(
        &mut self,
        device: &wgpu::Device,
        queue: &wgpu::Queue,
        chunk_key: SubVoxelChunkKey,
        vertices: Vec<PackedVertex>,
        indices: Vec<u32>,
        version: u64,
    ) {
        let vertex_size = vertices.len() * std::mem::size_of::<PackedVertex>();
        let index_size = indices.len() * std::mem::size_of::<u32>();

        let needs_recreate = self.chunk_buffers.get(&chunk_key)
            .map(|data| {
                data.vertex_buffer.size() < vertex_size as u64 ||
                data.index_buffer.size() < index_size as u64
            })
            .unwrap_or(true);

        if needs_recreate {
            let vertex_buffer = device.create_buffer(&wgpu::BufferDescriptor {
                label: Some(&format!("SubVoxel Chunk {:?} Vertex", chunk_key)),
                size: (vertex_size * 2).max(256) as u64, // Меньше минимум т.к. вершины компактнее
                usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
                mapped_at_creation: false,
            });

            let index_buffer = device.create_buffer(&wgpu::BufferDescriptor {
                label: Some(&format!("SubVoxel Chunk {:?} Index", chunk_key)),
                size: (index_size * 2).max(256) as u64,
                usage: wgpu::BufferUsages::INDEX | wgpu::BufferUsages::COPY_DST,
                mapped_at_creation: false,
            });

            self.chunk_buffers.insert(chunk_key, ChunkGpuData {
                vertex_buffer,
                index_buffer,
                num_indices: 0,
                version: 0,
            });
        }

        if let Some(gpu_data) = self.chunk_buffers.get_mut(&chunk_key) {
            queue.write_buffer(&gpu_data.vertex_buffer, 0, bytemuck::cast_slice(&vertices));
            queue.write_buffer(&gpu_data.index_buffer, 0, bytemuck::cast_slice(&indices));
            gpu_data.num_indices = indices.len() as u32;
            gpu_data.version = version;
        }
    }

    pub fn iter_chunk_buffers(&self) -> impl Iterator<Item = (&wgpu::Buffer, &wgpu::Buffer, u32)> {
        self.chunk_buffers.values()
            .filter(|d| d.num_indices > 0)
            .map(|d| (&d.vertex_buffer, &d.index_buffer, d.num_indices))
    }

    pub fn total_indices(&self) -> u32 {
        self.chunk_buffers.values().map(|d| d.num_indices).sum()
    }

    pub fn has_content(&self) -> bool {
        self.chunk_buffers.values().any(|d| d.num_indices > 0)
    }

    pub fn chunk_count(&self) -> usize {
        self.chunk_buffers.len()
    }

    /// Общее использование GPU памяти (байт)
    pub fn gpu_memory_usage(&self) -> usize {
        self.chunk_buffers.values()
            .map(|d| d.vertex_buffer.size() as usize + d.index_buffer.size() as usize)
            .sum()
    }
}

// ============================================
// Адаптер VoxelAccess для SparseChunkStorage
// ============================================

struct SparseChunkVoxelAccess<'a> {
    storage: &'a SparseChunkStorage,
    min_y: i32,
    max_y: i32,
}

impl<'a> SparseChunkVoxelAccess<'a> {
    fn new(storage: &'a SparseChunkStorage) -> Self {
        let (min_y, max_y) = storage.y_range();
        Self {
            storage,
            min_y: min_y as i32 * 4,
            max_y: (max_y as i32 + 1) * 4 - 1,
        }
    }
}

impl<'a> VoxelAccess for SparseChunkVoxelAccess<'a> {
    fn get(&self, x: i32, y: i32, z: i32) -> Option<BlockType> {
        if x < 0 || x >= 64 || z < 0 || z >= 64 || y < self.min_y || y > self.max_y {
            return None;
        }

        let block_x = (x / 4) as u8;
        let block_z = (z / 4) as u8;
        let block_y = (y / 4) as u8;
        let sub_x = (x % 4) as u8;
        let sub_y = (y % 4) as u8;
        let sub_z = (z % 4) as u8;

        self.storage.get(block_x, block_y, block_z, sub_x, sub_y, sub_z, 2)
    }

    fn bounds(&self) -> (i32, i32, i32, i32, i32, i32) {
        (0, self.min_y, 0, 63, self.max_y, 63)
    }
}


============================================================
FILE: subvoxel\systems\mesh.rs
============================================================

// ============================================
// Mesh System - ECS система генерации мешей
// ============================================

// Legacy mesher (с декомпрессией в ChunkGrid)
pub use crate::gpu::subvoxel::meshing::{
    ChunkMeshData, ChunkMeshContext, mesh_chunk, mesh_chunk_new, SubVoxelVertex,
};

// Новый octree mesher (без декомпрессии, O(log N))
pub use crate::gpu::subvoxel::meshing::{
    OctreeMeshData, OctreeMeshContext, mesh_chunk_octree, mesh_chunk_octree_new,
};


============================================================
FILE: subvoxel\systems\mesh_system.rs
============================================================

// ============================================
// Mesh System - ECS система генерации мешей (ОПТИМИЗИРОВАННАЯ)
// ============================================
//
// Использует:
// - SparseChunkStorage (O(N) память)
// - MaskGreedyContext (битовые маски, без сортировки)
// - PackedVertex (8 байт вместо 36)

use std::collections::{HashMap, HashSet};
use crate::gpu::blocks::BlockType;
use crate::gpu::subvoxel::chunk::{SubVoxelChunkKey, SparseChunkStorage, PackedBlockKey};
use crate::gpu::subvoxel::meshing::{
    PackedVertex, MaskGreedyContext, VoxelAccess, greedy_mesh_masked,
};

// ============================================
// Компоненты
// ============================================

/// Маркер грязного чанка
#[derive(Clone, Copy, Debug)]
pub struct DirtyChunk {
    pub key: SubVoxelChunkKey,
    pub priority: u8,
}

/// Готовый меш чанка (оптимизированный)
#[derive(Default)]
pub struct ChunkMesh {
    pub vertices: Vec<PackedVertex>,
    pub indices: Vec<u32>,
    pub version: u64,
}

impl ChunkMesh {
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.vertices.is_empty()
    }

    #[inline]
    pub fn vertex_count(&self) -> usize {
        self.vertices.len()
    }

    #[inline]
    pub fn index_count(&self) -> usize {
        self.indices.len()
    }

    /// Память в байтах
    #[inline]
    pub fn memory_usage(&self) -> usize {
        self.vertices.len() * std::mem::size_of::<PackedVertex>() +
        self.indices.len() * std::mem::size_of::<u32>()
    }
}

// ============================================
// Адаптер для VoxelAccess
// ============================================

/// Адаптер SparseChunkStorage -> VoxelAccess для mask greedy
struct SparseChunkVoxelAccess<'a> {
    storage: &'a SparseChunkStorage,
    min_y: i32,
    max_y: i32,
}

impl<'a> SparseChunkVoxelAccess<'a> {
    fn new(storage: &'a SparseChunkStorage) -> Self {
        let (min_y, max_y) = storage.y_range();
        Self {
            storage,
            min_y: min_y as i32 * 4, // В субвоксельных координатах
            max_y: (max_y as i32 + 1) * 4 - 1,
        }
    }
}

impl<'a> VoxelAccess for SparseChunkVoxelAccess<'a> {
    fn get(&self, x: i32, y: i32, z: i32) -> Option<BlockType> {
        if x < 0 || x >= 64 || z < 0 || z >= 64 || y < self.min_y || y > self.max_y {
            return None;
        }

        // Конвертируем субвоксельные координаты в блок + sub
        let block_x = (x / 4) as u8;
        let block_z = (z / 4) as u8;
        let block_y = (y / 4) as u8;
        let sub_x = (x % 4) as u8;
        let sub_y = (y % 4) as u8;
        let sub_z = (z % 4) as u8;

        self.storage.get(block_x, block_y, block_z, sub_x, sub_y, sub_z, 2)
    }

    fn bounds(&self) -> (i32, i32, i32, i32, i32, i32) {
        (0, self.min_y, 0, 63, self.max_y, 63)
    }
}

// ============================================
// Ресурсы
// ============================================

/// Конфигурация мешинга
#[derive(Clone)]
pub struct MeshingConfig {
    pub max_chunks_per_frame: usize,
    pub priority_radius: i32,
}

impl Default for MeshingConfig {
    fn default() -> Self {
        Self {
            max_chunks_per_frame: 4,
            priority_radius: 2,
        }
    }
}

/// Контекст системы мешинга
pub struct MeshingSystemContext {
    /// Контекст mask greedy (переиспользуемый)
    greedy_ctx: MaskGreedyContext,
    /// Очередь грязных чанков
    dirty_queue: Vec<DirtyChunk>,
    /// Готовые меши
    meshes: HashMap<SubVoxelChunkKey, ChunkMesh>,
    /// Конфигурация
    config: MeshingConfig,
}

impl MeshingSystemContext {
    pub fn new() -> Self {
        Self {
            greedy_ctx: MaskGreedyContext::new(),
            dirty_queue: Vec::with_capacity(64),
            meshes: HashMap::with_capacity(256),
            config: MeshingConfig::default(),
        }
    }

    pub fn with_config(config: MeshingConfig) -> Self {
        Self {
            greedy_ctx: MaskGreedyContext::new(),
            dirty_queue: Vec::with_capacity(64),
            meshes: HashMap::with_capacity(256),
            config,
        }
    }
}

impl Default for MeshingSystemContext {
    fn default() -> Self {
        Self::new()
    }
}

// ============================================
// Системы
// ============================================

/// Помечает чанк как грязный
pub fn mark_chunk_dirty(ctx: &mut MeshingSystemContext, key: SubVoxelChunkKey, priority: u8) {
    if ctx.dirty_queue.iter().any(|d| d.key == key) {
        return;
    }
    ctx.dirty_queue.push(DirtyChunk { key, priority });
}

/// Обновляет приоритеты чанков
pub fn update_priorities(ctx: &mut MeshingSystemContext, player_chunk_x: i32, player_chunk_z: i32) {
    let radius = ctx.config.priority_radius;
    for dirty in &mut ctx.dirty_queue {
        let dx = (dirty.key.x - player_chunk_x).abs();
        let dz = (dirty.key.z - player_chunk_z).abs();
        if dx <= radius && dz <= radius {
            dirty.priority = 255 - (dx + dz).min(255) as u8;
        }
    }
}

/// Обрабатывает очередь мешинга
/// Возвращает количество обработанных чанков
pub fn process_meshing_queue(
    ctx: &mut MeshingSystemContext,
    storages: &HashMap<SubVoxelChunkKey, SparseChunkStorage>,
) -> usize {
    if ctx.dirty_queue.is_empty() {
        return 0;
    }

    // Сортируем по приоритету
    ctx.dirty_queue.sort_by(|a, b| b.priority.cmp(&a.priority));

    let max_chunks = ctx.config.max_chunks_per_frame;
    let mut processed = 0;

    while processed < max_chunks && !ctx.dirty_queue.is_empty() {
        let dirty = ctx.dirty_queue.remove(0);
        
        let Some(storage) = storages.get(&dirty.key) else {
            // Чанк удалён - удаляем меш
            ctx.meshes.remove(&dirty.key);
            continue;
        };

        if storage.is_empty() {
            ctx.meshes.remove(&dirty.key);
            processed += 1;
            continue;
        }

        // Генерируем меш через mask greedy
        let chunk_offset = [
            (dirty.key.x * 16) as f32,
            0.0,
            (dirty.key.z * 16) as f32,
        ];

        let voxel_access = SparseChunkVoxelAccess::new(storage);
        greedy_mesh_masked(&voxel_access, &mut ctx.greedy_ctx, chunk_offset);

        // Сохраняем результат
        ctx.meshes.insert(dirty.key, ChunkMesh {
            vertices: std::mem::take(&mut ctx.greedy_ctx.vertices),
            indices: std::mem::take(&mut ctx.greedy_ctx.indices),
            version: storage.version(),
        });

        processed += 1;
    }

    processed
}

/// Получает меш чанка
#[inline]
pub fn get_chunk_mesh(ctx: &MeshingSystemContext, key: SubVoxelChunkKey) -> Option<&ChunkMesh> {
    ctx.meshes.get(&key)
}

/// Получает все меши
#[inline]
pub fn get_all_meshes(ctx: &MeshingSystemContext) -> &HashMap<SubVoxelChunkKey, ChunkMesh> {
    &ctx.meshes
}

/// Удаляет меш чанка
pub fn remove_chunk_mesh(ctx: &mut MeshingSystemContext, key: SubVoxelChunkKey) {
    ctx.meshes.remove(&key);
    ctx.dirty_queue.retain(|d| d.key != key);
}

/// Очищает все меши
pub fn clear_all_meshes(ctx: &mut MeshingSystemContext) {
    ctx.meshes.clear();
    ctx.dirty_queue.clear();
}

// ============================================
// Статистика
// ============================================

#[derive(Clone, Copy, Debug, Default)]
pub struct MeshingStats {
    pub total_meshes: usize,
    pub dirty_queue_size: usize,
    pub total_vertices: usize,
    pub total_indices: usize,
    pub total_memory_bytes: usize,
}

pub fn get_meshing_stats(ctx: &MeshingSystemContext) -> MeshingStats {
    let (total_vertices, total_indices, total_memory) = ctx.meshes.values()
        .fold((0, 0, 0), |(v, i, m), mesh| {
            (v + mesh.vertex_count(), i + mesh.index_count(), m + mesh.memory_usage())
        });

    MeshingStats {
        total_meshes: ctx.meshes.len(),
        dirty_queue_size: ctx.dirty_queue.len(),
        total_vertices,
        total_indices,
        total_memory_bytes: total_memory,
    }
}


============================================================
FILE: subvoxel\systems\mod.rs
============================================================

// ============================================
// SubVoxel Systems - ECS системы (ОПТИМИЗИРОВАННЫЕ)
// ============================================

mod placement;
mod raycast;
mod mesh;
mod mesh_system;

pub use placement::{world_to_subvoxel_pos, placement_pos_from_hit};
pub use raycast::{SubVoxelHit, subvoxel_raycast};

// Legacy mesher (36 байт вершины, ChunkGrid декомпрессия)
pub use mesh::{ChunkMeshData, ChunkMeshContext, mesh_chunk, mesh_chunk_new, SubVoxelVertex};

// Оптимизированный mesher (8 байт вершины, mask greedy)
pub use mesh_system::{
    // Компоненты
    DirtyChunk, ChunkMesh,
    // Ресурсы
    MeshingConfig, MeshingSystemContext,
    // Системы
    mark_chunk_dirty, update_priorities, process_meshing_queue,
    get_chunk_mesh, get_all_meshes, remove_chunk_mesh, clear_all_meshes,
    // Статистика
    MeshingStats, get_meshing_stats,
};


============================================================
FILE: subvoxel\systems\placement.rs
============================================================

// ============================================
// Placement System - Размещение субвокселей
// ============================================

use super::super::components::{SubVoxelPos, SubVoxelLevel};
use super::raycast::SubVoxelHit;

/// Вычислить позицию субвокселя из мировых координат
pub fn world_to_subvoxel_pos(
    world_x: f32, world_y: f32, world_z: f32,
    level: SubVoxelLevel,
) -> SubVoxelPos {
    let size = level.size();
    
    // Базовый блок
    let block_x = world_x.floor() as i32;
    let block_y = world_y.floor() as i32;
    let block_z = world_z.floor() as i32;
    
    // Позиция внутри блока
    let local_x = world_x - block_x as f32;
    let local_y = world_y - block_y as f32;
    let local_z = world_z - block_z as f32;
    
    // Индекс субвокселя
    let divisions = level.divisions();
    let sub_x = ((local_x / size).floor() as u8).min(divisions - 1);
    let sub_y = ((local_y / size).floor() as u8).min(divisions - 1);
    let sub_z = ((local_z / size).floor() as u8).min(divisions - 1);
    
    SubVoxelPos::new(block_x, block_y, block_z, sub_x, sub_y, sub_z, level)
}

/// Вычислить позицию для размещения субвокселя рядом с hit
pub fn placement_pos_from_hit(hit: &SubVoxelHit, level: SubVoxelLevel) -> SubVoxelPos {
    let size = level.size();
    // Смещаем точку попадания немного в направлении нормали
    let place_x = hit.hit_point[0] + hit.hit_normal[0] * (size * 0.5);
    let place_y = hit.hit_point[1] + hit.hit_normal[1] * (size * 0.5);
    let place_z = hit.hit_point[2] + hit.hit_normal[2] * (size * 0.5);
    
    world_to_subvoxel_pos(place_x, place_y, place_z, level)
}


============================================================
FILE: subvoxel\systems\raycast.rs
============================================================

// ============================================
// Raycast System - Рейкаст по субвокселям (ОПТИМИЗИРОВАННЫЙ)
// ============================================

use crate::gpu::blocks::BlockType;
use super::super::components::{SubVoxelPos, SubVoxelLevel, SubVoxelWorld};
use super::super::chunk::{SubVoxelChunkKey, SparseChunkStorage};

/// Результат raycast по субвокселям
#[derive(Clone, Copy, Debug)]
pub struct SubVoxelHit {
    pub pos: SubVoxelPos,
    pub block_type: BlockType,
    pub hit_point: [f32; 3],
    pub hit_normal: [f32; 3],
    pub distance: f32,
}

/// Raycast через субвоксели мира
pub fn subvoxel_raycast(
    world: &SubVoxelWorld,
    origin: [f32; 3],
    direction: [f32; 3],
    max_distance: f32,
    level: SubVoxelLevel,
) -> Option<SubVoxelHit> {
    let mut closest_hit: Option<SubVoxelHit> = None;

    let end = [
        origin[0] + direction[0] * max_distance,
        origin[1] + direction[1] * max_distance,
        origin[2] + direction[2] * max_distance,
    ];

    let min_chunk_x = (origin[0].min(end[0]).floor() as i32).div_euclid(16);
    let max_chunk_x = (origin[0].max(end[0]).ceil() as i32).div_euclid(16);
    let min_chunk_z = (origin[2].min(end[2]).floor() as i32).div_euclid(16);
    let max_chunk_z = (origin[2].max(end[2]).ceil() as i32).div_euclid(16);

    for cx in min_chunk_x..=max_chunk_x {
        for cz in min_chunk_z..=max_chunk_z {
            let key = SubVoxelChunkKey::new(cx, cz);
            if let Some(chunk) = world.get_chunk(&key) {
                if let Some(hit) = raycast_chunk(chunk, cx, cz, origin, direction, max_distance, level) {
                    if closest_hit.is_none() || hit.distance < closest_hit.as_ref().unwrap().distance {
                        closest_hit = Some(hit);
                    }
                }
            }
        }
    }

    closest_hit
}

/// Raycast через один чанк (использует SparseChunkStorage)
fn raycast_chunk(
    chunk: &SparseChunkStorage,
    chunk_x: i32, chunk_z: i32,
    origin: [f32; 3],
    direction: [f32; 3],
    max_distance: f32,
    level: SubVoxelLevel,
) -> Option<SubVoxelHit> {
    let mut closest_hit: Option<SubVoxelHit> = None;
    let base_x = chunk_x * 16;
    let base_z = chunk_z * 16;
    let divisions = level.divisions();

    for (block_key, octree) in chunk.iter_blocks() {
        let (bx, by, bz) = block_key.unpack();
        let block_world_x = base_x + bx as i32;
        let block_world_y = by as i32;
        let block_world_z = base_z + bz as i32;

        // Быстрая проверка AABB блока
        let block_min = [block_world_x as f32, block_world_y as f32, block_world_z as f32];
        let block_max = [block_min[0] + 1.0, block_min[1] + 1.0, block_min[2] + 1.0];
        
        if ray_aabb_intersection(origin, direction, block_min, block_max).is_none() {
            continue;
        }

        // Детальная проверка субвокселей
        for (sx, sy, sz, size, block_type) in octree.iter_solid() {
            let min_x = block_world_x as f32 + sx;
            let min_y = block_world_y as f32 + sy;
            let min_z = block_world_z as f32 + sz;
            let max_x = min_x + size;
            let max_y = min_y + size;
            let max_z = min_z + size;

            if let Some((t, normal)) = ray_aabb_intersection(
                origin, direction,
                [min_x, min_y, min_z],
                [max_x, max_y, max_z],
            ) {
                if t > 0.0 && t < max_distance {
                    if closest_hit.is_none() || t < closest_hit.as_ref().unwrap().distance {
                        let sub_x = ((sx / size) as u8).min(divisions - 1);
                        let sub_y = ((sy / size) as u8).min(divisions - 1);
                        let sub_z = ((sz / size) as u8).min(divisions - 1);

                        closest_hit = Some(SubVoxelHit {
                            pos: SubVoxelPos::new(
                                block_world_x, block_world_y, block_world_z,
                                sub_x, sub_y, sub_z,
                                level,
                            ),
                            block_type,
                            hit_point: [
                                origin[0] + direction[0] * t,
                                origin[1] + direction[1] * t,
                                origin[2] + direction[2] * t,
                            ],
                            hit_normal: normal,
                            distance: t,
                        });
                    }
                }
            }
        }
    }

    closest_hit
}

/// Ray-AABB intersection
fn ray_aabb_intersection(
    origin: [f32; 3],
    direction: [f32; 3],
    aabb_min: [f32; 3],
    aabb_max: [f32; 3],
) -> Option<(f32, [f32; 3])> {
    let mut t_min = f32::NEG_INFINITY;
    let mut t_max = f32::INFINITY;
    let mut normal = [0.0f32; 3];

    for i in 0..3 {
        if direction[i].abs() < 1e-8 {
            if origin[i] < aabb_min[i] || origin[i] > aabb_max[i] {
                return None;
            }
        } else {
            let inv_d = 1.0 / direction[i];
            let mut t1 = (aabb_min[i] - origin[i]) * inv_d;
            let mut t2 = (aabb_max[i] - origin[i]) * inv_d;

            let mut n = [0.0f32; 3];
            n[i] = -1.0;

            if t1 > t2 {
                std::mem::swap(&mut t1, &mut t2);
                n[i] = 1.0;
            }

            if t1 > t_min {
                t_min = t1;
                normal = n;
            }
            t_max = t_max.min(t2);

            if t_min > t_max {
                return None;
            }
        }
    }

    Some((t_min, normal))
}


============================================================
FILE: systems\block_interaction_system.rs
============================================================

// ============================================
// Block Interaction System - Ломание и установка блоков
// ============================================

use crate::gpu::core::GameResources;
use crate::gpu::blocks::MouseButton;
use crate::gpu::terrain::BlockPos;
use crate::gpu::subvoxel::{SubVoxelLevel, SubVoxelHit, world_to_subvoxel, subvoxel_intersects_player, placement_pos_from_hit};
use crate::gpu::player::{PLAYER_HEIGHT, PLAYER_RADIUS};
use crate::gpu::blocks::BlockType;

/// Система взаимодействия с блоками
pub struct BlockInteractionSystem;

impl BlockInteractionSystem {
    /// Обработка левой кнопки мыши (ломание)
    pub fn handle_break(resources: &mut GameResources) {
        let eye_pos = resources.player.eye_position();
        let forward = resources.player.forward();
        let origin = [eye_pos.x, eye_pos.y, eye_pos.z];
        let direction = [forward.x, forward.y, forward.z];
        
        // Ищем ближайший суб-воксель
        let mut closest_subvoxel: Option<(SubVoxelHit, f32)> = None;
        {
            let subvoxels = resources.subvoxel_storage.read().unwrap();
            for level in [SubVoxelLevel::Quarter, SubVoxelLevel::Half] {
                if let Some(hit) = subvoxels.raycast(origin, direction, 5.0, level) {
                    if closest_subvoxel.is_none() || hit.distance < closest_subvoxel.as_ref().unwrap().1 {
                        closest_subvoxel = Some((hit, hit.distance));
                    }
                }
            }
        }
        
        // Проверяем обычный блок
        let block_dist = resources.block_breaker.target_block()
            .map(|b| b.distance)
            .unwrap_or(f32::MAX);
        
        if let Some((hit, dist)) = closest_subvoxel {
            if dist < block_dist {
                // Ломаем суб-воксель
                let mut subvoxels = resources.subvoxel_storage.write().unwrap();
                subvoxels.remove(&hit.pos);
                return;
            }
        }
        
        // Ломаем обычный блок
        if let Some(broken) = resources.block_breaker.process_mouse_button(MouseButton::Left, true) {
            if let Some(renderer) = &mut resources.renderer {
                let changes = resources.world_changes.read().unwrap();
                renderer.instant_chunk_update(
                    broken.block_pos[0],
                    broken.block_pos[1],
                    broken.block_pos[2],
                    &changes,
                );
            }
        }
    }
    
    /// Обработка правой кнопки мыши (установка)
    pub fn handle_place(resources: &mut GameResources) {
        // Получаем тип блока из хотбара
        let block_type = if let Some(gui) = &mut resources.gui_renderer {
            gui.hotbar().selected_block_type()
        } else {
            None
        };
        
        let Some(block_type) = block_type else { return };
        
        if resources.current_subvoxel_level == SubVoxelLevel::Full {
            Self::place_full_block(resources, block_type);
        } else {
            Self::place_subvoxel(resources, block_type);
        }
    }
    
    /// Установка полного блока
    fn place_full_block(resources: &mut GameResources, block_type: BlockType) {
        if let Some(place_pos) = resources.block_breaker.placement_pos() {
            if !Self::block_intersects_player(resources, place_pos) {
                // Ставим блок
                let mut changes = resources.world_changes.write().unwrap();
                changes.set_block(
                    BlockPos::new(place_pos[0], place_pos[1], place_pos[2]),
                    block_type,
                );
                drop(changes);
                
                if let Some(renderer) = &mut resources.renderer {
                    let changes = resources.world_changes.read().unwrap();
                    renderer.instant_chunk_update(
                        place_pos[0],
                        place_pos[1],
                        place_pos[2],
                        &changes,
                    );
                }
                
                // Звук установки блока
                if let Some(audio) = &mut resources.audio_system {
                    audio.play_place_block();
                }
            }
        }
    }
    
    /// Установка суб-вокселя
    fn place_subvoxel(resources: &mut GameResources, block_type: BlockType) {
        let eye_pos = resources.player.eye_position();
        let forward = resources.player.forward();
        let origin = [eye_pos.x, eye_pos.y, eye_pos.z];
        let direction = [forward.x, forward.y, forward.z];
        
        // Ищем ближайший суб-воксель любого уровня
        let mut closest_hit: Option<SubVoxelHit> = None;
        {
            let subvoxels = resources.subvoxel_storage.read().unwrap();
            for level in [SubVoxelLevel::Quarter, SubVoxelLevel::Half] {
                if let Some(hit) = subvoxels.raycast(origin, direction, 5.0, level) {
                    if closest_hit.is_none() || hit.distance < closest_hit.as_ref().unwrap().distance {
                        closest_hit = Some(hit);
                    }
                }
            }
        }
        
        // Также проверяем обычный блок
        let block_dist = resources.block_breaker.target_block()
            .map(|b| b.distance)
            .unwrap_or(f32::MAX);
        
        let subvoxel_pos = if let Some(hit) = closest_hit {
            if hit.distance < block_dist {
                // Ставим рядом с существующим суб-вокселем
                Some(placement_pos_from_hit(&hit, resources.current_subvoxel_level))
            } else if let Some(hit_pos) = resources.block_breaker.placement_world_pos() {
                // Ставим на обычный блок (он ближе)
                Some(world_to_subvoxel(
                    hit_pos[0], hit_pos[1], hit_pos[2],
                    resources.current_subvoxel_level
                ))
            } else {
                None
            }
        } else if let Some(hit_pos) = resources.block_breaker.placement_world_pos() {
            // Нет суб-вокселей, ставим на обычный блок
            Some(world_to_subvoxel(
                hit_pos[0], hit_pos[1], hit_pos[2],
                resources.current_subvoxel_level
            ))
        } else {
            None
        };
        
        if let Some(subvoxel_pos) = subvoxel_pos {
            let mut subvoxels = resources.subvoxel_storage.write().unwrap();
            // Проверяем что позиция не занята
            if subvoxels.get(&subvoxel_pos).is_none() {
                // Проверяем коллизию с игроком
                if !subvoxel_intersects_player(
                    &subvoxel_pos,
                    resources.player.position.x,
                    resources.player.position.y,
                    resources.player.position.z,
                    PLAYER_RADIUS,
                    PLAYER_HEIGHT
                ) {
                    subvoxels.set(subvoxel_pos, block_type);
                    drop(subvoxels);
                    
                    // Звук установки блока
                    if let Some(audio) = &mut resources.audio_system {
                        audio.play_place_block();
                    }
                }
            }
        }
    }
    
    /// Обработка средней кнопки мыши (pick block)
    pub fn handle_pick_block(resources: &mut GameResources) {
        if let Some(target) = resources.block_breaker.target_block() {
            let block_type = target.block_type;
            if let Some(gui) = &mut resources.gui_renderer {
                gui.hotbar().pick_block(block_type);
            }
        }
    }
    
    /// Проверяет, пересекается ли блок с хитбоксом игрока
    fn block_intersects_player(resources: &GameResources, block_pos: [i32; 3]) -> bool {
        let player_pos = resources.player.position;
        
        // Границы хитбокса игрока (AABB)
        let player_min_x = player_pos.x - PLAYER_RADIUS;
        let player_max_x = player_pos.x + PLAYER_RADIUS;
        let player_min_y = player_pos.y;
        let player_max_y = player_pos.y + PLAYER_HEIGHT;
        let player_min_z = player_pos.z - PLAYER_RADIUS;
        let player_max_z = player_pos.z + PLAYER_RADIUS;
        
        // Границы блока
        let block_min_x = block_pos[0] as f32;
        let block_max_x = block_pos[0] as f32 + 1.0;
        let block_min_y = block_pos[1] as f32;
        let block_max_y = block_pos[1] as f32 + 1.0;
        let block_min_z = block_pos[2] as f32;
        let block_max_z = block_pos[2] as f32 + 1.0;
        
        // Проверка пересечения AABB
        player_max_x > block_min_x && player_min_x < block_max_x &&
        player_max_y > block_min_y && player_min_y < block_max_y &&
        player_max_z > block_min_z && player_min_z < block_max_z
    }
}


============================================================
FILE: systems\init_system.rs
============================================================

// ============================================
// Init System - Инициализация игры
// ============================================

use std::sync::{Arc, RwLock};
use std::time::Instant;
use winit::window::Window;

use crate::gpu::core::GameResources;
use crate::gpu::player::Camera;
use crate::gpu::player::{Player, PlayerController};
use crate::gpu::render::Renderer;
use crate::gpu::blocks::BlockBreaker;
use crate::gpu::terrain::WorldChanges;
use crate::gpu::gui::{GameMenu, GuiRenderer};
use crate::gpu::subvoxel::{SubVoxelStorage, SubVoxelLevel};
use crate::gpu::subvoxel::SubVoxelRenderer;
use crate::gpu::audio::AudioSystem;
use crate::gpu::terrain::{get_height, CaveParams, is_cave};
use crate::gpu::blocks::AIR;
use crate::gpu::systems::save_system::SaveSystem;

/// Система инициализации
pub struct InitSystem;

impl InitSystem {
    /// Создать начальные ресурсы игры
    pub fn create_resources() -> GameResources {
        let loaded = SaveSystem::load_or_create();
        
        let mut player = Player::new(loaded.start_x, loaded.start_y, loaded.start_z);
        player.move_speed = 8.0;
        player.sprint_speed = 320.0; // x40 от базовой скорости
        
        let mut player_controller = PlayerController::new(0.5);
        
        // Устанавливаем функцию проверки твёрдости блока
        player_controller.set_block_solid_checker(|bx, by, bz, world_changes: &std::collections::HashMap<crate::gpu::terrain::BlockPos, crate::gpu::blocks::BlockType>| {
            use crate::gpu::terrain::BlockPos;
            
            let pos = BlockPos::new(bx, by, bz);
            
            // Сначала проверяем изменения мира
            if let Some(&block_type) = world_changes.get(&pos) {
                return block_type != AIR;
            }
            
            // Если нет изменений - используем процедурную генерацию
            let base_height = get_height(bx as f32, bz as f32) as i32;
            
            // Выше поверхности - воздух
            if by > base_height {
                return false;
            }
            
            // Проверяем пещеры
            let cave_params = CaveParams::default();
            let cave_ceiling = base_height - cave_params.surface_offset;
            
            if by >= cave_params.min_height && by < cave_ceiling {
                if is_cave(bx, by, bz, &cave_params) {
                    return false;
                }
            }
            
            true
        });
        
        // Создаём хранилище изменений мира
        let world_changes = Arc::new(RwLock::new(WorldChanges::new()));
        SaveSystem::apply_loaded_changes(&world_changes, loaded.changes);
        
        // Создаём хранилище суб-вокселей
        let mut subvoxel_storage_inner = SubVoxelStorage::new();
        SaveSystem::apply_loaded_subvoxels(&mut subvoxel_storage_inner, loaded.subvoxels);
        let subvoxel_storage = Arc::new(RwLock::new(subvoxel_storage_inner));
        
        // Устанавливаем checker для коллизий с суб-вокселями
        let subvoxel_storage_clone = Arc::clone(&subvoxel_storage);
        player_controller.set_subvoxel_collision_checker(move |min_x, min_y, min_z, max_x, max_y, max_z| {
            let storage = subvoxel_storage_clone.read().unwrap();
            storage.check_aabb_collision(min_x, min_y, min_z, max_x, max_y, max_z)
        });
        
        GameResources {
            window: None,
            renderer: None,
            gui_renderer: None,
            subvoxel_renderer: None,
            player,
            player_controller,
            camera: Camera::new(16.0 / 9.0),
            block_breaker: BlockBreaker::new(Arc::clone(&world_changes)),
            world_changes,
            subvoxel_storage,
            current_subvoxel_level: SubVoxelLevel::Full,
            menu: GameMenu::new(1280, 720),
            audio_system: None,
            start_time: Instant::now(),
            last_frame: Instant::now(),
            cursor_grabbed: false,
            mouse_pos: (0.0, 0.0),
            menu_mouse_pressed: false,
            world_seed: loaded.world_seed,
        }
    }
    
    /// Инициализация рендеринга (вызывается при resumed)
    pub fn init_rendering(resources: &mut GameResources, window: Arc<Window>) {
        let renderer = pollster::block_on(Renderer::new(window.clone()));
        
        // GUI рендерер
        let gui_renderer = GuiRenderer::new(
            renderer.device(),
            renderer.queue(),
            renderer.surface_format(),
            renderer.uniform_bind_group_layout(),
            renderer.size().width,
            renderer.size().height,
        );
        
        // Рендерер суб-вокселей
        let subvoxel_renderer = SubVoxelRenderer::new(renderer.device());
        
        // Аудио система
        Self::init_audio(resources);
        
        resources.camera.resize(renderer.size().width, renderer.size().height);
        resources.menu.resize(renderer.size().width, renderer.size().height);
        resources.window = Some(window);
        resources.renderer = Some(renderer);
        resources.gui_renderer = Some(gui_renderer);
        resources.subvoxel_renderer = Some(subvoxel_renderer);
    }
    
    /// Инициализация аудио системы
    fn init_audio(resources: &mut GameResources) {
        match AudioSystem::new() {
            Ok(mut audio) => {
                if let Err(e) = audio.load_sounds() {
                    eprintln!("[AUDIO] Не удалось загрузить звуки: {}", e);
                }
                
                // Устанавливаем функцию проверки блоков для рейтрейсинга звука
                let world_changes_clone = Arc::clone(&resources.world_changes);
                audio.set_block_checker(move |bx, by, bz| {
                    // Проверяем изменения мира
                    if let Ok(changes) = world_changes_clone.try_read() {
                        if let Some(block_type) = changes.get_block(bx, by, bz) {
                            return block_type != AIR;
                        }
                    }
                    
                    // Процедурная генерация
                    let base_height = get_height(bx as f32, bz as f32) as i32;
                    if by > base_height {
                        return false;
                    }
                    
                    // Проверяем пещеры
                    let cave_params = CaveParams::default();
                    let cave_ceiling = base_height - cave_params.surface_offset;
                    if by >= cave_params.min_height && by < cave_ceiling {
                        if is_cave(bx, by, bz, &cave_params) {
                            return false;
                        }
                    }
                    
                    true
                });
                
                resources.audio_system = Some(audio);
            }
            Err(e) => {
                eprintln!("[AUDIO] Не удалось инициализировать аудио: {}", e);
            }
        }
    }
}


============================================================
FILE: systems\input_system.rs
============================================================

// ============================================
// Input System - Обработка ввода
// ============================================

use std::sync::Arc;
use winit::{
    event::{ElementState, KeyEvent, DeviceEvent},
    keyboard::{KeyCode, PhysicalKey},
    window::{CursorGrabMode, Window},
};

use crate::gpu::core::GameResources;
use crate::gpu::gui::MenuAction;

/// Система обработки клавиатуры
pub struct InputSystem;

impl InputSystem {
    /// Обработка клавиатурного ввода
    pub fn process_keyboard(
        resources: &mut GameResources,
        keycode: KeyCode,
        state: ElementState,
    ) -> Option<InputAction> {
        let pressed = state == ElementState::Pressed;
        
        match keycode {
            // Escape - открыть/закрыть меню
            KeyCode::Escape if pressed => {
                // Если открыт инвентарь - закрываем его
                if let Some(gui) = &mut resources.gui_renderer {
                    if gui.inventory().is_visible() {
                        gui.inventory().hide();
                        Self::grab_cursor(resources, true);
                        return Some(InputAction::InventoryToggle);
                    }
                }
                
                resources.menu.toggle();
                if let Some(gui) = &mut resources.gui_renderer {
                    gui.menu_system().toggle();
                }
                
                if resources.menu.is_visible() {
                    Self::grab_cursor(resources, false);
                } else {
                    Self::grab_cursor(resources, true);
                }
                Some(InputAction::MenuToggle)
            }
            
            // E - открыть/закрыть инвентарь
            KeyCode::KeyE if pressed => {
                if !resources.menu.is_visible() {
                    if let Some(gui) = &mut resources.gui_renderer {
                        gui.inventory().toggle();
                        
                        if gui.inventory().is_visible() {
                            Self::grab_cursor(resources, false);
                        } else {
                            Self::grab_cursor(resources, true);
                        }
                        return Some(InputAction::InventoryToggle);
                    }
                }
                None
            }
            
            // Q - переключить размер суб-вокселя
            KeyCode::KeyQ if pressed => {
                resources.current_subvoxel_level = resources.current_subvoxel_level.next();
                println!("[SUBVOXEL] Размер блока: {}", resources.current_subvoxel_level.name());
                Some(InputAction::SubvoxelLevelChange)
            }
            
            // F5 - переключить режим камеры
            KeyCode::F5 if pressed => {
                resources.camera.toggle_mode();
                Some(InputAction::CameraToggle)
            }
            
            // F6 - сохранить мир
            KeyCode::F6 if pressed => {
                Some(InputAction::SaveWorld)
            }
            
            // +/- для дистанции камеры
            KeyCode::Equal | KeyCode::NumpadAdd if pressed => {
                resources.camera.third_person_distance = 
                    (resources.camera.third_person_distance + 1.0).min(20.0);
                None
            }
            KeyCode::Minus | KeyCode::NumpadSubtract if pressed => {
                resources.camera.third_person_distance = 
                    (resources.camera.third_person_distance - 1.0).max(2.0);
                None
            }
            
            // T - переключить время
            KeyCode::KeyT if pressed => {
                Some(InputAction::CycleTime)
            }
            
            // [ и ] - скорость времени
            KeyCode::BracketLeft if pressed => {
                Some(InputAction::SlowTime)
            }
            KeyCode::BracketRight if pressed => {
                Some(InputAction::FastTime)
            }
            
            // Клавиши 1-9 для хотбара
            _ => {
                if !resources.menu.is_visible() {
                    let slot_key = match keycode {
                        KeyCode::Digit1 => Some(1),
                        KeyCode::Digit2 => Some(2),
                        KeyCode::Digit3 => Some(3),
                        KeyCode::Digit4 => Some(4),
                        KeyCode::Digit5 => Some(5),
                        KeyCode::Digit6 => Some(6),
                        KeyCode::Digit7 => Some(7),
                        KeyCode::Digit8 => Some(8),
                        KeyCode::Digit9 => Some(9),
                        _ => None,
                    };
                    
                    if let Some(key) = slot_key {
                        if pressed {
                            if let Some(gui) = &mut resources.gui_renderer {
                                gui.hotbar().select_by_key(key);
                            }
                        }
                    } else {
                        resources.player_controller.process_keyboard(keycode, pressed);
                    }
                }
                None
            }
        }
    }
    
    /// Обработка движения мыши
    pub fn process_mouse_motion(resources: &mut GameResources, delta: (f64, f64)) {
        if resources.cursor_grabbed && !resources.menu.is_visible() {
            resources.player_controller.process_mouse(delta.0, delta.1);
        }
    }
    
    /// Обработка колеса мыши
    pub fn process_mouse_wheel(resources: &mut GameResources, delta: winit::event::MouseScrollDelta) {
        let scroll = match delta {
            winit::event::MouseScrollDelta::LineDelta(_, y) => y as i32,
            winit::event::MouseScrollDelta::PixelDelta(pos) => (pos.y / 100.0) as i32,
        };
        
        if scroll != 0 {
            // Если открыт инвентарь - скроллим его
            // scroll > 0 когда крутим вверх, < 0 когда вниз
            if let Some(gui) = &mut resources.gui_renderer {
                if gui.inventory().is_visible() {
                    gui.inventory().scroll_by(scroll as f32 * 0.5);
                    return;
                }
            }
            
            // Иначе скроллим хотбар
            if resources.cursor_grabbed && !resources.menu.is_visible() {
                if let Some(gui) = &mut resources.gui_renderer {
                    gui.hotbar().scroll(-scroll);
                }
            }
        }
    }
    
    /// Захват/освобождение курсора
    pub fn grab_cursor(resources: &mut GameResources, grab: bool) {
        if let Some(window) = &resources.window {
            resources.cursor_grabbed = grab;
            if grab {
                let _ = window.set_cursor_grab(CursorGrabMode::Confined)
                    .or_else(|_| window.set_cursor_grab(CursorGrabMode::Locked));
                window.set_cursor_visible(false);
            } else {
                let _ = window.set_cursor_grab(CursorGrabMode::None);
                window.set_cursor_visible(true);
            }
        }
    }
}

/// Действия, которые могут быть вызваны вводом
#[derive(Debug, Clone, Copy)]
pub enum InputAction {
    MenuToggle,
    InventoryToggle,
    SubvoxelLevelChange,
    CameraToggle,
    SaveWorld,
    CycleTime,
    SlowTime,
    FastTime,
}


============================================================
FILE: systems\menu_system.rs
============================================================

// ============================================
// Menu System - Обработка игрового меню
// ============================================

use winit::event_loop::ActiveEventLoop;

use crate::gpu::core::GameResources;
use crate::gpu::gui::MenuAction;
use crate::gpu::systems::input_system::InputSystem;
use crate::gpu::systems::save_system::SaveSystem;

/// Система обработки меню
pub struct MenuSystem;

impl MenuSystem {
    /// Обработка нажатия кнопки мыши (начало drag)
    pub fn handle_mouse_down(
        resources: &mut GameResources,
    ) {
        if let Some(gui) = &mut resources.gui_renderer {
            if gui.inventory_ref().is_visible() {
                let mx = resources.mouse_pos.0;
                let my = resources.mouse_pos.1;
                
                // Проверяем клик по слоту инвентаря
                let slot_at = gui.inventory_renderer().get_slot_at(mx, my, gui.inventory_ref());
                
                if let Some(slot_index) = slot_at {
                    // Начинаем перетаскивание
                    gui.inventory().handle_click(slot_index);
                }
            }
        }
    }
    
    /// Обработка отпускания кнопки мыши (drop)
    pub fn handle_mouse_up(
        resources: &mut GameResources,
    ) -> bool {
        let mut should_grab_cursor = false;
        
        if let Some(gui) = &mut resources.gui_renderer {
            if gui.inventory_ref().is_visible() {
                // Проверяем есть ли перетаскиваемый блок
                if let Some(block_type) = gui.inventory().dragging() {
                    let mx = resources.mouse_pos.0;
                    let my = resources.mouse_pos.1;
                    
                    // Проверяем drop на хотбар
                    let (screen_w, screen_h) = gui.screen_size();
                    
                    if gui.hotbar().handle_click(mx, my, screen_w, screen_h) {
                        // Кликнули на слот хотбара - добавляем туда блок
                        let selected_slot = gui.hotbar().selected();
                        gui.hotbar().set_item(selected_slot, Some(crate::gpu::gui::hotbar::HotbarItem::from_block(block_type)));
                    }
                    
                    // Завершаем перетаскивание
                    gui.inventory().end_drag();
                }
            }
        }
        
        should_grab_cursor
    }
    
    /// Обработка клика по меню или инвентарю (legacy - для совместимости)
    pub fn handle_click(
        resources: &mut GameResources,
        event_loop: &ActiveEventLoop,
    ) -> bool {
        // Сначала проверяем инвентарь
        let inventory_action = if let Some(gui) = &mut resources.gui_renderer {
            if gui.inventory_ref().is_visible() {
                let mx = resources.mouse_pos.0;
                let my = resources.mouse_pos.1;
                
                // Получаем данные для проверки
                let slot_at = gui.inventory_renderer().get_slot_at(mx, my, gui.inventory_ref());
                
                // Проверяем клик по слоту
                if let Some(slot_index) = slot_at {
                    let block_type = gui.inventory().handle_click(slot_index);
                    if let Some(bt) = block_type {
                        gui.hotbar().pick_block(bt);
                        Some(true) // Нужно grab cursor
                    } else {
                        Some(false)
                    }
                } else {
                    // Проверяем клик по скроллбару
                    let is_scrollbar = gui.inventory_renderer().is_scrollbar_click(mx, my);
                    if is_scrollbar {
                        let max_scroll = gui.inventory_ref().max_scroll();
                        let scroll = gui.inventory_renderer().get_scroll_from_mouse_raw(my, max_scroll);
                        gui.inventory().set_scroll(scroll);
                    }
                    Some(false)
                }
            } else {
                None
            }
        } else {
            None
        };
        
        if let Some(need_grab) = inventory_action {
            if need_grab {
                InputSystem::grab_cursor(resources, true);
            }
            return false;
        }
        
        let action = if let Some(gui) = &mut resources.gui_renderer {
            gui.menu_system().handle_click(resources.mouse_pos.0, resources.mouse_pos.1)
        } else {
            resources.menu.process_click(resources.mouse_pos.0, resources.mouse_pos.1)
        };
        
        match action {
            MenuAction::Resume => {
                resources.menu.hide();
                if let Some(gui) = &mut resources.gui_renderer {
                    gui.menu_system().hide();
                }
                InputSystem::grab_cursor(resources, true);
                false
            }
            MenuAction::SaveSettings => {
                Self::apply_lod_settings(resources);
                false
            }
            MenuAction::QuitToDesktop => {
                SaveSystem::save_world(resources);
                event_loop.exit();
                true
            }
            _ => false
        }
    }
    
    /// Обновление hover состояния меню и инвентаря
    pub fn update_hover(resources: &mut GameResources) {
        // Обновляем инвентарь
        if let Some(gui) = &mut resources.gui_renderer {
            if gui.inventory_ref().is_visible() {
                let mx = resources.mouse_pos.0;
                let my = resources.mouse_pos.1;
                
                let hovered = gui.inventory_renderer().get_slot_at(mx, my, gui.inventory_ref());
                gui.inventory().set_hovered(hovered);
                return;
            }
        }
        
        // Обновляем меню
        if resources.menu.is_visible() {
            if let Some(gui) = &mut resources.gui_renderer {
                gui.menu_system().handle_mouse_move(resources.mouse_pos.0, resources.mouse_pos.1);
                gui.menu_system().handle_drag(resources.mouse_pos.0, resources.mouse_pos.1, resources.menu_mouse_pressed);
            }
        }
    }
    
    /// Обработка скролла в инвентаре
    pub fn handle_inventory_scroll(resources: &mut GameResources, delta: f32) {
        if let Some(gui) = &mut resources.gui_renderer {
            if gui.inventory_ref().is_visible() {
                gui.inventory().scroll_by(delta);
            }
        }
    }
    
    /// Применение настроек LOD
    fn apply_lod_settings(resources: &mut GameResources) {
        let distances = if let Some(gui) = &mut resources.gui_renderer {
            let lod_values = gui.menu_system().get_lod_values();
            // Конвертируем 0-1 в дистанции чанков (4-64)
            Some([
                (lod_values[0] * 60.0 + 4.0) as i32,
                (lod_values[1] * 60.0 + 4.0) as i32,
                (lod_values[2] * 60.0 + 4.0) as i32,
                (lod_values[3] * 60.0 + 4.0) as i32,
            ])
        } else {
            None
        };
        
        if let (Some(distances), Some(renderer)) = (distances, &mut resources.renderer) {
            renderer.set_lod_distances(distances);
            println!("[LOD] Applied distances: {:?}", distances);
        }
    }
}


============================================================
FILE: systems\mod.rs
============================================================

// ============================================
// Systems Module - ECS-подобные системы
// ============================================

mod input_system;
mod block_interaction_system;
mod menu_system;
mod save_system;
mod update_system;
mod render_system;
mod init_system;

pub use input_system::{InputSystem, InputAction};
pub use block_interaction_system::BlockInteractionSystem;
pub use menu_system::MenuSystem;
pub use save_system::SaveSystem;
pub use update_system::UpdateSystem;
pub use render_system::RenderSystem;
pub use init_system::InitSystem;


============================================================
FILE: systems\render_system.rs
============================================================

// ============================================
// Render System - Система рендеринга
// ============================================

use winit::event_loop::ActiveEventLoop;

use crate::gpu::core::GameResources;
use crate::gpu::subvoxel::SubVoxelLevel;
use crate::gpu::systems::menu_system::MenuSystem;

/// Система рендеринга
pub struct RenderSystem;

impl RenderSystem {
    /// Основной рендер-пасс
    pub fn render(resources: &mut GameResources, time: f32, dt: f32, event_loop: &ActiveEventLoop) {
        let Some(renderer) = &mut resources.renderer else { return };
        
        // Обновляем рендерер
        {
            let changes = resources.world_changes.read().unwrap();
            renderer.update(&resources.camera, &resources.player, time, dt, &changes);
        }
        
        // Обновляем суб-воксели
        if let Some(sv_renderer) = &mut resources.subvoxel_renderer {
            let subvoxels = resources.subvoxel_storage.read().unwrap();
            sv_renderer.update(renderer.device(), renderer.queue(), &subvoxels);
        }
        
        // Raycast для выделения
        let (highlight_block, should_highlight) = Self::calculate_highlight(resources);
        
        // Обновляем hover меню
        MenuSystem::update_hover(resources);
        
        // Рендерим
        let render_player = resources.camera.should_render_player();
        let sv_renderer = resources.subvoxel_renderer.as_ref();
        let highlight_for_render = if should_highlight { Some([0, 0, 0]) } else { None };
        let mouse_pos = resources.mouse_pos;
        
        let result = if resources.gui_renderer.is_some() {
            let gui = resources.gui_renderer.as_mut().unwrap();
            let renderer = resources.renderer.as_mut().unwrap();
            renderer.render_with_subvoxels(render_player, highlight_for_render, sv_renderer, |device, encoder, view, queue| {
                gui.render(device, encoder, view, queue, mouse_pos);
            })
        } else {
            let renderer = resources.renderer.as_mut().unwrap();
            renderer.render(render_player, highlight_block)
        };
        
        match result {
            Ok(_) => {}
            Err(wgpu::SurfaceError::Lost) => {
                let renderer = resources.renderer.as_mut().unwrap();
                renderer.resize(renderer.size());
            }
            Err(wgpu::SurfaceError::OutOfMemory) => {
                event_loop.exit();
            }
            Err(e) => eprintln!("Render error: {:?}", e),
        }
    }
    
    /// Вычисление подсветки блока/суб-вокселя
    fn calculate_highlight(resources: &mut GameResources) -> (Option<[i32; 3]>, bool) {
        let eye_pos = resources.player.eye_position();
        let forward = resources.player.forward();
        let origin = [eye_pos.x, eye_pos.y, eye_pos.z];
        let direction = [forward.x, forward.y, forward.z];
        
        // Ищем ближайший суб-воксель
        let mut closest_subvoxel: Option<crate::gpu::subvoxel::SubVoxelHit> = None;
        {
            let subvoxels = resources.subvoxel_storage.read().unwrap();
            for level in [SubVoxelLevel::Quarter, SubVoxelLevel::Half] {
                if let Some(hit) = subvoxels.raycast(origin, direction, 5.0, level) {
                    if closest_subvoxel.is_none() || hit.distance < closest_subvoxel.as_ref().unwrap().distance {
                        closest_subvoxel = Some(hit);
                    }
                }
            }
        }
        
        // Получаем позицию обычного блока
        let block_hit = resources.block_breaker.target_block();
        let block_dist = block_hit.map(|b| b.distance).unwrap_or(f32::MAX);
        
        // Выбираем что выделять
        let highlight_block = if let Some(sv_hit) = &closest_subvoxel {
            if sv_hit.distance < block_dist {
                // Выделяем суб-воксель
                let [x, y, z] = sv_hit.pos.world_min();
                let size = sv_hit.pos.level.size();
                if let Some(renderer) = &mut resources.renderer {
                    renderer.update_block_highlight_sized([x, y, z], size);
                }
                None
            } else {
                resources.block_breaker.highlight_block_pos()
            }
        } else {
            resources.block_breaker.highlight_block_pos()
        };
        
        if let Some(pos) = highlight_block {
            if let Some(renderer) = &mut resources.renderer {
                renderer.update_block_highlight(Some(pos));
            }
        }
        
        let should_highlight = highlight_block.is_some() 
            || closest_subvoxel.as_ref().map(|sv| sv.distance < block_dist).unwrap_or(false);
        
        (highlight_block, should_highlight)
    }
}


============================================================
FILE: systems\save_system.rs
============================================================

// ============================================
// Save System - Сохранение и загрузка мира
// ============================================

use std::collections::HashMap;
use std::sync::{Arc, RwLock};

use crate::gpu::core::{GameResources, SAVE_FILE, DEFAULT_SEED};
use crate::gpu::save::WorldFile;
use crate::gpu::terrain::{WorldChanges, BlockPos};
use crate::gpu::blocks::BlockType;
use crate::gpu::subvoxel::{SubVoxelStorage, SubVoxel};
use crate::gpu::terrain::get_height;

/// Система сохранения/загрузки
pub struct SaveSystem;

/// Данные загруженного мира
pub struct LoadedWorld {
    pub start_x: f32,
    pub start_y: f32,
    pub start_z: f32,
    pub world_seed: u64,
    pub changes: HashMap<BlockPos, BlockType>,
    pub subvoxels: Vec<SubVoxel>,
}

impl SaveSystem {
    /// Загрузить мир из файла или создать новый
    pub fn load_or_create() -> LoadedWorld {
        if let Ok(loaded) = WorldFile::load(SAVE_FILE) {
            println!("[SAVE] Загружен мир из {}", SAVE_FILE);
            println!("[SAVE] Seed: {}, Позиция: {:?}, Изменений: {}, Суб-вокселей: {}", 
                loaded.seed, loaded.player_pos, loaded.changes.len(), loaded.subvoxels.len());
            
            LoadedWorld {
                start_x: loaded.player_pos[0],
                start_y: loaded.player_pos[1],
                start_z: loaded.player_pos[2],
                world_seed: loaded.seed,
                changes: loaded.changes,
                subvoxels: loaded.subvoxels,
            }
        } else {
            // Новый мир
            let start_x = 0.0;
            let start_z = 0.0;
            let start_y = get_height(start_x, start_z) + 2.0;
            println!("[SAVE] Новый мир (seed: {})", DEFAULT_SEED);
            
            LoadedWorld {
                start_x,
                start_y,
                start_z,
                world_seed: DEFAULT_SEED,
                changes: HashMap::new(),
                subvoxels: Vec::new(),
            }
        }
    }
    
    /// Сохранить мир в файл
    pub fn save_world(resources: &GameResources) {
        let player_pos = [
            resources.player.position.x,
            resources.player.position.y,
            resources.player.position.z,
        ];
        
        let changes = resources.world_changes.read().unwrap();
        let subvoxels = resources.subvoxel_storage.read().unwrap();
        
        match WorldFile::save(SAVE_FILE, resources.world_seed, player_pos, &changes, &subvoxels) {
            Ok(_) => {
                println!("[SAVE] Мир сохранён в {} ({} изменений, {} суб-вокселей)", 
                    SAVE_FILE, changes.change_count(), subvoxels.count());
            }
            Err(e) => {
                eprintln!("[SAVE] Ошибка сохранения: {:?}", e);
            }
        }
    }
    
    /// Применить загруженные изменения к миру
    pub fn apply_loaded_changes(
        world_changes: &Arc<RwLock<WorldChanges>>,
        loaded_changes: HashMap<BlockPos, BlockType>,
    ) {
        if !loaded_changes.is_empty() {
            let mut changes = world_changes.write().unwrap();
            for (pos, block) in loaded_changes {
                changes.set_block(pos, block);
            }
        }
    }
    
    /// Применить загруженные суб-воксели
    pub fn apply_loaded_subvoxels(
        subvoxel_storage: &mut SubVoxelStorage,
        loaded_subvoxels: Vec<SubVoxel>,
    ) {
        if !loaded_subvoxels.is_empty() {
            subvoxel_storage.load(loaded_subvoxels);
        }
    }
}


============================================================
FILE: systems\update_system.rs
============================================================

// ============================================
// Update System - Обновление игровой логики
// ============================================

use crate::gpu::core::GameResources;

/// Система обновления игровой логики
pub struct UpdateSystem;

impl UpdateSystem {
    /// Основной цикл обновления
    pub fn update(resources: &mut GameResources, dt: f32, _time: f32) {
        // 1. Обновляем игрока (физика, движение)
        Self::update_player(resources, dt);
        
        // 2. Обновляем камеру
        resources.camera.update_from_player(&resources.player);
        
        // 3. Обновляем аудио
        Self::update_audio(resources, dt);
        
        // 4. Обновляем систему ломания блоков
        resources.block_breaker.update(&resources.player, dt);
    }
    
    /// Обновление игрока
    fn update_player(resources: &mut GameResources, dt: f32) {
        let changes = resources.world_changes.read().unwrap();
        let changes_map = changes.get_all_changes_copy();
        drop(changes);
        resources.player_controller.update(&mut resources.player, dt, &changes_map);
    }
    
    /// Обновление аудио системы
    fn update_audio(resources: &mut GameResources, dt: f32) {
        if let Some(audio) = &mut resources.audio_system {
            let is_moving = resources.player_controller.forward 
                || resources.player_controller.backward 
                || resources.player_controller.left 
                || resources.player_controller.right;
            
            audio.update(
                resources.player.eye_position(),
                resources.player.forward(),
                resources.player.velocity.y,
                is_moving,
                resources.player.on_ground,
                resources.player.is_sprinting,
                resources.player_controller.jump,
                dt,
            );
        }
    }
}


============================================================
FILE: terrain\mod.rs
============================================================

// ============================================
// Terrain Module - Гибридная генерация мира
// ============================================

pub mod generation;
pub mod mesh;
pub mod voxel;
pub mod cache;
pub mod gpu;
pub mod lod;
pub mod manager;
pub mod world_changes;

// Re-exports
pub use mesh::TerrainVertex;
pub use cache::ChunkKey;
pub use gpu::GpuChunkManager;
pub use voxel::{VoxelChunk, ChunkNeighbors, CHUNK_SIZE, MIN_HEIGHT};
pub use manager::{HybridTerrainManager, GeneratedMesh, GeneratedChunkData, SectionTerrainManager};
pub use generation::{get_height, get_lod_height, CaveParams, is_cave};
pub use world_changes::{WorldChanges, BlockPos};


============================================================
FILE: terrain\world_changes.rs
============================================================

// ============================================
// World Changes - Хранение изменений мира
// ============================================
// Хранит сломанные/поставленные блоки поверх процедурной генерации

use std::collections::HashMap;
use crate::gpu::blocks::{BlockType, AIR};

/// Ключ для блока в мире
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct BlockPos {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}

impl BlockPos {
    pub fn new(x: i32, y: i32, z: i32) -> Self {
        Self { x, y, z }
    }
    
    pub fn from_array(arr: [i32; 3]) -> Self {
        Self { x: arr[0], y: arr[1], z: arr[2] }
    }
    
    /// Получить ключ чанка для этого блока
    pub fn chunk_key(&self) -> (i32, i32) {
        let chunk_x = if self.x >= 0 { self.x / 16 } else { (self.x - 15) / 16 };
        let chunk_z = if self.z >= 0 { self.z / 16 } else { (self.z - 15) / 16 };
        (chunk_x, chunk_z)
    }
}

/// Хранилище изменений мира
pub struct WorldChanges {
    /// Изменённые блоки: позиция -> новый тип (Air = сломан)
    changes: HashMap<BlockPos, BlockType>,
    
    /// Чанки которые нужно перегенерировать
    dirty_chunks: Vec<(i32, i32)>,
    
    /// Версия изменений (инкрементируется при каждом изменении)
    version: u64,
}

impl WorldChanges {
    pub fn new() -> Self {
        Self {
            changes: HashMap::new(),
            dirty_chunks: Vec::new(),
            version: 0,
        }
    }
    
    /// Получить версию изменений
    pub fn version(&self) -> u64 {
        self.version
    }
    
    /// Установить блок (или удалить если Air)
    pub fn set_block(&mut self, pos: BlockPos, block_type: BlockType) {
        self.changes.insert(pos, block_type);
        self.version += 1;
        
        // Помечаем чанк как грязный
        let chunk_key = pos.chunk_key();
        if !self.dirty_chunks.contains(&chunk_key) {
            self.dirty_chunks.push(chunk_key);
        }
    }
    
    /// Сломать блок (установить Air)
    pub fn break_block(&mut self, x: i32, y: i32, z: i32) {
        self.set_block(BlockPos::new(x, y, z), AIR);
    }
    
    /// Получить изменённый блок (если есть)
    pub fn get_block(&self, x: i32, y: i32, z: i32) -> Option<BlockType> {
        self.changes.get(&BlockPos::new(x, y, z)).copied()
    }
    
    /// Проверить есть ли изменение для блока
    pub fn has_change(&self, x: i32, y: i32, z: i32) -> bool {
        self.changes.contains_key(&BlockPos::new(x, y, z))
    }
    
    /// Получить и очистить список грязных чанков
    pub fn take_dirty_chunks(&mut self) -> Vec<(i32, i32)> {
        std::mem::take(&mut self.dirty_chunks)
    }
    
    /// Есть ли грязные чанки
    pub fn has_dirty_chunks(&self) -> bool {
        !self.dirty_chunks.is_empty()
    }
    
    /// Количество изменений
    pub fn change_count(&self) -> usize {
        self.changes.len()
    }
    
    /// Получить копию всех изменений (для передачи в генератор)
    pub fn get_all_changes_copy(&self) -> HashMap<BlockPos, BlockType> {
        self.changes.clone()
    }
    
    /// Получить изменения только для конкретного чанка
    pub fn get_changes_for_chunk(&self, chunk_x: i32, chunk_z: i32, chunk_size: i32) -> HashMap<BlockPos, BlockType> {
        let min_x = chunk_x * chunk_size;
        let max_x = min_x + chunk_size;
        let min_z = chunk_z * chunk_size;
        let max_z = min_z + chunk_size;
        
        self.changes
            .iter()
            .filter(|(pos, _)| {
                pos.x >= min_x && pos.x < max_x && pos.z >= min_z && pos.z < max_z
            })
            .map(|(pos, block)| (*pos, *block))
            .collect()
    }
}

impl Default for WorldChanges {
    fn default() -> Self {
        Self::new()
    }
}


============================================================
FILE: terrain\cache\chunk_key.rs
============================================================

// ============================================
// Chunk Key - Идентификатор чанка
// ============================================

/// Ключ чанка: (chunk_x, chunk_z, lod_scale)
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub struct ChunkKey {
    pub x: i32,
    pub z: i32,
    pub scale: i32,
}

impl ChunkKey {
    pub fn new(x: i32, z: i32, scale: i32) -> Self {
        Self { x, z, scale }
    }
    
    /// Создать ключ для секции (section_y = 0..16)
    pub fn new_section(chunk_x: i32, chunk_z: i32, section_y: i32) -> Self {
        Self { x: chunk_x, z: chunk_z, scale: 1000 + section_y }
    }
}


============================================================
FILE: terrain\cache\mod.rs
============================================================

mod chunk_key;

pub use chunk_key::ChunkKey;


============================================================
FILE: terrain\generation\caves.rs
============================================================

// ============================================
// Cave System - 3D Noise для пещер
// ============================================

use super::noise::noise3d;

/// Параметры генерации пещер
#[derive(Clone, Copy)]
pub struct CaveParams {
    pub scale: f32,
    pub threshold: f32,
    pub surface_offset: i32,
    pub min_height: i32,
    pub vertical_squeeze: f32,
}

impl Default for CaveParams {
    fn default() -> Self {
        Self {
            scale: 0.025,
            threshold: 0.48,
            surface_offset: 8,
            min_height: -64,
            vertical_squeeze: 0.5,
        }
    }
}

/// Проверяет, является ли блок пещерой
#[inline]
pub fn is_cave(x: i32, y: i32, z: i32, params: &CaveParams) -> bool {
    let fx = x as f32 * params.scale;
    let fy = y as f32 * params.scale * params.vertical_squeeze;
    let fz = z as f32 * params.scale;
    
    let cave_noise = noise3d(fx, fy, fz);
    cave_noise > params.threshold
}


============================================================
FILE: terrain\generation\color.rs
============================================================

// ============================================
// Terrain Colors - Цвета по биому
// ============================================

use crate::gpu::blocks::get_face_colors;
use crate::gpu::biomes::biome_selector;

/// Получить цвет террейна по координатам (использует биом)
#[inline]
pub fn get_color(x: f32, z: f32, is_top: bool) -> [f32; 3] {
    let biome = biome_selector().get_biome_def(x as i32, z as i32);
    let block = biome.surface_block;
    
    let (top_color, side_color) = get_face_colors(block);
    if is_top { top_color } else { side_color }
}

/// Старая версия для совместимости (deprecated)
#[inline]
pub fn get_color_by_height(height: f32, is_top: bool) -> [f32; 3] {
    use crate::gpu::blocks::worldgen_blocks;
    let blocks = worldgen_blocks();
    let block = blocks.surface_block(height);
    
    let (top_color, side_color) = get_face_colors(block);
    if is_top { top_color } else { side_color }
}


============================================================
FILE: terrain\generation\height.rs
============================================================

// ============================================
// Height Map - Генерация карты высот с биомами
// ============================================

use crate::gpu::biomes::{BiomeTerrainGen, get_biome_height};

/// Базовая высота террейна (теперь с учётом биомов)
#[inline]
pub fn get_height(x: f32, z: f32) -> f32 {
    get_biome_height(x, z)
}

/// Высота для LOD (центрированная)
#[inline]
pub fn get_lod_height(x: f32, z: f32, scale: i32) -> f32 {
    if scale == 1 {
        return get_height(x, z);
    }
    let half = scale as f32 * 0.5;
    get_height(x + half, z + half)
}

/// 3D density для гор с карнизами
#[inline]
pub fn get_3d_density(x: f32, y: f32, z: f32) -> f32 {
    BiomeTerrainGen::get_3d_density(x, y, z)
}

/// Проверка твёрдости блока в 3D (для гор)
#[inline]
pub fn is_solid_3d(x: f32, y: f32, z: f32) -> bool {
    BiomeTerrainGen::is_solid(x, y, z)
}


============================================================
FILE: terrain\generation\mod.rs
============================================================

pub mod noise;
pub mod caves;
pub mod height;
pub mod color;

pub use caves::{CaveParams, is_cave};
pub use height::{get_height, get_lod_height};
pub use color::get_color;
pub use noise::noise3d;


============================================================
FILE: terrain\generation\noise.rs
============================================================

// ============================================
// Noise Functions - Шумовые функции для генерации
// ============================================

/// Hash3D возвращает значение в диапазоне 0.0..1.0
#[inline(always)]
pub fn hash3d(x: i32, y: i32, z: i32) -> f32 {
    let n = x.wrapping_mul(374761393)
        .wrapping_add(y.wrapping_mul(668265263))
        .wrapping_add(z.wrapping_mul(1274126177));
    let n = (n ^ (n >> 13)).wrapping_mul(1911520717);
    ((n as u32) as f32) / (u32::MAX as f32)
}

#[inline(always)]
fn smoothstep(t: f32) -> f32 {
    t * t * (3.0 - 2.0 * t)
}

/// 3D Value Noise - быстрее Simplex, достаточно для пещер
#[inline]
pub fn noise3d(x: f32, y: f32, z: f32) -> f32 {
    let xi = x.floor() as i32;
    let yi = y.floor() as i32;
    let zi = z.floor() as i32;
    
    let xf = smoothstep(x - x.floor());
    let yf = smoothstep(y - y.floor());
    let zf = smoothstep(z - z.floor());
    
    let n000 = hash3d(xi, yi, zi);
    let n100 = hash3d(xi + 1, yi, zi);
    let n010 = hash3d(xi, yi + 1, zi);
    let n110 = hash3d(xi + 1, yi + 1, zi);
    let n001 = hash3d(xi, yi, zi + 1);
    let n101 = hash3d(xi + 1, yi, zi + 1);
    let n011 = hash3d(xi, yi + 1, zi + 1);
    let n111 = hash3d(xi + 1, yi + 1, zi + 1);
    
    let nx00 = n000 + xf * (n100 - n000);
    let nx10 = n010 + xf * (n110 - n010);
    let nx01 = n001 + xf * (n101 - n001);
    let nx11 = n011 + xf * (n111 - n011);
    
    let nxy0 = nx00 + yf * (nx10 - nx00);
    let nxy1 = nx01 + yf * (nx11 - nx01);
    
    nxy0 + zf * (nxy1 - nxy0)
}

// 2D noise functions (from original noise.rs)
#[inline(always)]
pub fn hash2d(x: i32, y: i32) -> f32 {
    let n = x.wrapping_mul(374761393).wrapping_add(y.wrapping_mul(668265263));
    let n = (n ^ (n >> 13)).wrapping_mul(1274126177);
    ((n as u32) as f32) / (u32::MAX as f32)
}

#[inline]
pub fn noise2d(x: f32, y: f32) -> f32 {
    let xi = x.floor() as i32;
    let yi = y.floor() as i32;
    let xf = smoothstep(x - x.floor());
    let yf = smoothstep(y - y.floor());
    
    let n00 = hash2d(xi, yi);
    let n10 = hash2d(xi + 1, yi);
    let n01 = hash2d(xi, yi + 1);
    let n11 = hash2d(xi + 1, yi + 1);
    
    let nx0 = n00 + xf * (n10 - n00);
    let nx1 = n01 + xf * (n11 - n01);
    
    nx0 + yf * (nx1 - nx0)
}

/// FBM 2D - несколько октав шума
#[inline]
pub fn fbm2d(x: f32, y: f32, octaves: u32) -> f32 {
    let mut value = 0.0;
    let mut amplitude = 1.0;
    let mut frequency = 1.0;
    let mut max_value = 0.0;
    
    for _ in 0..octaves {
        value += amplitude * noise2d(x * frequency, y * frequency);
        max_value += amplitude;
        amplitude *= 0.5;
        frequency *= 2.0;
    }
    
    value / max_value
}


============================================================
FILE: terrain\gpu\chunk.rs
============================================================

// ============================================
// GPU Chunk - Буферы чанка на GPU
// ============================================

use wgpu::util::DeviceExt;
use crate::gpu::terrain::cache::ChunkKey;
use crate::gpu::terrain::mesh::TerrainVertex;

/// GPU буферы для одного чанка
pub struct GpuChunk {
    pub key: ChunkKey,
    pub vertex_buffer: wgpu::Buffer,
    pub index_buffer: wgpu::Buffer,
    pub index_count: u32,
}

impl GpuChunk {
    pub fn new(
        device: &wgpu::Device,
        key: ChunkKey,
        vertices: &[TerrainVertex],
        indices: &[u32],
    ) -> Self {
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some(&format!("Chunk {:?} Vertices", key)),
            contents: bytemuck::cast_slice(vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });

        let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some(&format!("Chunk {:?} Indices", key)),
            contents: bytemuck::cast_slice(indices),
            usage: wgpu::BufferUsages::INDEX,
        });

        Self {
            key,
            vertex_buffer,
            index_buffer,
            index_count: indices.len() as u32,
        }
    }
}


============================================================
FILE: terrain\gpu\manager.rs
============================================================

// ============================================
// GPU Chunk Manager - Управление GPU буферами
// ============================================

use std::collections::HashMap;
use std::sync::Arc;

use crate::gpu::terrain::cache::ChunkKey;
use crate::gpu::terrain::mesh::TerrainVertex;
use super::chunk::GpuChunk;

/// Менеджер GPU буферов чанков
pub struct GpuChunkManager {
    chunks: HashMap<ChunkKey, GpuChunk>,
    device: Arc<wgpu::Device>,
}

impl GpuChunkManager {
    pub fn new(device: Arc<wgpu::Device>) -> Self {
        Self {
            chunks: HashMap::with_capacity(1024),
            device,
        }
    }

    /// Загружает чанк на GPU
    pub fn upload(&mut self, key: ChunkKey, vertices: &[TerrainVertex], indices: &[u32]) {
        if vertices.is_empty() || indices.is_empty() {
            return;
        }
        
        let gpu_chunk = GpuChunk::new(&self.device, key, vertices, indices);
        self.chunks.insert(key, gpu_chunk);
    }

    /// Удаляет чанки которых нет в списке нужных
    pub fn retain_only(&mut self, valid_keys: &std::collections::HashSet<ChunkKey>) {
        self.chunks.retain(|key, _| valid_keys.contains(key));
    }

    /// Итератор по всем GPU чанкам для рендеринга
    pub fn iter(&self) -> impl Iterator<Item = &GpuChunk> {
        self.chunks.values()
    }
}


============================================================
FILE: terrain\gpu\mod.rs
============================================================

mod chunk;
mod manager;

pub use chunk::GpuChunk;
pub use manager::GpuChunkManager;


============================================================
FILE: terrain\lod\levels.rs
============================================================

// ============================================
// LOD Levels - Уровни детализации
// ============================================

#[derive(Clone, Copy)]
pub struct LodLevel {
    pub min_chunks: i32,
    pub max_chunks: i32,
    pub scale: i32,
}

impl LodLevel {
    pub const DEFAULT_LEVELS: [LodLevel; 4] = [
        LodLevel { min_chunks: 0, max_chunks: 8, scale: 1 },
        LodLevel { min_chunks: 8, max_chunks: 16, scale: 2 },
        LodLevel { min_chunks: 16, max_chunks: 32, scale: 4 },
        LodLevel { min_chunks: 32, max_chunks: 64, scale: 8 },
    ];
}


============================================================
FILE: terrain\lod\mod.rs
============================================================

mod levels;

pub use levels::LodLevel;


============================================================
FILE: terrain\manager\mod.rs
============================================================

mod hybrid;
mod section;

pub use hybrid::{HybridTerrainManager, GeneratedMesh, GeneratedChunkData};
pub use section::SectionTerrainManager;


============================================================
FILE: terrain\manager\section.rs
============================================================

// ============================================
// Section Terrain Manager - Секционная генерация
// ============================================

use std::collections::HashSet;
use std::sync::mpsc::{channel, Receiver, Sender};
use std::thread::{self, JoinHandle};

use crate::gpu::terrain::cache::ChunkKey;

/// Секционный менеджер (заглушка для совместимости)
pub struct SectionTerrainManager {
    _worker: JoinHandle<()>,
}

impl SectionTerrainManager {
    pub fn new() -> Self {
        let (tx, rx) = channel::<()>();
        let worker = thread::spawn(move || {
            loop {
                match rx.recv() {
                    Ok(_) => {}
                    Err(_) => break,
                }
            }
        });
        
        Self { _worker: worker }
    }
}


============================================================
FILE: terrain\manager\hybrid\generator.rs
============================================================

use std::collections::{HashMap, HashSet};
use rayon::prelude::*;

use crate::gpu::terrain::voxel::{VoxelChunk, ChunkNeighbors, CHUNK_SIZE, MeshingContext};
use crate::gpu::terrain::mesh::TerrainVertex;
use crate::gpu::terrain::cache::ChunkKey;
use crate::gpu::terrain::lod::LodLevel;
use crate::gpu::terrain::BlockPos;
use crate::gpu::blocks::BlockType;

use super::types::{GeneratedChunkData, GeneratedMesh};
use super::lod_mesh::generate_lod_chunk;

/// Генератор terrain с кэшированием и zero-allocation контекстом
pub(super) struct HybridGenerator {
    voxel_cache: HashMap<(i32, i32), VoxelChunk>,
    mesh_cache: HashMap<ChunkKey, (Vec<TerrainVertex>, Vec<u32>)>,
    cache_version: u64,
    lod_levels: [LodLevel; 4],
    /// Переиспользуемый контекст для генерации мешей (zero-allocation)
    meshing_ctx: MeshingContext,
}

impl HybridGenerator {
    pub fn new() -> Self {
        Self {
            voxel_cache: HashMap::new(),
            mesh_cache: HashMap::new(),
            cache_version: 0,
            lod_levels: LodLevel::DEFAULT_LEVELS,
            meshing_ctx: MeshingContext::new(),
        }
    }
    
    pub fn set_lod_distances(&mut self, distances: [i32; 4]) {
        self.lod_levels[0] = LodLevel { min_chunks: 0, max_chunks: distances[0], scale: 1 };
        self.lod_levels[1] = LodLevel { min_chunks: distances[0], max_chunks: distances[1], scale: 2 };
        self.lod_levels[2] = LodLevel { min_chunks: distances[1], max_chunks: distances[2], scale: 4 };
        self.lod_levels[3] = LodLevel { min_chunks: distances[2], max_chunks: distances[3], scale: 8 };
        self.mesh_cache.clear();
    }

    pub fn generate(
        &mut self,
        player_x: f32,
        player_z: f32,
        world_changes: &HashMap<BlockPos, BlockType>,
        changes_version: u64,
    ) -> GeneratedMesh {
        let center_cx = (player_x / CHUNK_SIZE as f32).floor() as i32;
        let center_cz = (player_z / CHUNK_SIZE as f32).floor() as i32;
        
        self.invalidate_changed_chunks(world_changes, changes_version);
        
        let (required_keys, chunks_to_generate) = self.collect_chunks_to_generate(center_cx, center_cz);
        
        // Воксельные чанки - последовательно (нужен кэш соседей)
        self.generate_voxel_chunks(&chunks_to_generate, world_changes);
        
        // LOD чанки - параллельно
        self.generate_lod_chunks_parallel(&chunks_to_generate);
        
        let new_chunks = self.collect_new_chunks(&chunks_to_generate);
        self.cleanup_caches(center_cx, center_cz, &required_keys);
        
        GeneratedMesh { new_chunks, required_keys }
    }


    fn invalidate_changed_chunks(&mut self, world_changes: &HashMap<BlockPos, BlockType>, changes_version: u64) {
        if changes_version == self.cache_version { return; }
        
        for pos in world_changes.keys() {
            let chunk_x = pos.x.div_euclid(CHUNK_SIZE);
            let chunk_z = pos.z.div_euclid(CHUNK_SIZE);
            for dx in -1..=1 {
                for dz in -1..=1 {
                    self.voxel_cache.remove(&(chunk_x + dx, chunk_z + dz));
                    self.mesh_cache.remove(&ChunkKey::new(chunk_x + dx, chunk_z + dz, 1));
                }
            }
        }
        self.cache_version = changes_version;
    }
    
    fn collect_chunks_to_generate(&self, center_cx: i32, center_cz: i32) -> (HashSet<ChunkKey>, Vec<(ChunkKey, bool)>) {
        let mut required_keys = HashSet::new();
        let mut chunks_to_generate = Vec::new();
        
        for lod in &self.lod_levels {
            for dz in -lod.max_chunks..=lod.max_chunks {
                for dx in -lod.max_chunks..=lod.max_chunks {
                    let dist = dx.abs().max(dz.abs());
                    if dist < lod.min_chunks || dist >= lod.max_chunks { continue; }
                    
                    let world_cx = center_cx + dx;
                    let world_cz = center_cz + dz;
                    
                    let (final_cx, final_cz) = if lod.scale > 1 {
                        (world_cx.div_euclid(lod.scale) * lod.scale, world_cz.div_euclid(lod.scale) * lod.scale)
                    } else {
                        (world_cx, world_cz)
                    };
                    
                    let key = ChunkKey::new(final_cx, final_cz, lod.scale);
                    if required_keys.contains(&key) { continue; }
                    required_keys.insert(key);
                    
                    if !self.mesh_cache.contains_key(&key) {
                        chunks_to_generate.push((key, lod.scale == 1));
                    }
                }
            }
        }
        
        (required_keys, chunks_to_generate)
    }
    
    fn generate_voxel_chunks(&mut self, chunks: &[(ChunkKey, bool)], world_changes: &HashMap<BlockPos, BlockType>) {
        let voxel_keys: Vec<_> = chunks.iter()
            .filter(|(_, is_voxel)| *is_voxel)
            .map(|(key, _)| *key)
            .collect();
        
        for key in voxel_keys {
            let (vertices, indices) = self.generate_voxel_chunk(key.x, key.z, world_changes);
            self.mesh_cache.insert(key, (vertices, indices));
        }
    }
    
    fn generate_lod_chunks_parallel(&mut self, chunks: &[(ChunkKey, bool)]) {
        let lod_keys: Vec<_> = chunks.iter()
            .filter(|(_, is_voxel)| !*is_voxel)
            .map(|(key, _)| *key)
            .collect();
        
        let results: Vec<_> = lod_keys.par_iter()
            .map(|key| (*key, generate_lod_chunk(key.x, key.z, key.scale)))
            .collect();
        
        for (key, (vertices, indices)) in results {
            self.mesh_cache.insert(key, (vertices, indices));
        }
    }
    
    fn generate_voxel_chunk(&mut self, cx: i32, cz: i32, world_changes: &HashMap<BlockPos, BlockType>) -> (Vec<TerrainVertex>, Vec<u32>) {
        // Ensure chunk and neighbors exist
        if !self.voxel_cache.contains_key(&(cx, cz)) {
            self.voxel_cache.insert((cx, cz), VoxelChunk::new(cx, cz, world_changes));
        }
        for (dx, dz) in [(-1, 0), (1, 0), (0, -1), (0, 1)] {
            if !self.voxel_cache.contains_key(&(cx + dx, cz + dz)) {
                self.voxel_cache.insert((cx + dx, cz + dz), VoxelChunk::new(cx + dx, cz + dz, world_changes));
            }
        }
        
        let neighbors = ChunkNeighbors {
            pos_x: self.voxel_cache.get(&(cx + 1, cz)),
            neg_x: self.voxel_cache.get(&(cx - 1, cz)),
            pos_z: self.voxel_cache.get(&(cx, cz + 1)),
            neg_z: self.voxel_cache.get(&(cx, cz - 1)),
        };
        
        // Используем zero-allocation контекст
        self.voxel_cache.get(&(cx, cz))
            .map(|c| c.generate_mesh_with_context(&neighbors, &mut self.meshing_ctx))
            .unwrap_or_default()
    }
    
    fn collect_new_chunks(&self, chunks: &[(ChunkKey, bool)]) -> Vec<GeneratedChunkData> {
        chunks.iter()
            .filter_map(|(key, _)| {
                self.mesh_cache.get(key).and_then(|(vertices, indices)| {
                    if !vertices.is_empty() {
                        Some(GeneratedChunkData {
                            key: *key,
                            vertices: vertices.clone(),
                            indices: indices.clone(),
                        })
                    } else {
                        None
                    }
                })
            })
            .collect()
    }
    
    fn cleanup_caches(&mut self, center_cx: i32, center_cz: i32, required_keys: &HashSet<ChunkKey>) {
        let max_dist = self.lod_levels[0].max_chunks + 2;
        self.voxel_cache.retain(|(cx, cz), _| {
            (cx - center_cx).abs().max((cz - center_cz).abs()) < max_dist
        });
        self.mesh_cache.retain(|key, _| required_keys.contains(key));
    }
}


============================================================
FILE: terrain\manager\hybrid\lod_mesh.rs
============================================================

use crate::gpu::terrain::voxel::CHUNK_SIZE;
use crate::gpu::terrain::mesh::TerrainVertex;
use crate::gpu::terrain::generation::{get_lod_height, get_color};

/// Генерация LOD чанка (thread-safe, для параллельной обработки)
pub fn generate_lod_chunk(cx: i32, cz: i32, scale: i32) -> (Vec<TerrainVertex>, Vec<u32>) {
    let mut vertices = Vec::with_capacity(5000);
    let mut indices = Vec::with_capacity(7500);
    
    let base_x = cx * CHUNK_SIZE;
    let base_z = cz * CHUNK_SIZE;
    let size = CHUNK_SIZE + 2;
    let s = scale as f32;
    
    // Генерируем heightmap
    let mut heights = vec![0.0f32; (size * size) as usize];
    for z in 0..size {
        for x in 0..size {
            heights[(z * size + x) as usize] = get_lod_height(
                (base_x + (x - 1) * scale) as f32,
                (base_z + (z - 1) * scale) as f32,
                scale
            );
        }
    }
    
    generate_top_faces(&mut vertices, &mut indices, &heights, base_x, base_z, scale);
    generate_side_faces(&mut vertices, &mut indices, &heights, base_x, base_z, scale, s);
    generate_skirts(&mut vertices, &mut indices, &heights, base_x, base_z, scale, s);
    
    (vertices, indices)
}


/// Greedy meshing для верхних граней
fn generate_top_faces(
    vertices: &mut Vec<TerrainVertex>,
    indices: &mut Vec<u32>,
    heights: &[f32],
    base_x: i32,
    base_z: i32,
    scale: i32,
) {
    let size = CHUNK_SIZE + 2;
    let mut visited = vec![false; (CHUNK_SIZE * CHUNK_SIZE) as usize];
    
    for z in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let idx = (z * CHUNK_SIZE + x) as usize;
            if visited[idx] { continue; }
            
            let h = heights[((z + 1) * size + (x + 1)) as usize];
            let wx = (base_x + x * scale) as f32;
            let wz = (base_z + z * scale) as f32;
            let color = get_color(wx, wz, true);
            
            // Расширяем по X (только если тот же цвет и высота)
            let mut width = 1;
            while x + width < CHUNK_SIZE {
                let next_h = heights[((z + 1) * size + (x + width + 1)) as usize];
                let next_wx = (base_x + (x + width) * scale) as f32;
                let next_color = get_color(next_wx, wz, true);
                if visited[(z * CHUNK_SIZE + x + width) as usize] || next_h != h || next_color != color { break; }
                width += 1;
            }
            
            // Расширяем по Z
            let mut depth = 1;
            'outer: while z + depth < CHUNK_SIZE {
                for dx in 0..width {
                    let next_h = heights[((z + depth + 1) * size + (x + dx + 1)) as usize];
                    let next_wx = (base_x + (x + dx) * scale) as f32;
                    let next_wz = (base_z + (z + depth) * scale) as f32;
                    let next_color = get_color(next_wx, next_wz, true);
                    if visited[((z + depth) * CHUNK_SIZE + x + dx) as usize] || next_h != h || next_color != color { break 'outer; }
                }
                depth += 1;
            }
            
            // Помечаем как посещённые
            for dz in 0..depth {
                for dx in 0..width {
                    visited[((z + dz) * CHUNK_SIZE + x + dx) as usize] = true;
                }
            }
            
            // Создаём quad
            let w = (width * scale) as f32;
            let d = (depth * scale) as f32;
            
            let base_v = vertices.len() as u32;
            vertices.push(TerrainVertex { position: [wx, h, wz], normal: [0.0, 1.0, 0.0], color, block_id: 0 });
            vertices.push(TerrainVertex { position: [wx, h, wz + d], normal: [0.0, 1.0, 0.0], color, block_id: 0 });
            vertices.push(TerrainVertex { position: [wx + w, h, wz + d], normal: [0.0, 1.0, 0.0], color, block_id: 0 });
            vertices.push(TerrainVertex { position: [wx + w, h, wz], normal: [0.0, 1.0, 0.0], color, block_id: 0 });
            indices.extend_from_slice(&[base_v, base_v + 1, base_v + 2, base_v, base_v + 2, base_v + 3]);
        }
    }
}

/// Боковые грани между разными высотами
fn generate_side_faces(
    vertices: &mut Vec<TerrainVertex>,
    indices: &mut Vec<u32>,
    heights: &[f32],
    base_x: i32,
    base_z: i32,
    scale: i32,
    s: f32,
) {
    let size = CHUNK_SIZE + 2;
    
    for z in 0..CHUNK_SIZE {
        for x in 0..CHUNK_SIZE {
            let h = heights[((z + 1) * size + (x + 1)) as usize];
            let wx = (base_x + x * scale) as f32;
            let wz = (base_z + z * scale) as f32;
            
            let h_xp = heights[((z + 1) * size + (x + 2)) as usize];
            if h_xp < h { add_side_x(vertices, indices, wx + s, wz, h_xp, h, 1.0, s, wx, wz); }
            
            let h_xn = heights[((z + 1) * size + x) as usize];
            if h_xn < h { add_side_x(vertices, indices, wx, wz, h_xn, h, -1.0, s, wx, wz); }
            
            let h_zp = heights[((z + 2) * size + (x + 1)) as usize];
            if h_zp < h { add_side_z(vertices, indices, wx, wz + s, h_zp, h, 1.0, s, wx, wz); }
            
            let h_zn = heights[(z * size + (x + 1)) as usize];
            if h_zn < h { add_side_z(vertices, indices, wx, wz, h_zn, h, -1.0, s, wx, wz); }
        }
    }
}

/// Юбки по краям чанка
fn generate_skirts(
    vertices: &mut Vec<TerrainVertex>,
    indices: &mut Vec<u32>,
    heights: &[f32],
    base_x: i32,
    base_z: i32,
    scale: i32,
    s: f32,
) {
    let size = CHUNK_SIZE + 2;
    let skirt_depth = 8.0;
    
    // -Z edge
    for x in 0..CHUNK_SIZE {
        let h = heights[(1 * size + (x + 1)) as usize];
        let wx = (base_x + x * scale) as f32;
        let wz = base_z as f32;
        add_skirt_z(vertices, indices, wx, wz, h, h - skirt_depth, s, -1.0, wx, wz);
    }
    // +Z edge
    for x in 0..CHUNK_SIZE {
        let h = heights[(CHUNK_SIZE * size + (x + 1)) as usize];
        let wx = (base_x + x * scale) as f32;
        let wz = (base_z + CHUNK_SIZE * scale) as f32;
        add_skirt_z(vertices, indices, wx, wz, h, h - skirt_depth, s, 1.0, wx, wz);
    }
    // -X edge
    for z in 0..CHUNK_SIZE {
        let h = heights[((z + 1) * size + 1) as usize];
        let wx = base_x as f32;
        let wz = (base_z + z * scale) as f32;
        add_skirt_x(vertices, indices, wx, wz, h, h - skirt_depth, s, -1.0, wx, wz);
    }
    // +X edge
    for z in 0..CHUNK_SIZE {
        let h = heights[((z + 1) * size + CHUNK_SIZE) as usize];
        let wx = (base_x + CHUNK_SIZE * scale) as f32;
        let wz = (base_z + z * scale) as f32;
        add_skirt_x(vertices, indices, wx, wz, h, h - skirt_depth, s, 1.0, wx, wz);
    }
}

fn add_side_x(vertices: &mut Vec<TerrainVertex>, indices: &mut Vec<u32>, x: f32, z: f32, h_low: f32, h_high: f32, nx: f32, s: f32, world_x: f32, world_z: f32) {
    let color = get_color(world_x, world_z, false);
    let normal = [nx, 0.0, 0.0];
    let base = vertices.len() as u32;
    if nx < 0.0 {
        vertices.push(TerrainVertex { position: [x, h_low, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_low, z + s], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_high, z + s], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_high, z], normal, color, block_id: 0 });
    } else {
        vertices.push(TerrainVertex { position: [x, h_low, z + s], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_low, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_high, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_high, z + s], normal, color, block_id: 0 });
    }
    indices.extend_from_slice(&[base, base + 1, base + 2, base, base + 2, base + 3]);
}

fn add_side_z(vertices: &mut Vec<TerrainVertex>, indices: &mut Vec<u32>, x: f32, z: f32, h_low: f32, h_high: f32, nz: f32, s: f32, world_x: f32, world_z: f32) {
    let color = get_color(world_x, world_z, false);
    let normal = [0.0, 0.0, nz];
    let base = vertices.len() as u32;
    if nz > 0.0 {
        vertices.push(TerrainVertex { position: [x, h_low, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x + s, h_low, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x + s, h_high, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_high, z], normal, color, block_id: 0 });
    } else {
        vertices.push(TerrainVertex { position: [x + s, h_low, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_low, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_high, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x + s, h_high, z], normal, color, block_id: 0 });
    }
    indices.extend_from_slice(&[base, base + 1, base + 2, base, base + 2, base + 3]);
}

fn add_skirt_x(vertices: &mut Vec<TerrainVertex>, indices: &mut Vec<u32>, x: f32, z: f32, h_top: f32, h_bottom: f32, s: f32, nx: f32, world_x: f32, world_z: f32) {
    let color = get_color(world_x, world_z, false);
    let normal = [nx, 0.0, 0.0];
    let base = vertices.len() as u32;
    if nx < 0.0 {
        vertices.push(TerrainVertex { position: [x, h_bottom, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_bottom, z + s], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_top, z + s], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_top, z], normal, color, block_id: 0 });
    } else {
        vertices.push(TerrainVertex { position: [x, h_bottom, z + s], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_bottom, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_top, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_top, z + s], normal, color, block_id: 0 });
    }
    indices.extend_from_slice(&[base, base + 1, base + 2, base, base + 2, base + 3]);
}

fn add_skirt_z(vertices: &mut Vec<TerrainVertex>, indices: &mut Vec<u32>, x: f32, z: f32, h_top: f32, h_bottom: f32, s: f32, nz: f32, world_x: f32, world_z: f32) {
    let color = get_color(world_x, world_z, false);
    let normal = [0.0, 0.0, nz];
    let base = vertices.len() as u32;
    if nz > 0.0 {
        vertices.push(TerrainVertex { position: [x, h_bottom, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x + s, h_bottom, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x + s, h_top, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_top, z], normal, color, block_id: 0 });
    } else {
        vertices.push(TerrainVertex { position: [x + s, h_bottom, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_bottom, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x, h_top, z], normal, color, block_id: 0 });
        vertices.push(TerrainVertex { position: [x + s, h_top, z], normal, color, block_id: 0 });
    }
    indices.extend_from_slice(&[base, base + 1, base + 2, base, base + 2, base + 3]);
}


============================================================
FILE: terrain\manager\hybrid\manager.rs
============================================================

use std::collections::HashMap;
use std::sync::mpsc::{channel, Receiver, Sender, TryRecvError};
use std::thread::{self, JoinHandle};

use crate::gpu::terrain::voxel::CHUNK_SIZE;
use crate::gpu::terrain::BlockPos;
use crate::gpu::blocks::BlockType;

use super::types::{GenerateRequest, GeneratedMesh};
use super::generator::HybridGenerator;

/// Асинхронный менеджер terrain с фоновой генерацией
pub struct HybridTerrainManager {
    request_tx: Sender<GenerateRequest>,
    result_rx: Receiver<GeneratedMesh>,
    _worker: JoinHandle<()>,
    current_chunk_x: i32,
    current_chunk_z: i32,
    pending: bool,
    changes_version: u64,
    last_sent_version: u64,
    lod_distances: [i32; 4],
    lod_changed: bool,
}

impl HybridTerrainManager {
    pub fn new() -> Self {
        let (request_tx, request_rx) = channel::<GenerateRequest>();
        let (result_tx, result_rx) = channel::<GeneratedMesh>();

        let worker = thread::spawn(move || {
            let mut generator = HybridGenerator::new();
            loop {
                match request_rx.recv() {
                    Ok(request) => {
                        if let Some(distances) = request.lod_distances {
                            generator.set_lod_distances(distances);
                        }
                        let mesh = generator.generate(
                            request.player_x,
                            request.player_z,
                            &request.world_changes,
                            request.changes_version,
                        );
                        if result_tx.send(mesh).is_err() { break; }
                    }
                    Err(_) => break,
                }
            }
        });
        
        Self {
            request_tx,
            result_rx,
            _worker: worker,
            current_chunk_x: i32::MIN,
            current_chunk_z: i32::MIN,
            pending: false,
            changes_version: 0,
            last_sent_version: 0,
            lod_distances: [8, 16, 32, 64],
            lod_changed: false,
        }
    }
    
    pub fn set_lod_distances(&mut self, distances: [i32; 4]) {
        if self.lod_distances != distances {
            self.lod_distances = distances;
            self.lod_changed = true;
        }
    }
    
    pub fn get_lod_distances(&self) -> [i32; 4] {
        self.lod_distances
    }
    
    pub fn generate_initial(&mut self, player_x: f32, player_z: f32) -> GeneratedMesh {
        let mut generator = HybridGenerator::new();
        let mesh = generator.generate(player_x, player_z, &HashMap::new(), 0);
        self.current_chunk_x = (player_x / CHUNK_SIZE as f32).floor() as i32;
        self.current_chunk_z = (player_z / CHUNK_SIZE as f32).floor() as i32;
        mesh
    }
    
    pub fn update(&mut self, player_x: f32, player_z: f32, world_changes: &HashMap<BlockPos, BlockType>, changes_version: u64) {
        let chunk_x = (player_x / CHUNK_SIZE as f32).floor() as i32;
        let chunk_z = (player_z / CHUNK_SIZE as f32).floor() as i32;
        self.changes_version = changes_version;
        
        let need_regen = chunk_x != self.current_chunk_x 
            || chunk_z != self.current_chunk_z
            || changes_version != self.last_sent_version
            || self.lod_changed;
        
        if need_regen && !self.pending {
            let lod_distances = if self.lod_changed {
                self.lod_changed = false;
                Some(self.lod_distances)
            } else {
                None
            };
            
            let request = GenerateRequest {
                player_x,
                player_z,
                world_changes: world_changes.clone(),
                changes_version,
                lod_distances,
            };
            
            if self.request_tx.send(request).is_ok() {
                self.pending = true;
                self.last_sent_version = changes_version;
                self.current_chunk_x = chunk_x;
                self.current_chunk_z = chunk_z;
            }
        }
    }
    
    pub fn try_get_mesh(&mut self) -> Option<GeneratedMesh> {
        match self.result_rx.try_recv() {
            Ok(mesh) => {
                self.pending = false;
                Some(mesh)
            }
            Err(TryRecvError::Empty) => None,
            Err(TryRecvError::Disconnected) => {
                self.pending = false;
                None
            }
        }
    }
}


============================================================
FILE: terrain\manager\hybrid\mod.rs
============================================================

mod types;
mod lod_mesh;
mod generator;
mod manager;

pub use types::{GeneratedChunkData, GeneratedMesh};
pub use manager::HybridTerrainManager;


============================================================
FILE: terrain\manager\hybrid\types.rs
============================================================

use std::collections::{HashMap, HashSet};

use crate::gpu::terrain::mesh::TerrainVertex;
use crate::gpu::terrain::cache::ChunkKey;
use crate::gpu::terrain::BlockPos;
use crate::gpu::blocks::BlockType;

/// Запрос на генерацию terrain
pub(super) struct GenerateRequest {
    pub player_x: f32,
    pub player_z: f32,
    pub world_changes: HashMap<BlockPos, BlockType>,
    pub changes_version: u64,
    pub lod_distances: Option<[i32; 4]>,
}

/// Данные сгенерированного чанка
pub struct GeneratedChunkData {
    pub key: ChunkKey,
    pub vertices: Vec<TerrainVertex>,
    pub indices: Vec<u32>,
}

/// Результат генерации мешей
pub struct GeneratedMesh {
    pub new_chunks: Vec<GeneratedChunkData>,
    pub required_keys: HashSet<ChunkKey>,
}


============================================================
FILE: terrain\mesh\mod.rs
============================================================

mod vertex;

pub use vertex::TerrainVertex;


============================================================
FILE: terrain\mesh\vertex.rs
============================================================

// ============================================
// Terrain Vertex - Структура вершины
// ============================================

#[repr(C)]
#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable, Default)]
pub struct TerrainVertex {
    pub position: [f32; 3],
    pub normal: [f32; 3],
    pub color: [f32; 3],
    pub block_id: u32,  // ID блока для текстурного атласа
}

impl TerrainVertex {
    pub fn desc() -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<TerrainVertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                wgpu::VertexAttribute {
                    offset: 0,
                    shader_location: 0,
                    format: wgpu::VertexFormat::Float32x3,
                },
                wgpu::VertexAttribute {
                    offset: std::mem::size_of::<[f32; 3]>() as wgpu::BufferAddress,
                    shader_location: 1,
                    format: wgpu::VertexFormat::Float32x3,
                },
                wgpu::VertexAttribute {
                    offset: std::mem::size_of::<[f32; 6]>() as wgpu::BufferAddress,
                    shader_location: 2,
                    format: wgpu::VertexFormat::Float32x3,
                },
                wgpu::VertexAttribute {
                    offset: std::mem::size_of::<[f32; 9]>() as wgpu::BufferAddress,
                    shader_location: 3,
                    format: wgpu::VertexFormat::Uint32,
                },
            ],
        }
    }
    
    /// Создать вершину (block_id = 0 по умолчанию)
    pub fn new(position: [f32; 3], normal: [f32; 3], color: [f32; 3]) -> Self {
        Self { position, normal, color, block_id: 0 }
    }
    
    /// Создать вершину с block_id
    pub fn with_block(position: [f32; 3], normal: [f32; 3], color: [f32; 3], block_id: u8) -> Self {
        Self { position, normal, color, block_id: block_id as u32 }
    }
}


============================================================
FILE: terrain\voxel\chunk.rs
============================================================

// ============================================
// Voxel Chunk - Воксельный чанк
// ============================================
// Data-Driven: все данные блоков из JSON

use std::collections::HashMap;
use crate::gpu::terrain::BlockPos;
use crate::gpu::blocks::{BlockType, AIR, WATER, DEEPSLATE, GRANITE, DIORITE, ANDESITE, 
    COAL_ORE, IRON_ORE, GOLD_ORE, DIAMOND_ORE, EMERALD_ORE, COPPER_ORE, SNOW, GRAVEL, get_face_colors};
use crate::gpu::terrain::generation::{get_height, CaveParams, is_cave, noise3d};
use crate::gpu::terrain::mesh::TerrainVertex;
use crate::gpu::biomes::biome_selector;

use super::constants::{CHUNK_SIZE, WORLD_HEIGHT, MIN_HEIGHT};
use super::greedy::{greedy_mesh_layer_into, add_greedy_face_with_block, FaceDir, FaceInfo};
use super::context::MeshingContext;

/// Генерирует блок процедурно с учётом биома
fn generate_block(x: i32, y: i32, z: i32, terrain_height: i32, cave_ceiling: i32, cave_params: &CaveParams) -> BlockType {
    // Пещеры
    if y >= cave_params.min_height && y < cave_ceiling {
        if is_cave(x, y, z, cave_params) {
            return AIR;
        }
    }
    
    // Получаем биом для этой позиции
    let biome = biome_selector().get_biome_def(x, z);
    
    // Глубина от поверхности
    let depth = terrain_height - y;
    
    // Bedrock слой
    if y < MIN_HEIGHT + 3 {
        return DEEPSLATE;
    }
    
    // Проверяем руды (только под поверхностью)
    if depth > 0 {
        if let Some(ore) = generate_ore(x, y, z) {
            return ore;
        }
    }
    
    // Снег на высоких вершинах (выше 70)
    if y == terrain_height && terrain_height > 70 {
        return SNOW;
    }
    
    // Гравий на склонах гор (высота 50-70, случайно)
    if y == terrain_height && terrain_height > 50 && terrain_height <= 70 {
        let gravel_noise = noise3d(x as f32 * 0.1, y as f32 * 0.1, z as f32 * 0.1);
        if gravel_noise > 0.6 {
            return GRAVEL;
        }
    }
    
    if depth > 4 {
        // Глубоко под землёй - разнообразные камни
        return generate_stone_variety(x, y, z, biome.deep_block);
    } else if depth > 0 {
        // Под поверхностью
        biome.subsurface_block
    } else if y == terrain_height {
        // Поверхность
        biome.surface_block
    } else {
        AIR
    }
}

/// Генерация разнообразия камней (granite, diorite, andesite)
fn generate_stone_variety(x: i32, y: i32, z: i32, base_stone: BlockType) -> BlockType {
    // Крупные "жилы" разных типов камня
    let variety_noise = noise3d(x as f32 * 0.03, y as f32 * 0.03, z as f32 * 0.03);
    
    // Второй слой шума для более интересных форм
    let detail_noise = noise3d(x as f32 * 0.08 + 100.0, y as f32 * 0.08, z as f32 * 0.08 + 100.0);
    
    let combined = variety_noise * 0.7 + detail_noise * 0.3;
    
    if combined > 0.65 {
        GRANITE
    } else if combined > 0.55 {
        DIORITE  
    } else if combined < 0.35 {
        ANDESITE
    } else {
        base_stone
    }
}

/// Генерация руд
fn generate_ore(x: i32, y: i32, z: i32) -> Option<BlockType> {
    // Разные руды на разных глубинах
    
    // Уголь: -20 до 40, частый
    if y >= -20 && y <= 40 {
        let coal_noise = noise3d(x as f32 * 0.12 + 50.0, y as f32 * 0.12, z as f32 * 0.12 + 50.0);
        if coal_noise > 0.75 {
            return Some(COAL_ORE);
        }
    }
    
    // Медь: -30 до 30
    if y >= -30 && y <= 30 {
        let copper_noise = noise3d(x as f32 * 0.1 + 150.0, y as f32 * 0.1, z as f32 * 0.1 + 150.0);
        if copper_noise > 0.78 {
            return Some(COPPER_ORE);
        }
    }
    
    // Железо: -30 до 20
    if y >= -30 && y <= 20 {
        let iron_noise = noise3d(x as f32 * 0.11 + 200.0, y as f32 * 0.11, z as f32 * 0.11 + 200.0);
        if iron_noise > 0.77 {
            return Some(IRON_ORE);
        }
    }
    
    // Золото: -30 до 0, редкое
    if y >= -30 && y <= 0 {
        let gold_noise = noise3d(x as f32 * 0.09 + 300.0, y as f32 * 0.09, z as f32 * 0.09 + 300.0);
        if gold_noise > 0.82 {
            return Some(GOLD_ORE);
        }
    }
    
    // Изумруд: только в горах, -30 до 30
    if y >= -30 && y <= 30 {
        let emerald_noise = noise3d(x as f32 * 0.08 + 400.0, y as f32 * 0.08, z as f32 * 0.08 + 400.0);
        if emerald_noise > 0.88 {
            return Some(EMERALD_ORE);
        }
    }
    
    // Алмазы: -30 до -10, очень редкие
    if y >= -30 && y <= -10 {
        let diamond_noise = noise3d(x as f32 * 0.07 + 500.0, y as f32 * 0.07, z as f32 * 0.07 + 500.0);
        if diamond_noise > 0.9 {
            return Some(DIAMOND_ORE);
        }
    }
    
    None
}

/// Получить цвета для блока
#[inline]
fn get_block_colors(block: BlockType, _y: f32) -> ([f32; 3], [f32; 3]) {
    get_face_colors(block)
}

/// Воксельный чанк
pub struct VoxelChunk {
    blocks: Vec<BlockType>,
    pub chunk_x: i32,
    pub chunk_z: i32,
    pub min_y: i32,
    pub max_y: i32,
}

impl VoxelChunk {
    pub fn new(chunk_x: i32, chunk_z: i32, world_changes: &HashMap<BlockPos, BlockType>) -> Self {
        let total_height = (WORLD_HEIGHT - MIN_HEIGHT) as usize;
        let mut blocks = vec![AIR; CHUNK_SIZE as usize * CHUNK_SIZE as usize * total_height];
        
        let base_x = chunk_x * CHUNK_SIZE;
        let base_z = chunk_z * CHUNK_SIZE;
        let cave_params = CaveParams::default();
        
        let mut min_y = WORLD_HEIGHT;
        let mut max_y = MIN_HEIGHT;
        
        for lz in 0..CHUNK_SIZE {
            for lx in 0..CHUNK_SIZE {
                let world_x = base_x + lx;
                let world_z = base_z + lz;
                
                let terrain_height = get_height(world_x as f32, world_z as f32) as i32;
                let cave_ceiling = terrain_height - cave_params.surface_offset;
                
                for y in MIN_HEIGHT..WORLD_HEIGHT {
                    let pos = BlockPos::new(world_x, y, world_z);
                    
                    let block = if let Some(&changed) = world_changes.get(&pos) {
                        changed
                    } else {
                        generate_block(world_x, y, world_z, terrain_height, cave_ceiling, &cave_params)
                    };
                    
                    if block != AIR {
                        min_y = min_y.min(y);
                        max_y = max_y.max(y);
                    }
                    
                    let idx = Self::index(lx, y, lz);
                    blocks[idx] = block;
                }
            }
        }
        
        Self { blocks, chunk_x, chunk_z, min_y, max_y }
    }
    
    #[inline]
    fn index(lx: i32, y: i32, lz: i32) -> usize {
        let ly = y - MIN_HEIGHT;
        (ly as usize) * (CHUNK_SIZE as usize * CHUNK_SIZE as usize) 
            + (lz as usize) * (CHUNK_SIZE as usize) 
            + (lx as usize)
    }
    
    #[inline]
    pub fn get_local(&self, lx: i32, y: i32, lz: i32) -> BlockType {
        if lx < 0 || lx >= CHUNK_SIZE || lz < 0 || lz >= CHUNK_SIZE || y < MIN_HEIGHT || y >= WORLD_HEIGHT {
            return AIR;
        }
        self.blocks[Self::index(lx, y, lz)]
    }

    
    /// Zero-allocation генерация меша с использованием контекста
    pub fn generate_mesh_with_context(
        &self, 
        neighbors: &ChunkNeighbors, 
        ctx: &mut MeshingContext
    ) -> (Vec<TerrainVertex>, Vec<u32>) {
        ctx.clear_output();
        
        let base_x = self.chunk_x * CHUNK_SIZE;
        let base_z = self.chunk_z * CHUNK_SIZE;
        let chunk_size = CHUNK_SIZE as usize;
        
        self.generate_y_faces(neighbors, ctx, base_x, base_z, chunk_size);
        self.generate_x_faces(neighbors, ctx, base_x, base_z, chunk_size);
        self.generate_z_faces(neighbors, ctx, base_x, base_z, chunk_size);
        
        ctx.take_results()
    }
    
    #[inline]
    fn generate_y_faces(&self, neighbors: &ChunkNeighbors, ctx: &mut MeshingContext, base_x: i32, base_z: i32, chunk_size: usize) {
        for y in self.min_y..=self.max_y + 1 {
            ctx.clear_y_masks();
            
            for lz in 0..CHUNK_SIZE {
                for lx in 0..CHUNK_SIZE {
                    let idx = (lz as usize) * chunk_size + (lx as usize);
                    
                    if y > self.min_y {
                        let block = self.get_local(lx, y - 1, lz);
                        if block != AIR && block != WATER && self.is_face_visible(lx, y, lz, neighbors) {
                            ctx.y_buffers.mask_pos[idx] = Some(FaceInfo::new(block, true));
                        }
                    }
                    
                    if y <= self.max_y {
                        let block = self.get_local(lx, y, lz);
                        if block != AIR && block != WATER && self.is_face_visible(lx, y - 1, lz, neighbors) {
                            ctx.y_buffers.mask_neg[idx] = Some(FaceInfo::new(block, false));
                        }
                    }
                }
            }
            
            greedy_mesh_layer_into(&ctx.y_buffers.mask_pos[..chunk_size * chunk_size], &mut ctx.y_buffers.visited[..chunk_size * chunk_size], chunk_size, chunk_size, &mut ctx.greedy_results);
            for &(u, v, w, h, face) in &ctx.greedy_results {
                let (top_color, _) = get_block_colors(face.block_type, y as f32);
                add_greedy_face_with_block(&mut ctx.vertices, &mut ctx.indices, (base_x + u as i32) as f32, (y - 1) as f32, (base_z + v as i32) as f32, w as f32, h as f32, [0.0, 1.0, 0.0], top_color, FaceDir::PosY, face.block_type);
            }
            
            ctx.y_buffers.clear_visited(chunk_size * chunk_size);
            greedy_mesh_layer_into(&ctx.y_buffers.mask_neg[..chunk_size * chunk_size], &mut ctx.y_buffers.visited[..chunk_size * chunk_size], chunk_size, chunk_size, &mut ctx.greedy_results);
            for &(u, v, w, h, face) in &ctx.greedy_results {
                let (_, side_color) = get_block_colors(face.block_type, y as f32);
                add_greedy_face_with_block(&mut ctx.vertices, &mut ctx.indices, (base_x + u as i32) as f32, y as f32, (base_z + v as i32) as f32, w as f32, h as f32, [0.0, -1.0, 0.0], side_color, FaceDir::NegY, face.block_type);
            }
        }
    }

    
    #[inline]
    fn generate_x_faces(&self, neighbors: &ChunkNeighbors, ctx: &mut MeshingContext, base_x: i32, base_z: i32, chunk_size: usize) {
        let height_range = (self.max_y - self.min_y + 1) as usize;
        
        for lx in 0..=CHUNK_SIZE {
            ctx.clear_x_masks(height_range);
            
            for y in self.min_y..=self.max_y {
                for lz in 0..CHUNK_SIZE {
                    let y_idx = (y - self.min_y) as usize;
                    let idx = y_idx * chunk_size + (lz as usize);
                    
                    if lx > 0 {
                        let block = self.get_local(lx - 1, y, lz);
                        if block != AIR && block != WATER && self.is_face_visible(lx, y, lz, neighbors) {
                            ctx.x_buffers.mask_pos[idx] = Some(FaceInfo::new(block, false));
                        }
                    }
                    
                    if lx < CHUNK_SIZE {
                        let block = self.get_local(lx, y, lz);
                        if block != AIR && block != WATER && self.is_face_visible(lx - 1, y, lz, neighbors) {
                            ctx.x_buffers.mask_neg[idx] = Some(FaceInfo::new(block, false));
                        }
                    }
                }
            }
            
            let mask_size = chunk_size * height_range;
            
            greedy_mesh_layer_into(&ctx.x_buffers.mask_pos[..mask_size], &mut ctx.x_buffers.visited[..mask_size], chunk_size, height_range, &mut ctx.greedy_results);
            for &(u, v, w, h, face) in &ctx.greedy_results {
                let (_, side_color) = get_block_colors(face.block_type, (self.min_y + v as i32) as f32);
                add_greedy_face_with_block(&mut ctx.vertices, &mut ctx.indices, (base_x + lx - 1) as f32, (self.min_y + v as i32) as f32, (base_z + u as i32) as f32, w as f32, h as f32, [1.0, 0.0, 0.0], side_color, FaceDir::PosX, face.block_type);
            }
            
            ctx.x_buffers.clear_visited(mask_size);
            greedy_mesh_layer_into(&ctx.x_buffers.mask_neg[..mask_size], &mut ctx.x_buffers.visited[..mask_size], chunk_size, height_range, &mut ctx.greedy_results);
            for &(u, v, w, h, face) in &ctx.greedy_results {
                let (_, side_color) = get_block_colors(face.block_type, (self.min_y + v as i32) as f32);
                add_greedy_face_with_block(&mut ctx.vertices, &mut ctx.indices, (base_x + lx) as f32, (self.min_y + v as i32) as f32, (base_z + u as i32) as f32, w as f32, h as f32, [-1.0, 0.0, 0.0], side_color, FaceDir::NegX, face.block_type);
            }
        }
    }
    
    #[inline]
    fn generate_z_faces(&self, neighbors: &ChunkNeighbors, ctx: &mut MeshingContext, base_x: i32, base_z: i32, chunk_size: usize) {
        let height_range = (self.max_y - self.min_y + 1) as usize;
        
        for lz in 0..=CHUNK_SIZE {
            ctx.clear_z_masks(height_range);
            
            for y in self.min_y..=self.max_y {
                for lx in 0..CHUNK_SIZE {
                    let y_idx = (y - self.min_y) as usize;
                    let idx = y_idx * chunk_size + (lx as usize);
                    
                    if lz > 0 {
                        let block = self.get_local(lx, y, lz - 1);
                        if block != AIR && block != WATER && self.is_face_visible(lx, y, lz, neighbors) {
                            ctx.z_buffers.mask_pos[idx] = Some(FaceInfo::new(block, false));
                        }
                    }
                    
                    if lz < CHUNK_SIZE {
                        let block = self.get_local(lx, y, lz);
                        if block != AIR && block != WATER && self.is_face_visible(lx, y, lz - 1, neighbors) {
                            ctx.z_buffers.mask_neg[idx] = Some(FaceInfo::new(block, false));
                        }
                    }
                }
            }
            
            let mask_size = chunk_size * height_range;
            
            greedy_mesh_layer_into(&ctx.z_buffers.mask_pos[..mask_size], &mut ctx.z_buffers.visited[..mask_size], chunk_size, height_range, &mut ctx.greedy_results);
            for &(u, v, w, h, face) in &ctx.greedy_results {
                let (_, side_color) = get_block_colors(face.block_type, (self.min_y + v as i32) as f32);
                add_greedy_face_with_block(&mut ctx.vertices, &mut ctx.indices, (base_x + u as i32) as f32, (self.min_y + v as i32) as f32, (base_z + lz - 1) as f32, w as f32, h as f32, [0.0, 0.0, 1.0], side_color, FaceDir::PosZ, face.block_type);
            }
            
            ctx.z_buffers.clear_visited(mask_size);
            greedy_mesh_layer_into(&ctx.z_buffers.mask_neg[..mask_size], &mut ctx.z_buffers.visited[..mask_size], chunk_size, height_range, &mut ctx.greedy_results);
            for &(u, v, w, h, face) in &ctx.greedy_results {
                let (_, side_color) = get_block_colors(face.block_type, (self.min_y + v as i32) as f32);
                add_greedy_face_with_block(&mut ctx.vertices, &mut ctx.indices, (base_x + u as i32) as f32, (self.min_y + v as i32) as f32, (base_z + lz) as f32, w as f32, h as f32, [0.0, 0.0, -1.0], side_color, FaceDir::NegZ, face.block_type);
            }
        }
    }

    
    #[allow(dead_code)]
    pub fn generate_mesh(&self, neighbors: &ChunkNeighbors) -> (Vec<TerrainVertex>, Vec<u32>) {
        let mut ctx = MeshingContext::new();
        self.generate_mesh_with_context(neighbors, &mut ctx)
    }
    
    pub fn generate_mesh_section_with_context(&self, neighbors: &ChunkNeighbors, section_min_y: i32, section_max_y: i32, ctx: &mut MeshingContext) -> (Vec<TerrainVertex>, Vec<u32>) {
        ctx.clear_output();
        let base_x = self.chunk_x * CHUNK_SIZE;
        let base_z = self.chunk_z * CHUNK_SIZE;
        let chunk_size = CHUNK_SIZE as usize;
        let actual_min = section_min_y.max(self.min_y);
        let actual_max = section_max_y.min(self.max_y);
        if actual_min > actual_max { return ctx.take_results(); }
        
        // Simplified section mesh generation
        for y in actual_min..=actual_max + 1 {
            ctx.clear_y_masks();
            for lz in 0..CHUNK_SIZE {
                for lx in 0..CHUNK_SIZE {
                    let idx = (lz as usize) * chunk_size + (lx as usize);
                    if y > actual_min && y - 1 <= actual_max {
                        let block = self.get_local(lx, y - 1, lz);
                        if block != AIR && block != WATER && self.is_face_visible(lx, y, lz, neighbors) {
                            ctx.y_buffers.mask_pos[idx] = Some(FaceInfo::new(block, true));
                        }
                    }
                    if y >= actual_min && y <= actual_max {
                        let block = self.get_local(lx, y, lz);
                        if block != AIR && block != WATER && self.is_face_visible(lx, y - 1, lz, neighbors) {
                            ctx.y_buffers.mask_neg[idx] = Some(FaceInfo::new(block, false));
                        }
                    }
                }
            }
            greedy_mesh_layer_into(&ctx.y_buffers.mask_pos[..chunk_size * chunk_size], &mut ctx.y_buffers.visited[..chunk_size * chunk_size], chunk_size, chunk_size, &mut ctx.greedy_results);
            for &(u, v, w, h, face) in &ctx.greedy_results {
                let (top_color, _) = get_block_colors(face.block_type, y as f32);
                add_greedy_face_with_block(&mut ctx.vertices, &mut ctx.indices, (base_x + u as i32) as f32, (y - 1) as f32, (base_z + v as i32) as f32, w as f32, h as f32, [0.0, 1.0, 0.0], top_color, FaceDir::PosY, face.block_type);
            }
            ctx.y_buffers.clear_visited(chunk_size * chunk_size);
            greedy_mesh_layer_into(&ctx.y_buffers.mask_neg[..chunk_size * chunk_size], &mut ctx.y_buffers.visited[..chunk_size * chunk_size], chunk_size, chunk_size, &mut ctx.greedy_results);
            for &(u, v, w, h, face) in &ctx.greedy_results {
                let (_, side_color) = get_block_colors(face.block_type, y as f32);
                add_greedy_face_with_block(&mut ctx.vertices, &mut ctx.indices, (base_x + u as i32) as f32, y as f32, (base_z + v as i32) as f32, w as f32, h as f32, [0.0, -1.0, 0.0], side_color, FaceDir::NegY, face.block_type);
            }
        }
        ctx.take_results()
    }
    
    pub fn generate_mesh_section(&self, neighbors: &ChunkNeighbors, min_y: i32, max_y: i32) -> (Vec<TerrainVertex>, Vec<u32>) {
        let mut ctx = MeshingContext::new();
        self.generate_mesh_section_with_context(neighbors, min_y, max_y, &mut ctx)
    }
    
    #[inline]
    fn is_face_visible(&self, lx: i32, y: i32, lz: i32, neighbors: &ChunkNeighbors) -> bool {
        if lx >= 0 && lx < CHUNK_SIZE && lz >= 0 && lz < CHUNK_SIZE {
            if y < MIN_HEIGHT || y >= WORLD_HEIGHT { return y >= WORLD_HEIGHT; }
            return self.get_local(lx, y, lz) == AIR;
        }
        if lx < 0 { if let Some(neg_x) = neighbors.neg_x { return neg_x.get_local(CHUNK_SIZE - 1, y, lz) == AIR; } }
        else if lx >= CHUNK_SIZE { if let Some(pos_x) = neighbors.pos_x { return pos_x.get_local(0, y, lz) == AIR; } }
        if lz < 0 { if let Some(neg_z) = neighbors.neg_z { return neg_z.get_local(lx, y, CHUNK_SIZE - 1) == AIR; } }
        else if lz >= CHUNK_SIZE { if let Some(pos_z) = neighbors.pos_z { return pos_z.get_local(lx, y, 0) == AIR; } }
        true
    }
}

pub struct ChunkNeighbors<'a> {
    pub pos_x: Option<&'a VoxelChunk>,
    pub neg_x: Option<&'a VoxelChunk>,
    pub pos_z: Option<&'a VoxelChunk>,
    pub neg_z: Option<&'a VoxelChunk>,
}


============================================================
FILE: terrain\voxel\constants.rs
============================================================

// ============================================
// Voxel Constants - Константы воксельной системы
// ============================================

/// Размер чанка в блоках
pub const CHUNK_SIZE: i32 = 16;
/// Высота мира
pub const WORLD_HEIGHT: i32 = 128;
/// Минимальная высота (bedrock)
pub const MIN_HEIGHT: i32 = -32;


============================================================
FILE: terrain\voxel\context.rs
============================================================

// ============================================
// Meshing Context - Zero-allocation буферы
// ============================================
//
// Контекст для генерации мешей с переиспользуемыми буферами.
// Принцип "Alloc Once, Reuse Forever" - память выделяется один раз,
// затем только очищается через clear() сохраняя capacity.

use crate::gpu::terrain::mesh::TerrainVertex;
use super::constants::CHUNK_SIZE;
use super::greedy::FaceInfo;

/// Максимальный размер слоя для масок (16x16)
const LAYER_SIZE: usize = (CHUNK_SIZE as usize) * (CHUNK_SIZE as usize);

/// Максимальная высота для вертикальных масок
const MAX_HEIGHT: usize = 160; // WORLD_HEIGHT - MIN_HEIGHT

/// Размер вертикальной маски (16 * max_height)
const VERTICAL_MASK_SIZE: usize = (CHUNK_SIZE as usize) * MAX_HEIGHT;

/// Буферы для одного направления граней
#[derive(Default)]
pub struct FaceMaskBuffers {
    /// Маска положительного направления
    pub mask_pos: Vec<Option<FaceInfo>>,
    /// Маска отрицательного направления  
    pub mask_neg: Vec<Option<FaceInfo>>,
    /// Флаги посещённых ячеек для greedy meshing
    pub visited: Vec<bool>,
}

impl FaceMaskBuffers {
    /// Создаёт буферы с заданной ёмкостью
    pub fn with_capacity(size: usize) -> Self {
        Self {
            mask_pos: vec![None; size],
            mask_neg: vec![None; size],
            visited: vec![false; size],
        }
    }

    /// Очищает буферы, сохраняя capacity
    #[inline]
    pub fn clear(&mut self, size: usize) {
        // Заполняем None/false вместо clear() чтобы сохранить длину
        self.mask_pos[..size].fill(None);
        self.mask_neg[..size].fill(None);
        self.visited[..size].fill(false);
    }

    /// Очищает только visited буфер
    #[inline]
    pub fn clear_visited(&mut self, size: usize) {
        self.visited[..size].fill(false);
    }
}

/// Контекст генерации меша - содержит все переиспользуемые буферы
pub struct MeshingContext {
    /// Буферы для Y граней (горизонтальные слои 16x16)
    pub y_buffers: FaceMaskBuffers,
    /// Буферы для X граней (вертикальные слои 16xH)
    pub x_buffers: FaceMaskBuffers,
    /// Буферы для Z граней (вертикальные слои 16xH)
    pub z_buffers: FaceMaskBuffers,
    
    /// Выходной буфер вершин
    pub vertices: Vec<TerrainVertex>,
    /// Выходной буфер индексов
    pub indices: Vec<u32>,
    
    /// Временный буфер для результатов greedy meshing
    pub greedy_results: Vec<(usize, usize, usize, usize, FaceInfo)>,
}

impl MeshingContext {
    /// Создаёт новый контекст с преаллоцированными буферами
    pub fn new() -> Self {
        Self {
            y_buffers: FaceMaskBuffers::with_capacity(LAYER_SIZE),
            x_buffers: FaceMaskBuffers::with_capacity(VERTICAL_MASK_SIZE),
            z_buffers: FaceMaskBuffers::with_capacity(VERTICAL_MASK_SIZE),
            vertices: Vec::with_capacity(8000),
            indices: Vec::with_capacity(12000),
            greedy_results: Vec::with_capacity(256),
        }
    }

    /// Очищает выходные буферы перед генерацией нового меша
    #[inline]
    pub fn clear_output(&mut self) {
        self.vertices.clear();
        self.indices.clear();
    }

    /// Очищает буферы Y масок для нового слоя
    #[inline]
    pub fn clear_y_masks(&mut self) {
        self.y_buffers.clear(LAYER_SIZE);
    }

    /// Очищает буферы X масок для нового слоя
    #[inline]
    pub fn clear_x_masks(&mut self, height: usize) {
        let size = (CHUNK_SIZE as usize) * height;
        self.x_buffers.clear(size);
    }

    /// Очищает буферы Z масок для нового слоя
    #[inline]
    pub fn clear_z_masks(&mut self, height: usize) {
        let size = (CHUNK_SIZE as usize) * height;
        self.z_buffers.clear(size);
    }

    /// Возвращает результаты и очищает внутренние буферы
    #[inline]
    pub fn take_results(&mut self) -> (Vec<TerrainVertex>, Vec<u32>) {
        let vertices = std::mem::take(&mut self.vertices);
        let indices = std::mem::take(&mut self.indices);
        
        // Восстанавливаем capacity для следующего использования
        self.vertices = Vec::with_capacity(8000);
        self.indices = Vec::with_capacity(12000);
        
        (vertices, indices)
    }
}

impl Default for MeshingContext {
    fn default() -> Self {
        Self::new()
    }
}


============================================================
FILE: terrain\voxel\greedy.rs
============================================================

// ============================================
// Greedy Meshing - Оптимизация мешей
// ============================================

use crate::gpu::blocks::BlockType;
use crate::gpu::terrain::mesh::TerrainVertex;

#[derive(Clone, Copy)]
pub enum FaceDir {
    PosX, NegX, PosY, NegY, PosZ, NegZ,
}

#[derive(Clone, Copy, PartialEq, Eq)]
pub struct FaceInfo {
    pub block_type: BlockType,
    pub is_top: bool,
}

impl FaceInfo {
    #[inline]
    pub fn new(block_type: BlockType, is_top: bool) -> Self {
        Self { block_type, is_top }
    }
}

/// Zero-allocation greedy meshing для одного слоя
/// 
/// Записывает результаты в предоставленный буфер вместо создания нового Vec.
/// Буфер visited должен быть предварительно очищен (заполнен false).
#[inline]
pub fn greedy_mesh_layer_into(
    mask: &[Option<FaceInfo>],
    visited: &mut [bool],
    size_u: usize,
    size_v: usize,
    results: &mut Vec<(usize, usize, usize, usize, FaceInfo)>,
) {
    results.clear();
    
    for v in 0..size_v {
        for u in 0..size_u {
            let idx = v * size_u + u;
            if visited[idx] { continue; }
            
            let face = match mask[idx] {
                Some(f) => f,
                None => continue,
            };
            
            // Расширяем по U
            let mut width = 1;
            while u + width < size_u {
                let next_idx = v * size_u + (u + width);
                if visited[next_idx] || mask[next_idx] != Some(face) { break; }
                width += 1;
            }

            // Расширяем по V
            let mut height = 1;
            'outer: while v + height < size_v {
                for du in 0..width {
                    let check_idx = (v + height) * size_u + (u + du);
                    if visited[check_idx] || mask[check_idx] != Some(face) { break 'outer; }
                }
                height += 1;
            }
            
            // Помечаем как посещённые
            for dv in 0..height {
                for du in 0..width {
                    visited[(v + dv) * size_u + (u + du)] = true;
                }
            }
            
            results.push((u, v, width, height, face));
        }
    }
}

/// Legacy версия для обратной совместимости (создаёт новые Vec)
#[allow(dead_code)]
pub fn greedy_mesh_layer(
    mask: &[Option<FaceInfo>],
    size_u: usize,
    size_v: usize,
) -> Vec<(usize, usize, usize, usize, FaceInfo)> {
    let mut result = Vec::new();
    let mut visited = vec![false; size_u * size_v];
    greedy_mesh_layer_into(mask, &mut visited, size_u, size_v, &mut result);
    result
}

/// Добавляет объединённую грань в буферы
#[inline]
pub fn add_greedy_face(
    vertices: &mut Vec<TerrainVertex>,
    indices: &mut Vec<u32>,
    x: f32, y: f32, z: f32,
    width_u: f32, height_v: f32,
    normal: [f32; 3],
    color: [f32; 3],
    dir: FaceDir,
) {
    add_greedy_face_with_block(vertices, indices, x, y, z, width_u, height_v, normal, color, dir, 0);
}

/// Добавляет объединённую грань в буферы с block_id
#[inline]
pub fn add_greedy_face_with_block(
    vertices: &mut Vec<TerrainVertex>,
    indices: &mut Vec<u32>,
    x: f32, y: f32, z: f32,
    width_u: f32, height_v: f32,
    normal: [f32; 3],
    color: [f32; 3],
    dir: FaceDir,
    block_id: u8,
) {
    let base = vertices.len() as u32;
    let bid = block_id as u32;
    
    match dir {
        FaceDir::PosX => {
            let x1 = x + 1.0;
            vertices.push(TerrainVertex { position: [x1, y, z + width_u], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x1, y, z], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x1, y + height_v, z], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x1, y + height_v, z + width_u], normal, color, block_id: bid });
        }
        FaceDir::NegX => {
            vertices.push(TerrainVertex { position: [x, y, z], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x, y, z + width_u], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x, y + height_v, z + width_u], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x, y + height_v, z], normal, color, block_id: bid });
        }
        FaceDir::PosY => {
            let y1 = y + 1.0;
            vertices.push(TerrainVertex { position: [x, y1, z], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x, y1, z + height_v], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x + width_u, y1, z + height_v], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x + width_u, y1, z], normal, color, block_id: bid });
        }
        FaceDir::NegY => {
            vertices.push(TerrainVertex { position: [x, y, z + height_v], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x, y, z], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x + width_u, y, z], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x + width_u, y, z + height_v], normal, color, block_id: bid });
        }
        FaceDir::PosZ => {
            let z1 = z + 1.0;
            vertices.push(TerrainVertex { position: [x, y, z1], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x + width_u, y, z1], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x + width_u, y + height_v, z1], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x, y + height_v, z1], normal, color, block_id: bid });
        }
        FaceDir::NegZ => {
            vertices.push(TerrainVertex { position: [x + width_u, y, z], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x, y, z], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x, y + height_v, z], normal, color, block_id: bid });
            vertices.push(TerrainVertex { position: [x + width_u, y + height_v, z], normal, color, block_id: bid });
        }
    }
    
    indices.extend_from_slice(&[base, base + 1, base + 2, base, base + 2, base + 3]);
}


============================================================
FILE: terrain\voxel\mod.rs
============================================================

// ============================================
// Voxel Module - Воксельная система
// ============================================

pub mod constants;
pub mod context;
pub mod thread_local;

mod greedy;
mod chunk;

pub use constants::{CHUNK_SIZE, MIN_HEIGHT};
pub use context::MeshingContext;
pub use chunk::{VoxelChunk, ChunkNeighbors};

// Re-export для внутреннего использования
pub(crate) use greedy::{FaceDir, FaceInfo, greedy_mesh_layer_into, add_greedy_face};


============================================================
FILE: terrain\voxel\thread_local.rs
============================================================

// ============================================
// Thread-Local Context - Контексты для потоков
// ============================================
//
// Thread-local storage для MeshingContext.
// Каждый рабочий поток Rayon получает свой экземпляр контекста.

use std::cell::RefCell;
use super::context::MeshingContext;

thread_local! {
    /// Thread-local контекст для генерации мешей
    static MESHING_CONTEXT: RefCell<MeshingContext> = RefCell::new(MeshingContext::new());
}

/// Выполняет функцию с thread-local контекстом
/// 
/// # Пример
/// ```ignore
/// let (vertices, indices) = with_meshing_context(|ctx| {
///     // использовать ctx для генерации меша
///     ctx.take_results()
/// });
/// ```
#[inline]
#[allow(dead_code)]
pub fn with_meshing_context<F, R>(f: F) -> R
where
    F: FnOnce(&mut MeshingContext) -> R,
{
    MESHING_CONTEXT.with(|ctx| {
        let mut ctx = ctx.borrow_mut();
        f(&mut ctx)
    })
}


